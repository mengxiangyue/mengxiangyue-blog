{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"source/images/2015.12.27.10.png","path":"images/2015.12.27.10.png","modified":1},{"_id":"source/images/2015.12.27.09.png","path":"images/2015.12.27.09.png","modified":1},{"_id":"source/images/2015.12.27.08.png","path":"images/2015.12.27.08.png","modified":1},{"_id":"source/images/2015.12.27.07.png","path":"images/2015.12.27.07.png","modified":1},{"_id":"source/images/2015.12.27.06.png","path":"images/2015.12.27.06.png","modified":1},{"_id":"source/images/2015.12.27.05.png","path":"images/2015.12.27.05.png","modified":1},{"_id":"source/images/2015.12.27.04.png","path":"images/2015.12.27.04.png","modified":1},{"_id":"source/images/2015.12.27.03.png","path":"images/2015.12.27.03.png","modified":1},{"_id":"source/images/2015.12.27.02.png","path":"images/2015.12.27.02.png","modified":1},{"_id":"source/images/2015.12.27.01.png","path":"images/2015.12.27.01.png","modified":1},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","path":"images/2015.12.23.NavigationBarTest.gif","modified":1},{"_id":"source/images/2015.12.19.06.png","path":"images/2015.12.19.06.png","modified":1},{"_id":"source/images/2015.12.19.05.png","path":"images/2015.12.19.05.png","modified":1},{"_id":"source/images/2015.12.19.04.png","path":"images/2015.12.19.04.png","modified":1},{"_id":"source/images/2015.12.19.03.png","path":"images/2015.12.19.03.png","modified":1},{"_id":"source/images/2015.12.19.02.png","path":"images/2015.12.19.02.png","modified":1},{"_id":"source/images/2015.12.19.01.png","path":"images/2015.12.19.01.png","modified":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","path":"img/mengxiangyue.jpg","modified":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/jacman/source/img/logo-back.png","path":"img/logo-back.png","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/images/2016.01.04.01.png","path":"images/2016.01.04.01.png","modified":1},{"_id":"source/images/2016.01.04.02.png","path":"images/2016.01.04.02.png","modified":1},{"_id":"source/images/2016.01.04.03.png","path":"images/2016.01.04.03.png","modified":1},{"_id":"source/images/2016.01.04.04.png","path":"images/2016.01.04.04.png","modified":1},{"_id":"source/images/2016.01.04.05.png","path":"images/2016.01.04.05.png","modified":1},{"_id":"source/images/2016.01.04.06.png","path":"images/2016.01.04.06.png","modified":1},{"_id":"source/images/2016.01.04.07.png","path":"images/2016.01.04.07.png","modified":1},{"_id":"source/images/2016.01.04.08.png","path":"images/2016.01.04.08.png","modified":1},{"_id":"source/images/2016.01.04.09.png","path":"images/2016.01.04.09.png","modified":1},{"_id":"source/images/2016.01.04.10.png","path":"images/2016.01.04.10.png","modified":1},{"_id":"source/images/2016.01.04.11.png","path":"images/2016.01.04.11.png","modified":1},{"_id":"source/images/2016.01.04.12.png","path":"images/2016.01.04.12.png","modified":1},{"_id":"source/images/2016.01.04.13.png","path":"images/2016.01.04.13.png","modified":1}],"Cache":[{"_id":"source/CNAME","shasum":"82a91d02385750292b82a7d6b3734c8d98a928be","modified":1450112345000},{"_id":"source/_posts/Hexo结合Github-Pages搭建静态博客.md","shasum":"cfda02059e8a1c6ca0eb3434e3fdf71d5fda361c","modified":1450579367000},{"_id":"source/_posts/iOS-NavigationBar手势返回的时候跟随.md","shasum":"6c32668ab9b22a11c41538f2ee21971d221a3e0b","modified":1450886535000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记四：APP-瘦身.md","shasum":"11d035cad8491ee846a392b6e7582c3309da1095","modified":1452010893000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","shasum":"974a44e2052be062a8e450f9c871454eb020b757","modified":1451179480000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web.md","shasum":"523e1a4b2ecb1b91bb2cc5c447db5a665ae4bf60","modified":1451218895000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记二：App-Search.md","shasum":"e4e31d9a4d7bf9b3956173078d9e06f2f6f40b28","modified":1451188628000},{"_id":"source/about/index.md","shasum":"275236c2371c3501bf390165a8511172469e7ab7","modified":1450499801000},{"_id":"source/images/2015.12.19.03.png","shasum":"b2230e53726b0213972a7f341e44499e0aa3eb08","modified":1450522668000},{"_id":"source/images/2015.12.19.05.png","shasum":"ee6cb6d8d3ba4f298575de57f1aa3eb119ad45bc","modified":1450524952000},{"_id":"source/images/2015.12.19.06.png","shasum":"5dbc917107cd31245445b190dca5b726c0dfd10e","modified":1450529338000},{"_id":"source/images/2015.12.27.09.png","shasum":"ac9a597544fefe0469593cd509a304fb1cc7583f","modified":1451216622000},{"_id":"source/images/2015.12.27.03.png","shasum":"29c1d4674928ca72b7decd429e35acac1491e0fc","modified":1451185706000},{"_id":"source/images/2015.12.19.02.png","shasum":"1b4e204bbe1e798c3ebd4c209b1b51e68059231e","modified":1450521943000},{"_id":"source/images/2015.12.27.05.png","shasum":"67c20eb12968871809061ae949bccd62533e560d","modified":1451186134000},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","shasum":"c78d77a76a397b0848874414fc1f335ae60dee8c","modified":1450885231000},{"_id":"source/images/2015.12.27.10.png","shasum":"dc146f271092b9405f9aca1d7ded70dc803df379","modified":1451216979000},{"_id":"source/images/2015.12.19.01.png","shasum":"021c02950ab5581da6c035e40fb94e3b1a56ae1e","modified":1450521146000},{"_id":"source/images/2015.12.19.04.png","shasum":"880191f1f6ad386668bf9f70bec795e1a8d978b8","modified":1450523879000},{"_id":"source/images/2015.12.27.04.png","shasum":"eea4e6298c8428992719a69d6fc0e35e2cb178f5","modified":1451185941000},{"_id":"source/images/2015.12.27.06.png","shasum":"42482ba521b8763546d41321679275fb8d4e58b9","modified":1451187720000},{"_id":"source/images/2015.12.27.07.png","shasum":"a952df1bc709cf70e556c5b99005ac5a20f84bf1","modified":1451212547000},{"_id":"source/images/2015.12.27.02.png","shasum":"68adcfd852ced036bebd1dd6f91f2a5442bcb356","modified":1451183696000},{"_id":"source/images/2015.12.27.01.png","shasum":"97f4ed423f1773a82af22e6a662c532bc7fec883","modified":1451183581000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1450111304000},{"_id":"themes/jacman/_config.yml","shasum":"f11a10f5308afb72990e4d60ff26049794ca701a","modified":1450577640000},{"_id":"themes/jacman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1450111304000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"b79534df2651b79dca54ec17829a514ff55ecb46","modified":1450530033000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"c645e8a77b5b13baf31a69da8365942747cb214f","modified":1450492919000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"facd1ecd2d45d0d6eb8dbf0b11be0a1be3c07613","modified":1450493978000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"89f22cb6086c5244ecd01da3bb17d70f68e7d07f","modified":1450500196000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"08119290adc3a7b0f0fe7b83699758569005c5bf","modified":1450502090000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b4c151839cb6ac81477db44ee1748aea4c37c8c8","modified":1450526363000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1450111304000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1450111304000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1450111304000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1450111304000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1450111304000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450111304000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1450111304000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1450111304000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"a0095f49f3531d777cb34513a64d367b742e5c14","modified":1450497664000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450111304000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450111304000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450111304000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"53a9b87b9937fe6513a5da328909f94add3fbf79","modified":1450499063000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450111304000},{"_id":"themes/jacman/source/img/logo.png","shasum":"29d05f497fc1aa9ecebd753b0e2e21241ed1fe0a","modified":1450503556000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450111304000},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","shasum":"2563a79fce9ec04dc3b14545aeff3a56f81dd4d1","modified":1450498875000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1450111304000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1450111304000},{"_id":"source/images/2015.12.27.08.png","shasum":"fc55480beb9ab8110d216103102329e82ec85d39","modified":1451214664000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1450111304000},{"_id":"themes/jacman/source/js/totop.js","shasum":"5a9ea00aa54adb83015f514690894bc123855bc3","modified":1450503375000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1450111304000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"15de0631d5ccae00a8b2990ad957cfb51f58bc27","modified":1450491067000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450111304000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1450111304000},{"_id":"themes/jacman/source/img/logo-back.png","shasum":"eafdece1be127ff95553a02976076653d5c0a422","modified":1450497033000},{"_id":"source/images/2016.01.04.01.png","shasum":"22154f5d0838a83351322a423b3dee6bd0b8fc42","modified":1451920229000},{"_id":"source/images/2016.01.04.02.png","shasum":"1ef8ec8c1174d80add8c51bf7caa7d70cae994ac","modified":1451921940000},{"_id":"source/images/2016.01.04.03.png","shasum":"de6833aed73595d51812496fbc9e03db729bfeb9","modified":1451922071000},{"_id":"source/images/2016.01.04.04.png","shasum":"9fbb04d36692482fbcd935529ff71f5f17b3de2a","modified":1451922170000},{"_id":"source/images/2016.01.04.05.png","shasum":"d855f15d3d22d32bf5bdaea6051b3ddef5519800","modified":1451922503000},{"_id":"source/images/2016.01.04.06.png","shasum":"a74d6b8624bade41d9c404c70ecfe044fa6ad745","modified":1452002849000},{"_id":"source/images/2016.01.04.07.png","shasum":"5b9352b8143e25327a8a6f947418d5f05d77d788","modified":1452003844000},{"_id":"source/images/2016.01.04.08.png","shasum":"01c2806071235f2c816b3fa0825f362f77a54857","modified":1452004167000},{"_id":"source/images/2016.01.04.09.png","shasum":"22a8c2a9b2b977cffe20c79f38a0d4d204a4d293","modified":1452004507000},{"_id":"source/images/2016.01.04.10.png","shasum":"25c465fbd9f6fda776f5fee047466bb1a9b674a1","modified":1452006859000},{"_id":"source/images/2016.01.04.11.png","shasum":"4e4be76eddadda24c7868d674fca813a60000a87","modified":1452007063000},{"_id":"source/images/2016.01.04.12.png","shasum":"9af887b91f35bab2f124f70f3ed043139d88108e","modified":1452009613000},{"_id":"source/images/2016.01.04.13.png","shasum":"5e9c5e3ec47cb2d53853ebf5286a962fe240f4c7","modified":1452010088000}],"Category":[{"name":"iOS 9 by Tutoials","_id":"cij028hb10003316e8a3ed8sg"},{"name":"iOS Tips","_id":"cij028hbq000e316em29bq52g"},{"name":"工具","_id":"cij028hbw000h316euxcmuaq2"}],"Data":[],"Page":[{"title":"about","date":"2015-12-19T04:36:01.000Z","_content":"\n写点什么呢。。。。。。。。\n","source":"about/index.md","raw":"title: about\ndate: 2015-12-19 12:36:01\n---\n\n写点什么呢。。。。。。。。\n","updated":"2015-12-19T04:36:41.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cij028hak0000316epe10vbmo"}],"Post":[{"title":"iOS9 by Tutorials 学习笔记四：APP 瘦身","date":"2016-01-04T14:26:09.000Z","_content":"\n>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。   \n\niPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。同样这些技术及设备的变化给我在开发的过程中也造成了许多的问题，但是苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。但是Universal App虽然在开发的过程中，方便了我们开发人员，但是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但是真正的在运行的时候，我们并不需要那么多相关的代码及资源。    \n\n例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：\n![](/images/2016.01.04.01.png)   \n\n上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：\n\n<!---more--->\n\n* App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  \n* On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。\n* Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   \n\n这三个技术加起来，统一称为App Thinning。\n\n### Getting started   \n打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：\n![](/images/2016.01.04.02.png)\n\n伴随着模拟器启动起来的还打开了一个Finder窗口：  \n![](/images/2016.01.04.03.png)\n\n这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：\n![](/images/2016.01.04.04.png)\n{% codeblock lang:bin %}\necho \"App Size in KB:  `du -sk \\\"${CONFIGURATION_BUILD_DIR}/${EXECUTABLE_NAME}.app\\\"`\"\nif [ \"${CONFIGURATION}\" = \"Debug\" ]; then\nopen ${CONFIGURATION_BUILD_DIR}\nfi\n{% endcodeblock %}   \n\n在Finder的Old CA Maps点击右键，选择显示包内容，如下：\n![](/images/2016.01.04.05.png)   \n\n上图中标注的说明如下：\n1. Assets.car是Assets.xcassets被Xcode进行编译后的文件。\n2. Old CA Maps是真实运行在设备上的可执行文件。\n3. Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。\n4. SD_Map.bundle 这个就是地图图片文件，但是将近120MB。\n\n#### Measuring your work   \n本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：\n![](/images/2016.01.04.06.png)   \n\n### Slicing up app slicing\nApp slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    \n\n**Executable slicing** 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   \n\n默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。\n\n#### Being smart with resources\n**Resource slicing** 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，需要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 **Memory** 和 **Graphics** ，如下：\n![](/images/2016.01.04.07.png)\n\n##### Your first fix\n在开始的时候介绍过Santa Cruz PNGs这个文件被放到Main bundle中，所以不能被编译进入到Assets.car，所以不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：\n![](/images/2016.01.04.08.png)\n\n选择New Image Set后，然后将新加入的set命名为Santa Cruz，然后做如下操作：\n![](/images/2016.01.04.09.png)  \n> 纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   \n\n然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   \n\n##### Lazily (down)loading content\n苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。\n\n##### Wire things up to use tags\n下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：\n{% codeblock lang:swift %}\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n{% endcodeblock %}    \n\n这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：\n![](/images/2016.01.04.10.png)\n\n然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。\n![](/images/2016.01.04.11.png)  \n\n>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   \n\n#### Make it download faster   \n在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：\n{% codeblock lang:swift %}\n// add 为新添加的 ProgressView是程序已经添加上的\nprivate func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n  guard let bundleTitle = mapOverlayData?.bundleTitle else {\n    return\n  }\n\n  let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n  bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n  loadingProgressView.observedProgress = bundleResource.progress // add\n\n  loadingProgressView.hidden = false // add\n  UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n  bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n    NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n      self?.loadingProgressView.hidden = true // add\n      UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n      if error == nil {\n        self?.displayOverlayFromBundle(bundleResource.bundle)\n      }\n    })\n  }\n\n}\n{% endcodeblock %}\n\n> 如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。\n\n#### The many flavors of tagging\n虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。\n\n##### Initial install tags  \n使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：\n* **Initial Install Tags** 在ipa下载的时候一同下载\n* **Prefetched Tag Order** 在程序下载完成后，下载对应的资源，然后按顺序排列。\n* **Prefetched Tag Order** 按需下载   \n下面是配置的地方：\n![](/images/2016.01.04.12.png)  \n\n#### Purging content\n应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：\n![](/images/2016.01.04.13.png)  \n\n##### Set a resource to be purged   \n在MapChromeViewController.swift添加如下代码：\n{% codeblock lang:swift %}\n  // new add 是新加的代码\n  var overlayBundleResource: NSBundleResourceRequest? // new add\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n    overlayBundleResource = bundleResource // new add\n\n    bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n    loadingProgressView.observedProgress = bundleResource.progress // add\n\n    loadingProgressView.hidden = false // add\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        self?.loadingProgressView.hidden = true // add\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n\n  // new add\n  override func viewDidDisappear(animated: Bool) {\n    super.viewDidDisappear(animated)\n    // 告诉系统结束了对资源的访问\n    overlayBundleResource?.endAccessingResources()\n  }\n{% endcodeblock %}\n\n上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。\n\n坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。\n","source":"_posts/iOS9-by-Tutorials-学习笔记四：APP-瘦身.md","raw":"title: iOS9 by Tutorials 学习笔记四：APP 瘦身\ndate: 2016-01-04 22:26:09\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。   \n\niPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。同样这些技术及设备的变化给我在开发的过程中也造成了许多的问题，但是苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。但是Universal App虽然在开发的过程中，方便了我们开发人员，但是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但是真正的在运行的时候，我们并不需要那么多相关的代码及资源。    \n\n例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：\n![](/images/2016.01.04.01.png)   \n\n上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：\n\n<!---more--->\n\n* App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  \n* On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。\n* Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   \n\n这三个技术加起来，统一称为App Thinning。\n\n### Getting started   \n打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：\n![](/images/2016.01.04.02.png)\n\n伴随着模拟器启动起来的还打开了一个Finder窗口：  \n![](/images/2016.01.04.03.png)\n\n这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：\n![](/images/2016.01.04.04.png)\n{% codeblock lang:bin %}\necho \"App Size in KB:  `du -sk \\\"${CONFIGURATION_BUILD_DIR}/${EXECUTABLE_NAME}.app\\\"`\"\nif [ \"${CONFIGURATION}\" = \"Debug\" ]; then\nopen ${CONFIGURATION_BUILD_DIR}\nfi\n{% endcodeblock %}   \n\n在Finder的Old CA Maps点击右键，选择显示包内容，如下：\n![](/images/2016.01.04.05.png)   \n\n上图中标注的说明如下：\n1. Assets.car是Assets.xcassets被Xcode进行编译后的文件。\n2. Old CA Maps是真实运行在设备上的可执行文件。\n3. Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。\n4. SD_Map.bundle 这个就是地图图片文件，但是将近120MB。\n\n#### Measuring your work   \n本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：\n![](/images/2016.01.04.06.png)   \n\n### Slicing up app slicing\nApp slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    \n\n**Executable slicing** 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   \n\n默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。\n\n#### Being smart with resources\n**Resource slicing** 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，需要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 **Memory** 和 **Graphics** ，如下：\n![](/images/2016.01.04.07.png)\n\n##### Your first fix\n在开始的时候介绍过Santa Cruz PNGs这个文件被放到Main bundle中，所以不能被编译进入到Assets.car，所以不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：\n![](/images/2016.01.04.08.png)\n\n选择New Image Set后，然后将新加入的set命名为Santa Cruz，然后做如下操作：\n![](/images/2016.01.04.09.png)  \n> 纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   \n\n然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   \n\n##### Lazily (down)loading content\n苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。\n\n##### Wire things up to use tags\n下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：\n{% codeblock lang:swift %}\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n{% endcodeblock %}    \n\n这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：\n![](/images/2016.01.04.10.png)\n\n然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。\n![](/images/2016.01.04.11.png)  \n\n>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   \n\n#### Make it download faster   \n在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：\n{% codeblock lang:swift %}\n// add 为新添加的 ProgressView是程序已经添加上的\nprivate func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n  guard let bundleTitle = mapOverlayData?.bundleTitle else {\n    return\n  }\n\n  let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n  bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n  loadingProgressView.observedProgress = bundleResource.progress // add\n\n  loadingProgressView.hidden = false // add\n  UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n  bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n    NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n      self?.loadingProgressView.hidden = true // add\n      UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n      if error == nil {\n        self?.displayOverlayFromBundle(bundleResource.bundle)\n      }\n    })\n  }\n\n}\n{% endcodeblock %}\n\n> 如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。\n\n#### The many flavors of tagging\n虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。\n\n##### Initial install tags  \n使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：\n* **Initial Install Tags** 在ipa下载的时候一同下载\n* **Prefetched Tag Order** 在程序下载完成后，下载对应的资源，然后按顺序排列。\n* **Prefetched Tag Order** 按需下载   \n下面是配置的地方：\n![](/images/2016.01.04.12.png)  \n\n#### Purging content\n应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：\n![](/images/2016.01.04.13.png)  \n\n##### Set a resource to be purged   \n在MapChromeViewController.swift添加如下代码：\n{% codeblock lang:swift %}\n  // new add 是新加的代码\n  var overlayBundleResource: NSBundleResourceRequest? // new add\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n    overlayBundleResource = bundleResource // new add\n\n    bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n    loadingProgressView.observedProgress = bundleResource.progress // add\n\n    loadingProgressView.hidden = false // add\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        self?.loadingProgressView.hidden = true // add\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n\n  // new add\n  override func viewDidDisappear(animated: Bool) {\n    super.viewDidDisappear(animated)\n    // 告诉系统结束了对资源的访问\n    overlayBundleResource?.endAccessingResources()\n  }\n{% endcodeblock %}\n\n上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。\n\n坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。\n","slug":"iOS9-by-Tutorials-学习笔记四：APP-瘦身","published":1,"updated":"2016-01-05T16:21:33.000Z","_id":"cij028haq0001316ekxpaqfjf","comments":1,"layout":"post","photos":[],"link":""},{"title":"iOS9 by Tutorials 学习笔记二：App Search","date":"2015-12-27T03:52:58.000Z","_content":"> 本文为自己读书的一个总结，可能与原书有一定出入  \n\niOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：\n* NSUserActivity\n* Core Spotlight\n* Web markup\n\n下面简单的说一下我对于这三个API的理解：\n1. NSUserActivity:   \nNSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   \n2. Core Spotlight:   \n这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    \n3. Web markup:    \nWeb Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。\n\n<!--more-->\n\n###  Getting started\n下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：\n![](/images/2015.12.27.01.png)    \n\n下面是这个工程的截图：\n![](/images/2015.12.27.02.png)    \n\n下面是图中标注的几个关键类的解释：\n1. AppDelegate     \n  点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    \n2. EmployeeViewController    \n  人员的详细界面，这个里面主要设置NSUserActivity    \n3. EmployeeService    \n  这个主要是写CoreSpotlight中index相关的东西    \n4. EmployeeSearch    \n  主要是扩展了Employee类，添加了与搜索相关的属性    \n另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    \n\n在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  \n* Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容\n* ViewedRecords 只有打开过的才能够被搜索到  \n* AllRecords 所有的员工信息都能够被搜索到   \n\n#### 搜索我们已经打开过的内容   \n使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：\n1. 创建NSUserActivity的一个实例，设置相关的属性\n2. 赋值给UIViewController的userActivity属性   \n\n下面我们在EmployeeSearch中添加如下代码：  \n> 如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   \n\n{% codeblock lang:swift %}\nimport Foundation\nimport CoreSpotlight\n\nextension Employee {\n  // 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到\n  public static let domainIdentifier = \"com.mengxiangyue.colleagues.employee\"\n  // 字典 在处理点击的时候，可以根据该字典获取我们想要的数据\n  public var userActivityUserInfo: [NSObject: AnyObject] {\n    return [\"id\": objectId]\n  }\n\n  // 给Employee添加userActivity属性，主要是方便我们获取userActivity\n  public var userActivity: NSUserActivity {\n    let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n    activity.title = name  // 显示的名字\n    activity.userInfo = userActivityUserInfo  // 与该Activity相关的数据\n    activity.keywords = [email, department]  // 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索\n    return activity\n  }\n}  \n{% endcodeblock %}\n这里扩展了Employee，然后添加了几个属性，属性的意义见注释。  \n这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   \n\n下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：\n{% codeblock lang:swift %}\nlet activity = employee.userActivity\nswitch Setting.searchIndexingPreference {\ncase .Disabled:\n  activity.eligibleForSearch = false\ncase .ViewedRecords:\n  activity.eligibleForSearch = true\n  // relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复\n  activity.contentAttributeSet?.relatedUniqueIdentifier = nil\ncase .AllRecords:\n  activity.eligibleForSearch = true\n}\n\nuserActivity = activity\n{% endcodeblock %}   \n\n下面在该类中添加如下的方法，用于在合适的时机更新Activity：\n{% codeblock lang:swift %}\n// 更新NSUserActivity关联的信息\n  override func updateUserActivityState(activity: NSUserActivity) {\n    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)\n  }\n{% endcodeblock %}  \n\n下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：  \n![](/images/2015.12.27.03.png)   \n\n看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：  \n![](/images/2015.12.27.04.png)   \n\n下面我们在EmployeeSearch.swift添加如下属性：\n\n{% codeblock lang:swift %}\npublic var attributeSet: CSSearchableItemAttributeSet {\n  let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact as String)\n  attributeSet.title = name  // 不太清楚是干啥的\n  attributeSet.contentDescription = \"\\(department), \\(title)\\n\\(phone)\"\n  attributeSet.thumbnailData = UIImageJPEGRepresentation(loadPicture(), 0.9)\n  attributeSet.supportsPhoneCall = true\n  attributeSet.phoneNumbers = [phone]\n  attributeSet.emailAddresses = [email]\n  attributeSet.keywords = skills\n  attributeSet.relatedUniqueIdentifier = objectId  \n\n  return attributeSet\n}\n{% endcodeblock %}  \n\n然后将给userActivity添加如下属性：   \n\n{% codeblock lang:swift %}\npublic var userActivity: NSUserActivity {\n  let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n  activity.title = name\n  activity.userInfo = userActivityUserInfo\n  activity.keywords = [email, department]\n  activity.contentAttributeSet = attributeSet   // 新添加的这一行\n  return activity\n}\n{% endcodeblock %}  \n\n然后运行程序，搜索结果如下：\n![](/images/2015.12.27.05.png)   \n\n但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：\n\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n  let objectId: String\n  // 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId\n  if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n    objectId = activityObjectId\n  }\n  // 获取对应Employee实例 然后跳转到对应的界面\n  if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n    nav.popToRootViewControllerAnimated(false)\n    let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n    employeeViewController.employee = employee\n    nav.pushViewController(employeeViewController, animated: false)\n    return true\n  }\n  return false\n}   \n{% endcodeblock %}\n这时候我们再点击搜索结果就能够跳转到对应的详细界面了。\n\n### CoreSpotlight\n下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：\n\n{% codeblock lang:swift %}\n// 在前面的代码中已经设置过了\nattributeSet.relatedUniqueIdentifier = objectId\n{% endcodeblock %}\n这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   \n\n然后在EmployeeSearch.swift添加如下的代码：\n\n{% codeblock lang:swift %}\n// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用\nvar searchableItem: CSSearchableItem {\n  let item = CSSearchableItem(uniqueIdentifier: objectId, domainIdentifier: Employee.domainIdentifier, attributeSet: attributeSet)\n  return item\n}\n{% endcodeblock %}   \n\n然后在EmployeeService.swift添加如下代码：  \n\n{% codeblock lang:swift %}   \nimport CoreSpotlight\n\n..............<省略一部分代码>\n\npublic func indexAllEmployees() {\n  let employees = fetchEmployees()\n  let searchableItems = employees.map{ $0.searchableItem }\n  // 将我们需要被索引的item放入到defaultSearchableIndex中\n  CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in\n    if let error = error {\n      print(\"Error indexing employees: \\(error)\")\n    } else {\n      print(\"Employees indexed.\")\n    }\n  }\n}\n{% endcodeblock %}   \n然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：\n![](/images/2015.12.27.06.png)\n\n但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n    let objectId: String\n    if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n      objectId = activityObjectId\n    }\n    // 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   \n    // CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值\n    else if userActivity.activityType == CSSearchableItemActionType, let activityObjectId = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String {\n      objectId = activityObjectId\n    } else {\n      return false\n    }\n    if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n      nav.popToRootViewControllerAnimated(false)\n      let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n      employeeViewController.employee = employee\n      nav.pushViewController(employeeViewController, animated: false)\n      return true\n    }\n    return false\n  }\n{% endcodeblock %}   \n这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   \n\n### 删除Item\n最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：\n{% codeblock lang:swift %}\npublic func destroyEmployeeIndexing() {\n  CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -> Void in\n    if let error = error {\n      print(\"Error deleting searching employee items: \\(error)\")\n    } else {\n      print(\"Employees indexing deleted.\")\n    }\n  }\n}\n{% endcodeblock %}\n这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   \n\n另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:[CoreSpotlight.framework注释翻译](http://blog.csdn.net/mengxiangyue/article/details/46575977)\n","source":"_posts/iOS9-by-Tutorials-学习笔记二：App-Search.md","raw":"title: iOS9 by Tutorials 学习笔记二：App Search\ndate: 2015-12-27 11:52:58\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n> 本文为自己读书的一个总结，可能与原书有一定出入  \n\niOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：\n* NSUserActivity\n* Core Spotlight\n* Web markup\n\n下面简单的说一下我对于这三个API的理解：\n1. NSUserActivity:   \nNSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   \n2. Core Spotlight:   \n这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    \n3. Web markup:    \nWeb Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。\n\n<!--more-->\n\n###  Getting started\n下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：\n![](/images/2015.12.27.01.png)    \n\n下面是这个工程的截图：\n![](/images/2015.12.27.02.png)    \n\n下面是图中标注的几个关键类的解释：\n1. AppDelegate     \n  点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    \n2. EmployeeViewController    \n  人员的详细界面，这个里面主要设置NSUserActivity    \n3. EmployeeService    \n  这个主要是写CoreSpotlight中index相关的东西    \n4. EmployeeSearch    \n  主要是扩展了Employee类，添加了与搜索相关的属性    \n另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    \n\n在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  \n* Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容\n* ViewedRecords 只有打开过的才能够被搜索到  \n* AllRecords 所有的员工信息都能够被搜索到   \n\n#### 搜索我们已经打开过的内容   \n使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：\n1. 创建NSUserActivity的一个实例，设置相关的属性\n2. 赋值给UIViewController的userActivity属性   \n\n下面我们在EmployeeSearch中添加如下代码：  \n> 如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   \n\n{% codeblock lang:swift %}\nimport Foundation\nimport CoreSpotlight\n\nextension Employee {\n  // 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到\n  public static let domainIdentifier = \"com.mengxiangyue.colleagues.employee\"\n  // 字典 在处理点击的时候，可以根据该字典获取我们想要的数据\n  public var userActivityUserInfo: [NSObject: AnyObject] {\n    return [\"id\": objectId]\n  }\n\n  // 给Employee添加userActivity属性，主要是方便我们获取userActivity\n  public var userActivity: NSUserActivity {\n    let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n    activity.title = name  // 显示的名字\n    activity.userInfo = userActivityUserInfo  // 与该Activity相关的数据\n    activity.keywords = [email, department]  // 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索\n    return activity\n  }\n}  \n{% endcodeblock %}\n这里扩展了Employee，然后添加了几个属性，属性的意义见注释。  \n这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   \n\n下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：\n{% codeblock lang:swift %}\nlet activity = employee.userActivity\nswitch Setting.searchIndexingPreference {\ncase .Disabled:\n  activity.eligibleForSearch = false\ncase .ViewedRecords:\n  activity.eligibleForSearch = true\n  // relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复\n  activity.contentAttributeSet?.relatedUniqueIdentifier = nil\ncase .AllRecords:\n  activity.eligibleForSearch = true\n}\n\nuserActivity = activity\n{% endcodeblock %}   \n\n下面在该类中添加如下的方法，用于在合适的时机更新Activity：\n{% codeblock lang:swift %}\n// 更新NSUserActivity关联的信息\n  override func updateUserActivityState(activity: NSUserActivity) {\n    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)\n  }\n{% endcodeblock %}  \n\n下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：  \n![](/images/2015.12.27.03.png)   \n\n看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：  \n![](/images/2015.12.27.04.png)   \n\n下面我们在EmployeeSearch.swift添加如下属性：\n\n{% codeblock lang:swift %}\npublic var attributeSet: CSSearchableItemAttributeSet {\n  let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact as String)\n  attributeSet.title = name  // 不太清楚是干啥的\n  attributeSet.contentDescription = \"\\(department), \\(title)\\n\\(phone)\"\n  attributeSet.thumbnailData = UIImageJPEGRepresentation(loadPicture(), 0.9)\n  attributeSet.supportsPhoneCall = true\n  attributeSet.phoneNumbers = [phone]\n  attributeSet.emailAddresses = [email]\n  attributeSet.keywords = skills\n  attributeSet.relatedUniqueIdentifier = objectId  \n\n  return attributeSet\n}\n{% endcodeblock %}  \n\n然后将给userActivity添加如下属性：   \n\n{% codeblock lang:swift %}\npublic var userActivity: NSUserActivity {\n  let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n  activity.title = name\n  activity.userInfo = userActivityUserInfo\n  activity.keywords = [email, department]\n  activity.contentAttributeSet = attributeSet   // 新添加的这一行\n  return activity\n}\n{% endcodeblock %}  \n\n然后运行程序，搜索结果如下：\n![](/images/2015.12.27.05.png)   \n\n但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：\n\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n  let objectId: String\n  // 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId\n  if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n    objectId = activityObjectId\n  }\n  // 获取对应Employee实例 然后跳转到对应的界面\n  if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n    nav.popToRootViewControllerAnimated(false)\n    let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n    employeeViewController.employee = employee\n    nav.pushViewController(employeeViewController, animated: false)\n    return true\n  }\n  return false\n}   \n{% endcodeblock %}\n这时候我们再点击搜索结果就能够跳转到对应的详细界面了。\n\n### CoreSpotlight\n下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：\n\n{% codeblock lang:swift %}\n// 在前面的代码中已经设置过了\nattributeSet.relatedUniqueIdentifier = objectId\n{% endcodeblock %}\n这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   \n\n然后在EmployeeSearch.swift添加如下的代码：\n\n{% codeblock lang:swift %}\n// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用\nvar searchableItem: CSSearchableItem {\n  let item = CSSearchableItem(uniqueIdentifier: objectId, domainIdentifier: Employee.domainIdentifier, attributeSet: attributeSet)\n  return item\n}\n{% endcodeblock %}   \n\n然后在EmployeeService.swift添加如下代码：  \n\n{% codeblock lang:swift %}   \nimport CoreSpotlight\n\n..............<省略一部分代码>\n\npublic func indexAllEmployees() {\n  let employees = fetchEmployees()\n  let searchableItems = employees.map{ $0.searchableItem }\n  // 将我们需要被索引的item放入到defaultSearchableIndex中\n  CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in\n    if let error = error {\n      print(\"Error indexing employees: \\(error)\")\n    } else {\n      print(\"Employees indexed.\")\n    }\n  }\n}\n{% endcodeblock %}   \n然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：\n![](/images/2015.12.27.06.png)\n\n但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n    let objectId: String\n    if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n      objectId = activityObjectId\n    }\n    // 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   \n    // CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值\n    else if userActivity.activityType == CSSearchableItemActionType, let activityObjectId = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String {\n      objectId = activityObjectId\n    } else {\n      return false\n    }\n    if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n      nav.popToRootViewControllerAnimated(false)\n      let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n      employeeViewController.employee = employee\n      nav.pushViewController(employeeViewController, animated: false)\n      return true\n    }\n    return false\n  }\n{% endcodeblock %}   \n这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   \n\n### 删除Item\n最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：\n{% codeblock lang:swift %}\npublic func destroyEmployeeIndexing() {\n  CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -> Void in\n    if let error = error {\n      print(\"Error deleting searching employee items: \\(error)\")\n    } else {\n      print(\"Employees indexing deleted.\")\n    }\n  }\n}\n{% endcodeblock %}\n这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   \n\n另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:[CoreSpotlight.framework注释翻译](http://blog.csdn.net/mengxiangyue/article/details/46575977)\n","slug":"iOS9-by-Tutorials-学习笔记二：App-Search","published":1,"updated":"2015-12-27T03:57:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij028hb00002316ewxsvzazq"},{"title":"iOS9 by Tutorials 学习笔记三：Your App on the Web","date":"2015-12-27T10:22:56.000Z","_content":"\n> 这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   \n\n在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  \n\n### Getting started   \n这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8>进行下载。APP截图如下：\n![](/images/2015.12.27.07.png)   \n\n### Linking to your app\n在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   \n\n#### Deep links\n在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app>://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   \n\n<!--more-->\n\n一旦设置了URL scheme，就能够通过openURL(\\_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(\\_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   \n* 安全 UIApplication有一个方法canOpenURL(\\_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   \n> canOpenURL(\\_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  \n\n* 冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(\\_:)，iPhone将不会知道应该怎么处理。   \n* No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   \n\niOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  \n\n#### Universal links\n这里举了一个例子：你有一个域名clownapp.com，你可以注册http://clownapp.com作为你的universal link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。   \n> PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   \n\nUniversal links与deep links有如下的有点：  \n* 唯一 由于使用的是域名，能够保证唯一性\n* 安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  \n> 这里原文如下There's also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。\n\n* 简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。\n\n#### 注册你的App，使其能够处理universal links   \n为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：  \n![](/images/2015.12.27.08.png)  \n\n> 这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   \n\n#### 注册你的服务器能够处理unilateral links  \n你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：\n{% codeblock lang:swift %}\n{\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"KFCNEC27GU.com.razeware.RWDevCon\",\n                \"paths\": [\n                    \"/videos/\\*\"\n                ]\n            }\n        ]\n    }\n}\n{% endcodeblock %}  \n其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 \\*，？ 等，如 /videos/\\*/year/201?/videoName。   \n\n这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。\n\n#### 在你的App上处理universal links\n> 这部分代码没有试验    \n\n上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：\n{% codeblock lang:swift %}\nclass func sessionByWebPath(path: String,\ncontext: NSManagedObjectContext) -> Session? {\n\n  let fetch = NSFetchRequest(entityName: \"Session\")\n  fetch.predicate = NSPredicate(format: \"webPath = %@\", [path])\n\n  do {\n    let results = try context.executeFetchRequest(fetch)\n    return results.first as? Session\n  } catch let fetchError as NSError {\n    print(\"fetch error: \\(fetchError.localizedDescription)\")\n  }\n\n  return nil\n}\n{% endcodeblock %}  \n\n在AppDelegate.swift添加如下方法：\n{% codeblock lang:swift %}\nextension AppDelegate {\n  // 辅助方法\n  func presentVideoViewController(URL: NSURL) {\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    let navID = \"NavPlayerViewController\"\n\n    let navVideoPlayerVC =\n    storyboard.instantiateViewControllerWithIdentifier(navID)\n      as! UINavigationController\n\n    navVideoPlayerVC.modalPresentationStyle = .FormSheet\n\n    if let videoPlayerVC = navVideoPlayerVC.topViewController\n      as? AVPlayerViewController {\n\n        videoPlayerVC.player = AVPlayer(URL: URL)\n\n        let rootViewController = window?.rootViewController\n        rootViewController?.presentViewController(navVideoPlayerVC,\n          animated: true, completion: nil)\n    }\n  }\n\n  func application(application: UIApplication,\n    continueUserActivity\n    userActivity: NSUserActivity,\n    restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n\n      //1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links\n      if userActivity.activityType ==\n        NSUserActivityTypeBrowsingWeb {\n\n          let universalURL = userActivity.webpageURL!\n\n          //2 提取出 url 的不同部分\n          if let components = NSURLComponents(URL: universalURL,\n            resolvingAgainstBaseURL: true),\n            let path = components.path {\n\n              if let session = Session.sessionByWebPath(path,\n                context: coreDataStack.context) {\n                  //3 找到 session，然后播放 video\n                  let videoURL = NSURL(string: session.videoUrl)!\n                  presentVideoViewController(videoURL)\n                  return true\n              } else {\n                //4 无法理解就打开网站首页\n                let app = UIApplication.sharedApplication()\n                let url = NSURL(string: \"http://www.rwdevcon.com\")!\n                app.openURL(url)\n              }\n          }\n      }\n      return false\n  }\n}\n{% endcodeblock %}   \n\n下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功\n{% codeblock lang:swift %}  \ngood link\nhttp://www.rwdevcon.com/videos/talk-tammy-coron-possible.html\nbad link\nhttp://www.rwdevcon.com/videos/tim-cook-keynote.html\n{% endcodeblock %}   \n\n### 使用web markup\nSearch 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。\n\n你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   \n\n苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   \n\n#### 使你的网站能够被发现   \n苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。\n1. 在iTunes Connect中，在设置**Support URL**的地方，设置**Marketing URL**，指向你已经使用markup的网站。  \n![](/images/2015.12.27.09.png)\n2. 保证你填写的URL能够被苹果的爬虫访问到。\n3. 检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。\n\n#### 添加Smart App Banners\n添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：\n![](/images/2015.12.27.10.png)   \n\n实现这个效果的方式，在你想要添加banner的网页上添加如下代码：\n{% codeblock lang:html %}\n<meta name=\"apple-itunes-app\" content=\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}\n这里的name是App在store中的名字，下面的content包含两部分内容：\n* app-id 在store上的app id\n* app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links\n> Smart App Banners 仅仅支持 Safari   \n\n你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：\n{% codeblock lang:html %}\n// Twitter Cards  具体 https://dev.twitter.com/cards/mobile\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n\n// App Links 具体http://applinks.org\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}    \n\n#### Semantic markup using Open Graph  \n苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   \n\nApple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。\n\n最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。\n{% codeblock lang:html %}\n<meta property=\"og:image\" content=\"http://www.rwdevcon.com/assets/images/  \nvideos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:secure_url\" content=\"https://www.rwdevcon.com/  \nassets/images/videos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:type\" content=\"image/jpeg\" />  \n<meta property=\"og:image:width\" content=\"640\" />  \n<meta property=\"og:image:height\" content=\"340\" />  \n<meta property=\"og:video\" content=\"http://www.rwdevcon.com/videos/Ray-  \nWenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:secure_url\" content=\"https://www.rwdevcon.com/  \nvideos/Ray-Wenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:type\" content=\"video/mp4\" />  \n<meta property=\"og:video:width\" content=\"1280\" />  \n<meta property=\"og:video:height\" content=\"720\" />  \n<meta property=\"og:description\" content=\"Learn how teamwork lets you  \ndream bigger, through the story of an indie iPhone developer who almost  \nmissed out on the greatest opportunity of his life.\" />\n{% endcodeblock %}\n\n> 上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢\n\n关于web markup相关的详细的东西可以看苹果的文档<https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html>\n\n最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。\n\n突然感觉这是最没底的一篇文章。\n","source":"_posts/iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web.md","raw":"title: iOS9 by Tutorials 学习笔记三：Your App on the Web\ndate: 2015-12-27 18:22:56\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n> 这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   \n\n在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  \n\n### Getting started   \n这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8>进行下载。APP截图如下：\n![](/images/2015.12.27.07.png)   \n\n### Linking to your app\n在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   \n\n#### Deep links\n在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app>://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   \n\n<!--more-->\n\n一旦设置了URL scheme，就能够通过openURL(\\_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(\\_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   \n* 安全 UIApplication有一个方法canOpenURL(\\_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   \n> canOpenURL(\\_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  \n\n* 冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(\\_:)，iPhone将不会知道应该怎么处理。   \n* No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   \n\niOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  \n\n#### Universal links\n这里举了一个例子：你有一个域名clownapp.com，你可以注册http://clownapp.com作为你的universal link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。   \n> PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   \n\nUniversal links与deep links有如下的有点：  \n* 唯一 由于使用的是域名，能够保证唯一性\n* 安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  \n> 这里原文如下There's also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。\n\n* 简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。\n\n#### 注册你的App，使其能够处理universal links   \n为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：  \n![](/images/2015.12.27.08.png)  \n\n> 这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   \n\n#### 注册你的服务器能够处理unilateral links  \n你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：\n{% codeblock lang:swift %}\n{\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"KFCNEC27GU.com.razeware.RWDevCon\",\n                \"paths\": [\n                    \"/videos/\\*\"\n                ]\n            }\n        ]\n    }\n}\n{% endcodeblock %}  \n其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 \\*，？ 等，如 /videos/\\*/year/201?/videoName。   \n\n这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。\n\n#### 在你的App上处理universal links\n> 这部分代码没有试验    \n\n上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：\n{% codeblock lang:swift %}\nclass func sessionByWebPath(path: String,\ncontext: NSManagedObjectContext) -> Session? {\n\n  let fetch = NSFetchRequest(entityName: \"Session\")\n  fetch.predicate = NSPredicate(format: \"webPath = %@\", [path])\n\n  do {\n    let results = try context.executeFetchRequest(fetch)\n    return results.first as? Session\n  } catch let fetchError as NSError {\n    print(\"fetch error: \\(fetchError.localizedDescription)\")\n  }\n\n  return nil\n}\n{% endcodeblock %}  \n\n在AppDelegate.swift添加如下方法：\n{% codeblock lang:swift %}\nextension AppDelegate {\n  // 辅助方法\n  func presentVideoViewController(URL: NSURL) {\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    let navID = \"NavPlayerViewController\"\n\n    let navVideoPlayerVC =\n    storyboard.instantiateViewControllerWithIdentifier(navID)\n      as! UINavigationController\n\n    navVideoPlayerVC.modalPresentationStyle = .FormSheet\n\n    if let videoPlayerVC = navVideoPlayerVC.topViewController\n      as? AVPlayerViewController {\n\n        videoPlayerVC.player = AVPlayer(URL: URL)\n\n        let rootViewController = window?.rootViewController\n        rootViewController?.presentViewController(navVideoPlayerVC,\n          animated: true, completion: nil)\n    }\n  }\n\n  func application(application: UIApplication,\n    continueUserActivity\n    userActivity: NSUserActivity,\n    restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n\n      //1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links\n      if userActivity.activityType ==\n        NSUserActivityTypeBrowsingWeb {\n\n          let universalURL = userActivity.webpageURL!\n\n          //2 提取出 url 的不同部分\n          if let components = NSURLComponents(URL: universalURL,\n            resolvingAgainstBaseURL: true),\n            let path = components.path {\n\n              if let session = Session.sessionByWebPath(path,\n                context: coreDataStack.context) {\n                  //3 找到 session，然后播放 video\n                  let videoURL = NSURL(string: session.videoUrl)!\n                  presentVideoViewController(videoURL)\n                  return true\n              } else {\n                //4 无法理解就打开网站首页\n                let app = UIApplication.sharedApplication()\n                let url = NSURL(string: \"http://www.rwdevcon.com\")!\n                app.openURL(url)\n              }\n          }\n      }\n      return false\n  }\n}\n{% endcodeblock %}   \n\n下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功\n{% codeblock lang:swift %}  \ngood link\nhttp://www.rwdevcon.com/videos/talk-tammy-coron-possible.html\nbad link\nhttp://www.rwdevcon.com/videos/tim-cook-keynote.html\n{% endcodeblock %}   \n\n### 使用web markup\nSearch 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。\n\n你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   \n\n苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   \n\n#### 使你的网站能够被发现   \n苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。\n1. 在iTunes Connect中，在设置**Support URL**的地方，设置**Marketing URL**，指向你已经使用markup的网站。  \n![](/images/2015.12.27.09.png)\n2. 保证你填写的URL能够被苹果的爬虫访问到。\n3. 检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。\n\n#### 添加Smart App Banners\n添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：\n![](/images/2015.12.27.10.png)   \n\n实现这个效果的方式，在你想要添加banner的网页上添加如下代码：\n{% codeblock lang:html %}\n<meta name=\"apple-itunes-app\" content=\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}\n这里的name是App在store中的名字，下面的content包含两部分内容：\n* app-id 在store上的app id\n* app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links\n> Smart App Banners 仅仅支持 Safari   \n\n你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：\n{% codeblock lang:html %}\n// Twitter Cards  具体 https://dev.twitter.com/cards/mobile\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n\n// App Links 具体http://applinks.org\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}    \n\n#### Semantic markup using Open Graph  \n苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   \n\nApple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。\n\n最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。\n{% codeblock lang:html %}\n<meta property=\"og:image\" content=\"http://www.rwdevcon.com/assets/images/  \nvideos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:secure_url\" content=\"https://www.rwdevcon.com/  \nassets/images/videos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:type\" content=\"image/jpeg\" />  \n<meta property=\"og:image:width\" content=\"640\" />  \n<meta property=\"og:image:height\" content=\"340\" />  \n<meta property=\"og:video\" content=\"http://www.rwdevcon.com/videos/Ray-  \nWenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:secure_url\" content=\"https://www.rwdevcon.com/  \nvideos/Ray-Wenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:type\" content=\"video/mp4\" />  \n<meta property=\"og:video:width\" content=\"1280\" />  \n<meta property=\"og:video:height\" content=\"720\" />  \n<meta property=\"og:description\" content=\"Learn how teamwork lets you  \ndream bigger, through the story of an indie iPhone developer who almost  \nmissed out on the greatest opportunity of his life.\" />\n{% endcodeblock %}\n\n> 上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢\n\n关于web markup相关的详细的东西可以看苹果的文档<https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html>\n\n最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。\n\n突然感觉这是最没底的一篇文章。\n","slug":"iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web","published":1,"updated":"2015-12-27T12:21:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij028hba0007316emka9erf2"},{"title":"iOS9 by Tutorials 学习笔记一：Swift 2.0","date":"2015-12-22T14:15:07.000Z","_content":"\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","source":"_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","raw":"title: iOS9 by Tutorials 学习笔记一：Swift 2.0\ndate: 2015-12-22 22:15:07\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","slug":"iOS9-by-Tutorials-学习笔记一：Swift-2-0","published":1,"updated":"2015-12-27T01:24:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij028hbn000a316engspqi8e"},{"title":"iOS NavigationBar手势返回的时候跟随","date":"2015-12-23T15:22:39.000Z","_content":"\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","source":"_posts/iOS-NavigationBar手势返回的时候跟随.md","raw":"title: iOS NavigationBar手势返回的时候跟随\ndate: 2015-12-23 23:22:39\ncategories:\n  - iOS Tips\ntags:\n---\n\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","slug":"iOS-NavigationBar手势返回的时候跟随","published":1,"updated":"2015-12-23T16:02:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij028hbp000d316ergc4vvbk"},{"title":"Hexo结合Github Pages搭建静态博客","date":"2015-12-19T05:17:00.000Z","_content":"已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","source":"_posts/Hexo结合Github-Pages搭建静态博客.md","raw":"title: Hexo结合Github Pages搭建静态博客\ncategories:\n  - 工具\ntags:\n  - Github\n  - Hexo\ndate: 2015-12-19 13:17:00\n---\n已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","slug":"Hexo结合Github-Pages搭建静态博客","published":1,"updated":"2015-12-20T02:42:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cij028hbu000g316eayfkbhld"}],"PostAsset":[],"PostCategory":[{"post_id":"cij028hb00002316ewxsvzazq","category_id":"cij028hb10003316e8a3ed8sg","_id":"cij028hb60006316e09un2u9h"},{"post_id":"cij028hba0007316emka9erf2","category_id":"cij028hb10003316e8a3ed8sg","_id":"cij028hbc0008316e36y934il"},{"post_id":"cij028hbn000a316engspqi8e","category_id":"cij028hb10003316e8a3ed8sg","_id":"cij028hbo000b316eclp6wvcv"},{"post_id":"cij028hbp000d316ergc4vvbk","category_id":"cij028hbq000e316em29bq52g","_id":"cij028hbs000f316e41arh5wz"},{"post_id":"cij028hbu000g316eayfkbhld","category_id":"cij028hbw000h316euxcmuaq2","_id":"cij028hbx000k316euw6ckw48"},{"post_id":"cij028haq0001316ekxpaqfjf","category_id":"cij028hb10003316e8a3ed8sg","_id":"cij1lsodr002m316e1gobmwzf"}],"PostTag":[{"post_id":"cij028hb00002316ewxsvzazq","tag_id":"cij028hb20004316e3xkpnmqd","_id":"cij028hb60005316e8rzy9b6u"},{"post_id":"cij028hba0007316emka9erf2","tag_id":"cij028hb20004316e3xkpnmqd","_id":"cij028hbc0009316e5q937hyf"},{"post_id":"cij028hbn000a316engspqi8e","tag_id":"cij028hb20004316e3xkpnmqd","_id":"cij028hbo000c316erdsai940"},{"post_id":"cij028hbu000g316eayfkbhld","tag_id":"cij028hbw000i316e99p2jdqb","_id":"cij028hbx000l316eg2pu5ip9"},{"post_id":"cij028hbu000g316eayfkbhld","tag_id":"cij028hbx000j316epn8r7mxf","_id":"cij028hbx000m316e7o08u343"},{"post_id":"cij028haq0001316ekxpaqfjf","tag_id":"cij028hb20004316e3xkpnmqd","_id":"cij029jzt000o316eoe8t12mv"}],"Tag":[{"name":"iOS 9","_id":"cij028hb20004316e3xkpnmqd"},{"name":"Github","_id":"cij028hbw000i316e99p2jdqb"},{"name":"Hexo","_id":"cij028hbx000j316epn8r7mxf"}]}}