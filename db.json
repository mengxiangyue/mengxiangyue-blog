{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.03.png","path":"images/2015.12.19.03.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.06.png","path":"images/2015.12.19.06.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.05.png","path":"images/2015.12.19.05.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.09.png","path":"images/2015.12.27.09.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.01.png","path":"images/2016.01.04.01.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.02.png","path":"images/2015.12.19.02.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","path":"images/2015.12.23.NavigationBarTest.gif","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.03.png","path":"images/2015.12.27.03.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.05.png","path":"images/2015.12.27.05.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.10.png","path":"images/2015.12.27.10.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.03.png","path":"images/2016.01.04.03.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.01.png","path":"images/2015.12.19.01.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.19.04.png","path":"images/2015.12.19.04.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.04.png","path":"images/2015.12.27.04.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.06.png","path":"images/2015.12.27.06.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.07.png","path":"images/2015.12.27.07.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.02.png","path":"images/2016.01.04.02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.05.png","path":"images/2016.01.04.05.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/04.png","path":"images/2016.01.09/04.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/03.png","path":"images/2016.01.13/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/08.png","path":"images/2016.01.13/08.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/04.png","path":"images/2016.01.21/04.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/08.png","path":"images/2016.01.21/08.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/10.png","path":"images/2016.01.21/10.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/01.png","path":"images/2016.01.25/01.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","path":"img/mengxiangyue.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"source/images/2015.12.27.01.png","path":"images/2015.12.27.01.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.02.png","path":"images/2015.12.27.02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.08.png","path":"images/2016.01.04.08.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.11.png","path":"images/2016.01.04.11.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/03.png","path":"images/2016.01.09/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/07.png","path":"images/2016.01.09/07.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/11.png","path":"images/2016.01.09/11.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.11/02.png","path":"images/2016.01.11/02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.11/03.png","path":"images/2016.01.11/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/01.png","path":"images/2016.01.13/01.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/02.png","path":"images/2016.01.13/02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/04.png","path":"images/2016.01.13/04.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/10.png","path":"images/2016.01.13/10.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/06.png","path":"images/2016.01.21/06.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/07.png","path":"images/2016.01.21/07.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/09.png","path":"images/2016.01.21/09.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/11.png","path":"images/2016.01.21/11.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/14.png","path":"images/2016.01.21/14.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/02.png","path":"images/2016.01.25/02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/05.png","path":"images/2016.01.25/05.png","modified":1,"renderable":0},{"_id":"source/images/2016.04.25/03.jpg","path":"images/2016.04.25/03.jpg","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/07.png","path":"images/2016.01.25/07.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/03.png","path":"images/2016.02.23/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/05.png","path":"images/2016.02.23/05.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"source/images/2016.01.09/02.png","path":"images/2016.01.09/02.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/06.png","path":"images/2016.01.09/06.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/05.png","path":"images/2016.01.09/05.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/08.png","path":"images/2016.01.09/08.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/10.png","path":"images/2016.01.09/10.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/11.png","path":"images/2016.01.13/11.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/12.png","path":"images/2016.01.13/12.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/12.png","path":"images/2016.01.21/12.png","modified":1,"renderable":0},{"_id":"source/images/2016.04.25/01.jpg","path":"images/2016.04.25/01.jpg","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/04.png","path":"images/2016.01.25/04.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/03.png","path":"images/2016.01.25/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.04.25/04.jpg","path":"images/2016.04.25/04.jpg","modified":1,"renderable":0},{"_id":"source/images/2016.04.25/02.jpg","path":"images/2016.04.25/02.jpg","modified":1,"renderable":0},{"_id":"source/images/2016.04.25/05.jpg","path":"images/2016.04.25/05.jpg","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.13.png","path":"images/2016.01.04.13.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"source/images/2016.01.04.04.png","path":"images/2016.01.04.04.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.07.png","path":"images/2016.01.04.07.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.09.png","path":"images/2016.01.04.09.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/01.png","path":"images/2016.01.09/01.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.09/12.png","path":"images/2016.01.09/12.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/09.png","path":"images/2016.01.13/09.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/13.png","path":"images/2016.01.13/13.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/01.png","path":"images/2016.01.21/01.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/13.png","path":"images/2016.01.21/13.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/02.png","path":"images/2016.02.23/02.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"source/images/2016.01.09/09.png","path":"images/2016.01.09/09.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/02.png","path":"images/2016.01.21/02.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/04.png","path":"images/2016.02.23/04.png","modified":1,"renderable":0},{"_id":"source/images/2015.12.27.08.png","path":"images/2015.12.27.08.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.12.png","path":"images/2016.01.04.12.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/01.png","path":"images/2016.02.23/01.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.11/01.png","path":"images/2016.01.11/01.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.04.10.png","path":"images/2016.01.04.10.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/03.png","path":"images/2016.01.21/03.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/06.png","path":"images/2016.01.25/06.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.25/08.png","path":"images/2016.01.25/08.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/06.png","path":"images/2016.02.23/06.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/06.png","path":"images/2016.01.13/06.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/05.png","path":"images/2016.01.13/05.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.13/07.png","path":"images/2016.01.13/07.png","modified":1,"renderable":0},{"_id":"source/images/2016.01.21/05.png","path":"images/2016.01.21/05.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/img/logo-back.png","path":"img/logo-back.png","modified":1,"renderable":1},{"_id":"source/images/2016.01.04.06.png","path":"images/2016.01.04.06.png","modified":1,"renderable":0},{"_id":"source/images/2016.02.23/07.png","path":"images/2016.02.23/07.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"82a91d02385750292b82a7d6b3734c8d98a928be","modified":1461581674000},{"_id":"themes/jacman/_config.yml","hash":"f11a10f5308afb72990e4d60ff26049794ca701a","modified":1461581674000},{"_id":"source/_posts/7月2号一场有料的Android分享会，约么？.md","hash":"309df962509f6808b1ff92e8648758ce5625c4d3","modified":1467075333000},{"_id":"source/_posts/Hexo结合Github-Pages搭建静态博客.md","hash":"cfda02059e8a1c6ca0eb3434e3fdf71d5fda361c","modified":1461581674000},{"_id":"source/_posts/MAC上Nuclide的安装.md","hash":"20cff31a932d8818f4b354ce1f6ea750d3c7cb84","modified":1461581674000},{"_id":"source/_posts/iOS-NavigationBar手势返回的时候跟随.md","hash":"6c32668ab9b22a11c41538f2ee21971d221a3e0b","modified":1461581674000},{"_id":"source/_posts/OC项目中使用Swift.md","hash":"e0745e4153019cbc0a30ba52790c2e1170ad9c57","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web.md","hash":"523e1a4b2ecb1b91bb2cc5c447db5a665ae4bf60","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记七：UIStackView-进阶.md","hash":"ec3af5de606bac4c56037eca86389b6ba802c638","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记九：3D-Touch.md","hash":"9946b7d895898da11090dbd4653718c916b915e4","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","hash":"974a44e2052be062a8e450f9c871454eb020b757","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记二：App-Search.md","hash":"e4e31d9a4d7bf9b3956173078d9e06f2f6f40b28","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记五：Multitasking.md","hash":"2aedc4314f5351bafed276e71d9d81069976ce29","modified":1461581674000},{"_id":"source/_posts/一场站着听完的iOS技术分享会.md","hash":"77a1e0de9c292f3c20b20c96af77c059813d0464","modified":1467073925000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记八-Storyboard新特性.md","hash":"c35777a2997bf4cab461542823700188d8b484ae","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记四：APP-瘦身.md","hash":"8d8c5fa458119149a311e43a36f97c9811bb55e1","modified":1461581674000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记六：UIStackView-Auto-Layout-Changes.md","hash":"895283f0c80876950f89f9258077a5ece34ef862","modified":1461581674000},{"_id":"source/images/2015.12.19.03.png","hash":"b2230e53726b0213972a7f341e44499e0aa3eb08","modified":1461581674000},{"_id":"source/images/2015.12.19.06.png","hash":"5dbc917107cd31245445b190dca5b726c0dfd10e","modified":1461581674000},{"_id":"source/images/2015.12.19.05.png","hash":"ee6cb6d8d3ba4f298575de57f1aa3eb119ad45bc","modified":1461581674000},{"_id":"source/images/2015.12.27.09.png","hash":"ac9a597544fefe0469593cd509a304fb1cc7583f","modified":1461581674000},{"_id":"source/images/2016.01.04.01.png","hash":"22154f5d0838a83351322a423b3dee6bd0b8fc42","modified":1461581674000},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1461581674000},{"_id":"source/about/index.md","hash":"275236c2371c3501bf390165a8511172469e7ab7","modified":1461581674000},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1461581674000},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1461581674000},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1461581674000},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1461581674000},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1461581674000},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1461581674000},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1461581674000},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1461581674000},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1461581674000},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1461581674000},{"_id":"source/images/2015.12.19.02.png","hash":"1b4e204bbe1e798c3ebd4c209b1b51e68059231e","modified":1461581674000},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","hash":"c78d77a76a397b0848874414fc1f335ae60dee8c","modified":1461581674000},{"_id":"source/images/2015.12.27.03.png","hash":"29c1d4674928ca72b7decd429e35acac1491e0fc","modified":1461581674000},{"_id":"source/images/2015.12.27.05.png","hash":"67c20eb12968871809061ae949bccd62533e560d","modified":1461581674000},{"_id":"source/images/2015.12.27.10.png","hash":"dc146f271092b9405f9aca1d7ded70dc803df379","modified":1461581674000},{"_id":"source/images/2016.01.04.03.png","hash":"de6833aed73595d51812496fbc9e03db729bfeb9","modified":1461581674000},{"_id":"source/images/2015.12.19.01.png","hash":"021c02950ab5581da6c035e40fb94e3b1a56ae1e","modified":1461581674000},{"_id":"source/images/2015.12.19.04.png","hash":"880191f1f6ad386668bf9f70bec795e1a8d978b8","modified":1461581674000},{"_id":"source/images/2015.12.27.04.png","hash":"eea4e6298c8428992719a69d6fc0e35e2cb178f5","modified":1461581674000},{"_id":"source/images/2015.12.27.06.png","hash":"42482ba521b8763546d41321679275fb8d4e58b9","modified":1461581674000},{"_id":"source/images/2015.12.27.07.png","hash":"a952df1bc709cf70e556c5b99005ac5a20f84bf1","modified":1461581674000},{"_id":"source/images/2016.01.04.02.png","hash":"1ef8ec8c1174d80add8c51bf7caa7d70cae994ac","modified":1461581674000},{"_id":"source/images/2016.01.04.05.png","hash":"d855f15d3d22d32bf5bdaea6051b3ddef5519800","modified":1461581674000},{"_id":"source/images/2016.01.09/04.png","hash":"5eabd9b88b6a2cfe9a8d27f265db1f5d325a2f8d","modified":1461581674000},{"_id":"source/images/2016.01.13/03.png","hash":"64e89991ab745a0b51784f8ccc46eef17ba5496b","modified":1461581674000},{"_id":"source/images/2016.01.13/08.png","hash":"199ca5cca32cc146e2b064243370dffc6a8cfd68","modified":1461581674000},{"_id":"source/images/2016.01.21/04.png","hash":"d254c8dd5e4a26eef16b738696524a2392cbfca6","modified":1461581674000},{"_id":"source/images/2016.01.21/08.png","hash":"def06a875d4ec9ae662970d1aeb6ba6bfd698c74","modified":1461581674000},{"_id":"source/images/2016.01.21/10.png","hash":"aaf60d7f1c275f61aacb48bdf0c530678bec4127","modified":1461581674000},{"_id":"source/images/2016.01.25/01.png","hash":"b1d7ddabf5edd2db063a21b51d673ba83225d983","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"b79534df2651b79dca54ec17829a514ff55ecb46","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"c645e8a77b5b13baf31a69da8365942747cb214f","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"89f22cb6086c5244ecd01da3bb17d70f68e7d07f","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"08119290adc3a7b0f0fe7b83699758569005c5bf","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"facd1ecd2d45d0d6eb8dbf0b11be0a1be3c07613","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1461581674000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1461581674000},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1461581674000},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1461581674000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1461581674000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1461581674000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1461581674000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1461581674000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1461581674000},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1461581674000},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1461581674000},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1461581674000},{"_id":"themes/jacman/source/img/favicon.ico","hash":"53a9b87b9937fe6513a5da328909f94add3fbf79","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1461581674000},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1461581674000},{"_id":"themes/jacman/source/img/logo.png","hash":"29d05f497fc1aa9ecebd753b0e2e21241ed1fe0a","modified":1461581674000},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1461581674000},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","hash":"2563a79fce9ec04dc3b14545aeff3a56f81dd4d1","modified":1461581674000},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1461581674000},{"_id":"themes/jacman/source/js/totop.js","hash":"5a9ea00aa54adb83015f514690894bc123855bc3","modified":1461581674000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1461581674000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1461581674000},{"_id":"source/images/2015.12.27.01.png","hash":"97f4ed423f1773a82af22e6a662c532bc7fec883","modified":1461581674000},{"_id":"source/images/2015.12.27.02.png","hash":"68adcfd852ced036bebd1dd6f91f2a5442bcb356","modified":1461581674000},{"_id":"source/images/2016.01.04.08.png","hash":"01c2806071235f2c816b3fa0825f362f77a54857","modified":1461581674000},{"_id":"source/images/2016.01.04.11.png","hash":"4e4be76eddadda24c7868d674fca813a60000a87","modified":1461581674000},{"_id":"source/images/2016.01.09/03.png","hash":"05b50a104015a61c276a644e44482f83cac6cab3","modified":1461581674000},{"_id":"source/images/2016.01.09/07.png","hash":"80e0933fab248f9c2be7622214eeacb1a33977bd","modified":1461581674000},{"_id":"source/images/2016.01.09/11.png","hash":"e35387914fbe426aeebc3b76ef543cd51383ad94","modified":1461581674000},{"_id":"source/images/2016.01.11/02.png","hash":"4431ccaa656c13d671ba7e9af71548f8ae1624f0","modified":1461581674000},{"_id":"source/images/2016.01.11/03.png","hash":"d4bb3af76916d3799c66614411c2bd7ffa134eb6","modified":1461581674000},{"_id":"source/images/2016.01.13/01.png","hash":"6d1a808f5ab6517ada14e303925175605b071689","modified":1461581674000},{"_id":"source/images/2016.01.13/02.png","hash":"d604cf15fffdb894ff6005ca1a02d6931c145382","modified":1461581674000},{"_id":"source/images/2016.01.13/04.png","hash":"d5d1627a2b5fdd10d56015f6f0cb777a0f5293d8","modified":1461581674000},{"_id":"source/images/2016.01.13/10.png","hash":"0213af643d2cc0cd916e8cfa53f43c2a5cb139d4","modified":1461581674000},{"_id":"source/images/2016.01.21/06.png","hash":"2f45a2cce06698a65fed1dc019e5b7e057d0e1a5","modified":1461581674000},{"_id":"source/images/2016.01.21/07.png","hash":"21ee06937ed7b6713c2e9417bfce77fcfa03d110","modified":1461581674000},{"_id":"source/images/2016.01.21/09.png","hash":"f23319d396d97d7a6b4c8a0b523a76315883f2d6","modified":1461581674000},{"_id":"source/images/2016.01.21/11.png","hash":"d99b0fe01ee6d2fd2a9d93366f1b65803c84e820","modified":1461581674000},{"_id":"source/images/2016.01.21/14.png","hash":"8004a1727e5d8e721fdd198aeeb7adb130d4cf76","modified":1461581674000},{"_id":"source/images/2016.01.25/02.png","hash":"73eb68e50472e3731801d1b93a07bb6c14a20ebc","modified":1461581674000},{"_id":"source/images/2016.01.25/05.png","hash":"49021cf4cf7764a71fd30d9f5df7e343d85f9f1f","modified":1461581674000},{"_id":"source/images/2016.04.25/03.jpg","hash":"325f2a75a99ce0549f1d22c68e822f7a73a845c5","modified":1467073925000},{"_id":"source/images/2016.01.25/07.png","hash":"3095dd7304ba754979192df3ac12062063356516","modified":1461581674000},{"_id":"source/images/2016.02.23/03.png","hash":"6cd120585f18b56422a053b5392088cb892a8470","modified":1461581674000},{"_id":"source/images/2016.02.23/05.png","hash":"046c71717c62da3a759c272ae6ab4ee9b7d6127b","modified":1461581674000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1461581674000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1461581674000},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1461581674000},{"_id":"themes/jacman/source/img/author.jpg","hash":"15de0631d5ccae00a8b2990ad957cfb51f58bc27","modified":1461581674000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1461581674000},{"_id":"source/images/2016.01.09/02.png","hash":"daa69f9eb6a7e18de955214fed9705cef1d9003f","modified":1461581674000},{"_id":"source/images/2016.01.09/06.png","hash":"6f1adab89d92d70d57a24efc636c4baa57e16a54","modified":1461581674000},{"_id":"source/images/2016.01.09/05.png","hash":"9f2c0415f8129214ae0dc80ce9e87b7bb042455a","modified":1461581674000},{"_id":"source/images/2016.01.09/08.png","hash":"c15e21f18fe4ff0cba1c5acb4ae51f53518b9cf4","modified":1461581674000},{"_id":"source/images/2016.01.09/10.png","hash":"aaa4c7b5c5c8dd16490365fe0b870441c6b4faff","modified":1461581674000},{"_id":"source/images/2016.01.13/11.png","hash":"bd9ce11612d37736c0be4cebfa8188461f2559bb","modified":1461581674000},{"_id":"source/images/2016.01.13/12.png","hash":"d3325cade0173b15fbdb8aebad1ae55bf0a2121a","modified":1461581674000},{"_id":"source/images/2016.01.21/12.png","hash":"9cd95c1b2167b5e710a9359af8a023fde132d8ee","modified":1461581674000},{"_id":"source/images/2016.04.25/01.jpg","hash":"3f61fe3cfc88d4b62e0b703ce81094dd60b8554e","modified":1467073925000},{"_id":"source/images/2016.01.25/04.png","hash":"8b1ff8f05ab079fa999adea89aefa9871175ffb8","modified":1461581674000},{"_id":"source/images/2016.01.25/03.png","hash":"912c319f3de23c8fc90d79ca2669dc9903ba4412","modified":1461581674000},{"_id":"source/images/2016.04.25/04.jpg","hash":"b071100a646eda0f1a7a5177480dde32d33bfdb0","modified":1467073925000},{"_id":"source/images/2016.04.25/02.jpg","hash":"95d3cd2506a5e2a9587c46ee4bfb9126e2d9340c","modified":1467073925000},{"_id":"source/images/2016.04.25/05.jpg","hash":"9957a50bc5e1ee75aff340deadfad6826653b998","modified":1467073925000},{"_id":"source/images/2016.01.04.13.png","hash":"5e9c5e3ec47cb2d53853ebf5286a962fe240f4c7","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b4c151839cb6ac81477db44ee1748aea4c37c8c8","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1461581674000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1461581674000},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1461581674000},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1461581674000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"a0095f49f3531d777cb34513a64d367b742e5c14","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1461581674000},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1461581674000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1461581674000},{"_id":"source/images/2016.01.04.04.png","hash":"9fbb04d36692482fbcd935529ff71f5f17b3de2a","modified":1461581674000},{"_id":"source/images/2016.01.04.07.png","hash":"5b9352b8143e25327a8a6f947418d5f05d77d788","modified":1461581674000},{"_id":"source/images/2016.01.04.09.png","hash":"22a8c2a9b2b977cffe20c79f38a0d4d204a4d293","modified":1461581674000},{"_id":"source/images/2016.01.09/01.png","hash":"4e29f67f32ad7ca26dc29d039a0782d9dab861f8","modified":1461581674000},{"_id":"source/images/2016.01.09/12.png","hash":"7d68b7e8ddf43ef5180c92428c89cb4e04822bf5","modified":1461581674000},{"_id":"source/images/2016.01.13/09.png","hash":"771623a191fd0a39dbbe18bf1faa969779d0d9eb","modified":1461581674000},{"_id":"source/images/2016.01.13/13.png","hash":"156b7e75810f78985455aadab9b1a3d814c63237","modified":1461581674000},{"_id":"source/images/2016.01.21/01.png","hash":"822fbb7fe8d0eb0422017b463566f468a879e4b5","modified":1461581674000},{"_id":"source/images/2016.01.21/13.png","hash":"30454296f3ef297483d32de0844e29f93ebf1cfd","modified":1461581674000},{"_id":"source/images/2016.02.23/02.png","hash":"85106e15034f970763c3d85af2bf13c083a4a395","modified":1461581674000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1461581674000},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1461581674000},{"_id":"source/images/2016.01.09/09.png","hash":"5c2e5a7941a4b3f708c4a9548fff111234340c5e","modified":1461581674000},{"_id":"source/images/2016.01.21/02.png","hash":"dfd812a8b21c077af0e48ccee8ad3ffbc3f907b7","modified":1461581674000},{"_id":"source/images/2016.02.23/04.png","hash":"70492f1be3ad06e048edc9bdfb74aa254fb74a43","modified":1461581674000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1461581674000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1461581674000},{"_id":"source/images/2015.12.27.08.png","hash":"fc55480beb9ab8110d216103102329e82ec85d39","modified":1461581674000},{"_id":"source/images/2016.01.04.12.png","hash":"9af887b91f35bab2f124f70f3ed043139d88108e","modified":1461581674000},{"_id":"source/images/2016.02.23/01.png","hash":"4865471e00b26951df5af2630870db7ed7f19242","modified":1461581674000},{"_id":"source/images/2016.01.11/01.png","hash":"a6f36f60dd71f1cb6d2997bb8296196ca057d3d7","modified":1461581674000},{"_id":"source/images/2016.01.04.10.png","hash":"25c465fbd9f6fda776f5fee047466bb1a9b674a1","modified":1461581674000},{"_id":"source/images/2016.01.21/03.png","hash":"a6e8ed2e968729b60e3001eb6df9ba71847799c1","modified":1461581674000},{"_id":"source/images/2016.01.25/06.png","hash":"6c3afd798a5491ae1ea790e4b3c6896948b87450","modified":1461581674000},{"_id":"source/images/2016.01.25/08.png","hash":"6bfb254226dde17aee5cfd741559c1ebeb0985fc","modified":1461581674000},{"_id":"source/images/2016.02.23/06.png","hash":"9b9a3df8a222d59b4de326d26170280d7cc122e5","modified":1461581674000},{"_id":"source/images/2016.01.13/06.png","hash":"c02ad7f7ea050467eb1fb8bc1d4a0cb5558da795","modified":1461581674000},{"_id":"source/images/2016.01.13/05.png","hash":"3510d2408d2c6324094cb3d8e77dbbf2334d680b","modified":1461581674000},{"_id":"source/images/2016.01.13/07.png","hash":"d2f81bad9e493ef0ca62c23403fc44654fafb418","modified":1461581674000},{"_id":"source/images/2016.01.21/05.png","hash":"d65e944cb2f06f0ac2a07bf7ebf5f20e023d4250","modified":1461581674000},{"_id":"themes/jacman/source/img/logo-back.png","hash":"eafdece1be127ff95553a02976076653d5c0a422","modified":1461581674000},{"_id":"source/images/2016.01.04.06.png","hash":"a74d6b8624bade41d9c404c70ecfe044fa6ad745","modified":1461581674000},{"_id":"source/images/2016.02.23/07.png","hash":"e3a342fe875cfa6657c2a6293908d160d299447c","modified":1461581674000}],"Category":[{"name":"工具","_id":"cipyqsl0g00053is6jio1ihsw"},{"name":"React Native","_id":"cipyqsl0n000a3is69g6lrg47"},{"name":"iOS Tips","_id":"cipyqsl0q000f3is69z6n5zdp"},{"name":"iOS 9 by Tutoials","_id":"cipyqsl0w000s3is6wq50ge4x"}],"Data":[],"Page":[{"title":"about","date":"2015-12-19T04:36:01.000Z","_content":"\n写点什么呢。。。。。。。。\n","source":"about/index.md","raw":"title: about\ndate: 2015-12-19 12:36:01\n---\n\n写点什么呢。。。。。。。。\n","updated":"2016-04-25T10:54:34.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cipyqsl0800013is6n3lk9p9t","content":"<p>写点什么呢。。。。。。。。</p>\n","excerpt":"","more":"<p>写点什么呢。。。。。。。。</p>\n"}],"Post":[{"title":"7月2号一场有料的Android分享会，约么？","date":"2016-06-28T00:55:33.000Z","_content":"","source":"_posts/7月2号一场有料的Android分享会，约么？.md","raw":"title: 7月2号一场有料的Android分享会，约么？\ndate: 2016-06-28 08:55:33\ntags:\n---\n","slug":"7月2号一场有料的Android分享会，约么？","published":1,"updated":"2016-06-28T00:55:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0300003is6a09rc5fx","content":"","excerpt":"","more":""},{"title":"Hexo结合Github Pages搭建静态博客","date":"2015-12-19T05:17:00.000Z","_content":"已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","source":"_posts/Hexo结合Github-Pages搭建静态博客.md","raw":"title: Hexo结合Github Pages搭建静态博客\ncategories:\n  - 工具\ntags:\n  - Github\n  - Hexo\ndate: 2015-12-19 13:17:00\n---\n已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","slug":"Hexo结合Github-Pages搭建静态博客","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0900023is6zzi972bl","content":"<p>已经好久没有写过博客了，主要是因为懒了。<br>前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  </p>\n<p>我自己已经有一个博客了，是在CSDN的博客，博客地址：<a href=\"http://blog.csdn.net/mengxiangyue\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/mengxiangyue</a>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  </p>\n<p>好了貌似扯得有点远了，下面进入正题。<br>上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  </p>\n<blockquote>\n<ol>\n<li>购买一个域名</li>\n<li>在github上面生成一个github pages的仓库</li>\n<li>搭建Hexo环境</li>\n<li>配置博客</li>\n<li>部署博客</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<p>在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。<br>Github Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。</p>\n<p>下面按步骤说吧：</p>\n<h3 id=\"1-购买一个域名\"><a href=\"#1-购买一个域名\" class=\"headerlink\" title=\"1. 购买一个域名\"></a>1. 购买一个域名</h3><blockquote>\n<p>这里如果你不想使用独立域名，也可以略过这一步    </p>\n</blockquote>\n<p>注册、登录阿里云账号，然后选择-&gt;域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  </p>\n<h3 id=\"2-在github上面生成一个github-pages的仓库\"><a href=\"#2-在github上面生成一个github-pages的仓库\" class=\"headerlink\" title=\"2. 在github上面生成一个github pages的仓库\"></a>2. 在github上面生成一个github pages的仓库</h3><p>2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： <img src=\"/images/2015.12.19.01.png\" alt=\"\"><br>2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。<img src=\"/images/2015.12.19.02.png\" alt=\"\"><br>点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://&lt;你的Github用户名&gt;.github.com，这时候如果能够打开说明成功了。   </p>\n<h3 id=\"3-搭建Hexo环境\"><a href=\"#3-搭建Hexo环境\" class=\"headerlink\" title=\"3. 搭建Hexo环境\"></a>3. 搭建Hexo环境</h3><p>3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。<br>3.2 安装Hexo<br>    执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g # 安装hexo工具</span><br></pre></td></tr></table></figure></p>\n<p>3.3 初始化博客<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog #初始化一个blog 可以cd到你想要生成博客的目录</span><br><span class=\"line\">cd blog # 切换到创建博客的目录下</span><br><span class=\"line\">npm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误</span><br></pre></td></tr></table></figure></p>\n<p>这时候生成的博客目录：<img src=\"/images/2015.12.19.03.png\" alt=\"\"><br>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></p>\n<p>这时候在浏览器访问<a href=\"http://0.0.0.0:4000/\" target=\"_blank\" rel=\"external\">http://0.0.0.0:4000/</a>，应该能够看到已经搭建好的博客了。  </p>\n<h3 id=\"4-配置博客\"><a href=\"#4-配置博客\" class=\"headerlink\" title=\"4. 配置博客\"></a>4. 配置博客</h3><p>这里主要配置主题、评论插件多说、RSS、域名。<br>我使用的主题是jacman，详细的介绍在<a href=\"http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/\" target=\"_blank\" rel=\"external\">这篇文章</a>已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<a href=\"https://github.com/mengxiangyue/mengxiangyue-blog\" target=\"_blank\" rel=\"external\">https://github.com/mengxiangyue/mengxiangyue-blog</a><br>每个配置项的后面留一个空格，然后再写配置的值，如下”首页:”与后面的”/“之间要留一个空格，否则会出现问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首页: /</span><br></pre></td></tr></table></figure></p>\n<p>如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imglogo:</span><br><span class=\"line\">  enable: true  </span><br><span class=\"line\">  src: img/logo.png</span><br></pre></td></tr></table></figure></p>\n<p>另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。<br>在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   </p>\n<h4 id=\"配置多说插件\"><a href=\"#配置多说插件\" class=\"headerlink\" title=\"配置多说插件\"></a>配置多说插件</h4><p>注册多说（<a href=\"http://duoshuo.com/\" target=\"_blank\" rel=\"external\">http://duoshuo.com/</a>）账户，然后添加站点，按照自己的要求填写信息。<img src=\"/images/2015.12.19.04.png\" alt=\"\"><br>右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是<a href=\"http://mengxinagyue.duoshuo.com/admin/\" target=\"_blank\" rel=\"external\">http://mengxinagyue.duoshuo.com/admin/</a> ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">duoshuo_shortname: mengxinagyue  #修改成你自己的用户名</span><br></pre></td></tr></table></figure></p>\n<p>到这里多说配置完了。</p>\n<h4 id=\"配置RSS\"><a href=\"#配置RSS\" class=\"headerlink\" title=\"配置RSS\"></a>配置RSS</h4><p>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p>\n<p>在博客的配置文件_config.yml中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\"></span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br></pre></td></tr></table></figure></p>\n<p>执行如下命令：</p>\n<blockquote>\n<p>这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate  # 重新生成配置文件 保证我们的修改会生效</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>访问<a href=\"http://0.0.0.0:4000/\" target=\"_blank\" rel=\"external\">http://0.0.0.0:4000/</a>，配置应该已经生效</p>\n<h4 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h4><p>安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。<br><img src=\"/images/2015.12.19.04.png\" alt=\"\">  </p>\n<blockquote>\n<p>配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  </p>\n</blockquote>\n<p>在你的博客的文件夹的source目录下创建一个”CNAME”文件，没有后缀，里面的内容就只是写上你的域名就可以了。</p>\n<h3 id=\"5-部署博客\"><a href=\"#5-部署博客\" class=\"headerlink\" title=\"5. 部署博客\"></a>5. 部署博客</h3><p>在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>在博客的配置文件_config.yml中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: &lt;你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址&gt;</span><br></pre></td></tr></table></figure></p>\n<p>最后执行如下命令：</p>\n<blockquote>\n<p>在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。</p>\n<h3 id=\"下面是我遇到的一些问题\"><a href=\"#下面是我遇到的一些问题\" class=\"headerlink\" title=\"下面是我遇到的一些问题\"></a>下面是我遇到的一些问题</h3><p>1 about路径不存在<br> jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>\n<p>2 图片路径的问题<br>我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：’<img src=\"/images/2015.12.19.05.png\" alt=\"\">‘  </p>\n<p>3 站内搜索<br>配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  </p>\n<p>4 目录序号错误<br>Hexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：<br><img src=\"/images/2015.12.19.06.png\" alt=\"\"><br>我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 解决自动生成文章目录序号问题 --&gt;</span><br><span class=\"line\">&lt;script type=\"text/javascript\"&gt;</span><br><span class=\"line\">var regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");</span><br><span class=\"line\">var tocItemTextArray = $(\".toc-article .toc-item .toc-text\");</span><br><span class=\"line\">for (var i = 0; i &lt; tocItemTextArray.length; i++) &#123;</span><br><span class=\"line\">  var item = tocItemTextArray[i];</span><br><span class=\"line\">  item.textContent = item.textContent.replace(regex, \"\");</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>5 回到顶部不显示<br>jacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   </p>\n<pre><code class=\"shell\">var upperLimit = 300;\n</code></pre>\n<p>6 首页不展开配置<br>jacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   </p>\n<pre><code class=\"javascript\">index:\n  expand: <span class=\"literal\">true</span>  \n  excerpt_link: Read More\n</code></pre>\n<p>然后需要在写文章的时候，在需要在首页截断显示的地方添加”&lt;!–more–>“标签   </p>\n<p>7 写文章即使预览功能<br>在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      </p>\n<blockquote>\n<p>hexo generate –watch  #文件变动 立即重新生成<br>hexo server</p>\n</blockquote>\n<p>终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。</p>\n","excerpt":"<p>已经好久没有写过博客了，主要是因为懒了。<br>前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  </p>\n<p>我自己已经有一个博客了，是在CSDN的博客，博客地址：<a href=\"http://blog.csdn.net/mengxiangyue\">http://blog.csdn.net/mengxiangyue</a>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  </p>\n<p>好了貌似扯得有点远了，下面进入正题。<br>上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  </p>\n<blockquote>\n<ol>\n<li>购买一个域名</li>\n<li>在github上面生成一个github pages的仓库</li>\n<li>搭建Hexo环境</li>\n<li>配置博客</li>\n<li>部署博客</li>\n</ol>\n</blockquote>","more":"<p>在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。<br>Github Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。</p>\n<p>下面按步骤说吧：</p>\n<h3 id=\"1-购买一个域名\"><a href=\"#1-购买一个域名\" class=\"headerlink\" title=\"1. 购买一个域名\"></a>1. 购买一个域名</h3><blockquote>\n<p>这里如果你不想使用独立域名，也可以略过这一步    </p>\n</blockquote>\n<p>注册、登录阿里云账号，然后选择-&gt;域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  </p>\n<h3 id=\"2-在github上面生成一个github-pages的仓库\"><a href=\"#2-在github上面生成一个github-pages的仓库\" class=\"headerlink\" title=\"2. 在github上面生成一个github pages的仓库\"></a>2. 在github上面生成一个github pages的仓库</h3><p>2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： <img src=\"/images/2015.12.19.01.png\" alt=\"\"><br>2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。<img src=\"/images/2015.12.19.02.png\" alt=\"\"><br>点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://&lt;你的Github用户名&gt;.github.com，这时候如果能够打开说明成功了。   </p>\n<h3 id=\"3-搭建Hexo环境\"><a href=\"#3-搭建Hexo环境\" class=\"headerlink\" title=\"3. 搭建Hexo环境\"></a>3. 搭建Hexo环境</h3><p>3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。<br>3.2 安装Hexo<br>    执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g # 安装hexo工具</span><br></pre></td></tr></table></figure></p>\n<p>3.3 初始化博客<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init blog #初始化一个blog 可以cd到你想要生成博客的目录</span><br><span class=\"line\">cd blog # 切换到创建博客的目录下</span><br><span class=\"line\">npm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误</span><br></pre></td></tr></table></figure></p>\n<p>这时候生成的博客目录：<img src=\"/images/2015.12.19.03.png\" alt=\"\"><br>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure></p>\n<p>这时候在浏览器访问<a href=\"http://0.0.0.0:4000/\">http://0.0.0.0:4000/</a>，应该能够看到已经搭建好的博客了。  </p>\n<h3 id=\"4-配置博客\"><a href=\"#4-配置博客\" class=\"headerlink\" title=\"4. 配置博客\"></a>4. 配置博客</h3><p>这里主要配置主题、评论插件多说、RSS、域名。<br>我使用的主题是jacman，详细的介绍在<a href=\"http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/\">这篇文章</a>已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<a href=\"https://github.com/mengxiangyue/mengxiangyue-blog\">https://github.com/mengxiangyue/mengxiangyue-blog</a><br>每个配置项的后面留一个空格，然后再写配置的值，如下”首页:”与后面的”/“之间要留一个空格，否则会出现问题。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">首页: /</span><br></pre></td></tr></table></figure></p>\n<p>如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imglogo:</span><br><span class=\"line\">  enable: true  </span><br><span class=\"line\">  src: img/logo.png</span><br></pre></td></tr></table></figure></p>\n<p>另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。<br>在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   </p>\n<h4 id=\"配置多说插件\"><a href=\"#配置多说插件\" class=\"headerlink\" title=\"配置多说插件\"></a>配置多说插件</h4><p>注册多说（<a href=\"http://duoshuo.com/\">http://duoshuo.com/</a>）账户，然后添加站点，按照自己的要求填写信息。<img src=\"/images/2015.12.19.04.png\" alt=\"\"><br>右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是<a href=\"http://mengxinagyue.duoshuo.com/admin/\">http://mengxinagyue.duoshuo.com/admin/</a> ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">duoshuo_shortname: mengxinagyue  #修改成你自己的用户名</span><br></pre></td></tr></table></figure></p>\n<p>到这里多说配置完了。</p>\n<h4 id=\"配置RSS\"><a href=\"#配置RSS\" class=\"headerlink\" title=\"配置RSS\"></a>配置RSS</h4><p>执行如下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p>\n<p>在博客的配置文件_config.yml中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\"></span><br><span class=\"line\">#Feed Atom</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br></pre></td></tr></table></figure></p>\n<p>执行如下命令：</p>\n<blockquote>\n<p>这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo generate  # 重新生成配置文件 保证我们的修改会生效</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<p>访问<a href=\"http://0.0.0.0:4000/\">http://0.0.0.0:4000/</a>，配置应该已经生效</p>\n<h4 id=\"配置域名\"><a href=\"#配置域名\" class=\"headerlink\" title=\"配置域名\"></a>配置域名</h4><p>安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。<br><img src=\"/images/2015.12.19.04.png\" alt=\"\">  </p>\n<blockquote>\n<p>配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  </p>\n</blockquote>\n<p>在你的博客的文件夹的source目录下创建一个”CNAME”文件，没有后缀，里面的内容就只是写上你的域名就可以了。</p>\n<h3 id=\"5-部署博客\"><a href=\"#5-部署博客\" class=\"headerlink\" title=\"5. 部署博客\"></a>5. 部署博客</h3><p>在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>在博客的配置文件_config.yml中添加如下配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: &lt;你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址&gt;</span><br></pre></td></tr></table></figure></p>\n<p>最后执行如下命令：</p>\n<blockquote>\n<p>在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure>\n<p>最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。</p>\n<h3 id=\"下面是我遇到的一些问题\"><a href=\"#下面是我遇到的一些问题\" class=\"headerlink\" title=\"下面是我遇到的一些问题\"></a>下面是我遇到的一些问题</h3><p>1 about路径不存在<br> jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>\n<p>2 图片路径的问题<br>我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：’<img src=\"/images/2015.12.19.05.png\" alt=\"\">‘  </p>\n<p>3 站内搜索<br>配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  </p>\n<p>4 目录序号错误<br>Hexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：<br><img src=\"/images/2015.12.19.06.png\" alt=\"\"><br>我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 解决自动生成文章目录序号问题 --&gt;</span><br><span class=\"line\">&lt;script type=\"text/javascript\"&gt;</span><br><span class=\"line\">var regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");</span><br><span class=\"line\">var tocItemTextArray = $(\".toc-article .toc-item .toc-text\");</span><br><span class=\"line\">for (var i = 0; i &lt; tocItemTextArray.length; i++) &#123;</span><br><span class=\"line\">  var item = tocItemTextArray[i];</span><br><span class=\"line\">  item.textContent = item.textContent.replace(regex, \"\");</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>5 回到顶部不显示<br>jacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   </p>\n<pre><code class=\"shell\">var upperLimit = 300;\n</code></pre>\n<p>6 首页不展开配置<br>jacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   </p>\n<pre><code class=\"javascript\">index:\n  expand: <span class=\"literal\">true</span>  \n  excerpt_link: Read More\n</code></pre>\n<p>然后需要在写文章的时候，在需要在首页截断显示的地方添加”&lt;!–more–>“标签   </p>\n<p>7 写文章即使预览功能<br>在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      </p>\n<blockquote>\n<p>hexo generate –watch  #文件变动 立即重新生成<br>hexo server</p>\n</blockquote>\n<p>终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。</p>"},{"title":"MAC上Nuclide的安装","date":"2016-01-21T15:10:24.000Z","_content":"\nNuclide是Facebook开发的开发React Native的开发工具，基于Github的Atom开发，以Atom插件的形式存在。在MAC版Atom安装插件可以使用系统自带的插件安装方式安装：Atom->Preferences..->Install,搜索Nuclide-installer,点击install就可以安装Nuclide了。安装完了是不是很幸福，能开心的编程了。啊啊啊啊啊.....但是事实并非如此，打开编辑器发现根本不能用，卡成翔了，查看一下进程，发现有个AtomHelper CPU占用率超过100%了。去github查看issue发现好多人都遇到了这个问题。自己试验了半天找到了一种安装方式：\n\n1. 删除已经安装的Nuclide插件    \n  这里我是直接卸载Atom，这样能够删除安静。对于曾经安装的插件，记录下来，重新安装。\n2. 编译Nuclide   \n  从<https://github.com/facebook/nuclide>下载Nuclide，终端进入下载后的目录，执行命令 **./scripts/dev/setup** 。编译的过程中如果没有出现错误信息，就表示编译成功了。将文件夹重命名为nuclide，然后拷贝到~/.atom/packages/目录下。重启Atom，第一次启动应该比较慢，等启动结束后进入Atom->Preferences..->Packages，如果列出了nuclide，表示安装成功了。  \n3. 升级flow   \n  这样安装后可能flow不能使用，因为.flowconfig文件末尾会有一个版本，如果我们本地版本低于其中配置的版本将不能使用flow，我们可以直接删除这个版本配置，这样就能使用了。但是这个并不是好的解决方案，好的解决方案是将flow升级到最新版本。在终端中执行如下命令：\n```shell\nbrew update\nbrew upgrade flow\n```  \n\n升级后应该flow就能正常使用了。   \n\n这样就能够正常的使用Nuclide了。\n","source":"_posts/MAC上Nuclide的安装.md","raw":"title: MAC上Nuclide的安装\ndate: 2016-01-21 23:10:24\ncategories:\n  - React Native\ntags:\n  - React Native\n---\n\nNuclide是Facebook开发的开发React Native的开发工具，基于Github的Atom开发，以Atom插件的形式存在。在MAC版Atom安装插件可以使用系统自带的插件安装方式安装：Atom->Preferences..->Install,搜索Nuclide-installer,点击install就可以安装Nuclide了。安装完了是不是很幸福，能开心的编程了。啊啊啊啊啊.....但是事实并非如此，打开编辑器发现根本不能用，卡成翔了，查看一下进程，发现有个AtomHelper CPU占用率超过100%了。去github查看issue发现好多人都遇到了这个问题。自己试验了半天找到了一种安装方式：\n\n1. 删除已经安装的Nuclide插件    \n  这里我是直接卸载Atom，这样能够删除安静。对于曾经安装的插件，记录下来，重新安装。\n2. 编译Nuclide   \n  从<https://github.com/facebook/nuclide>下载Nuclide，终端进入下载后的目录，执行命令 **./scripts/dev/setup** 。编译的过程中如果没有出现错误信息，就表示编译成功了。将文件夹重命名为nuclide，然后拷贝到~/.atom/packages/目录下。重启Atom，第一次启动应该比较慢，等启动结束后进入Atom->Preferences..->Packages，如果列出了nuclide，表示安装成功了。  \n3. 升级flow   \n  这样安装后可能flow不能使用，因为.flowconfig文件末尾会有一个版本，如果我们本地版本低于其中配置的版本将不能使用flow，我们可以直接删除这个版本配置，这样就能使用了。但是这个并不是好的解决方案，好的解决方案是将flow升级到最新版本。在终端中执行如下命令：\n```shell\nbrew update\nbrew upgrade flow\n```  \n\n升级后应该flow就能正常使用了。   \n\n这样就能够正常的使用Nuclide了。\n","slug":"MAC上Nuclide的安装","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0c00033is69l727bbw","content":"<p>Nuclide是Facebook开发的开发React Native的开发工具，基于Github的Atom开发，以Atom插件的形式存在。在MAC版Atom安装插件可以使用系统自带的插件安装方式安装：Atom-&gt;Preferences..-&gt;Install,搜索Nuclide-installer,点击install就可以安装Nuclide了。安装完了是不是很幸福，能开心的编程了。啊啊啊啊啊…..但是事实并非如此，打开编辑器发现根本不能用，卡成翔了，查看一下进程，发现有个AtomHelper CPU占用率超过100%了。去github查看issue发现好多人都遇到了这个问题。自己试验了半天找到了一种安装方式：</p>\n<ol>\n<li>删除已经安装的Nuclide插件<br>这里我是直接卸载Atom，这样能够删除安静。对于曾经安装的插件，记录下来，重新安装。</li>\n<li>编译Nuclide<br>从<a href=\"https://github.com/facebook/nuclide\" target=\"_blank\" rel=\"external\">https://github.com/facebook/nuclide</a>下载Nuclide，终端进入下载后的目录，执行命令 <strong>./scripts/dev/setup</strong> 。编译的过程中如果没有出现错误信息，就表示编译成功了。将文件夹重命名为nuclide，然后拷贝到~/.atom/packages/目录下。重启Atom，第一次启动应该比较慢，等启动结束后进入Atom-&gt;Preferences..-&gt;Packages，如果列出了nuclide，表示安装成功了。  </li>\n<li>升级flow<br>这样安装后可能flow不能使用，因为.flowconfig文件末尾会有一个版本，如果我们本地版本低于其中配置的版本将不能使用flow，我们可以直接删除这个版本配置，这样就能使用了。但是这个并不是好的解决方案，好的解决方案是将flow升级到最新版本。在终端中执行如下命令：<pre><code class=\"shell\">brew update\nbrew upgrade flow\n</code></pre>\n</li>\n</ol>\n<p>升级后应该flow就能正常使用了。   </p>\n<p>这样就能够正常的使用Nuclide了。</p>\n","excerpt":"","more":"<p>Nuclide是Facebook开发的开发React Native的开发工具，基于Github的Atom开发，以Atom插件的形式存在。在MAC版Atom安装插件可以使用系统自带的插件安装方式安装：Atom-&gt;Preferences..-&gt;Install,搜索Nuclide-installer,点击install就可以安装Nuclide了。安装完了是不是很幸福，能开心的编程了。啊啊啊啊啊…..但是事实并非如此，打开编辑器发现根本不能用，卡成翔了，查看一下进程，发现有个AtomHelper CPU占用率超过100%了。去github查看issue发现好多人都遇到了这个问题。自己试验了半天找到了一种安装方式：</p>\n<ol>\n<li>删除已经安装的Nuclide插件<br>这里我是直接卸载Atom，这样能够删除安静。对于曾经安装的插件，记录下来，重新安装。</li>\n<li>编译Nuclide<br>从<a href=\"https://github.com/facebook/nuclide\">https://github.com/facebook/nuclide</a>下载Nuclide，终端进入下载后的目录，执行命令 <strong>./scripts/dev/setup</strong> 。编译的过程中如果没有出现错误信息，就表示编译成功了。将文件夹重命名为nuclide，然后拷贝到~/.atom/packages/目录下。重启Atom，第一次启动应该比较慢，等启动结束后进入Atom-&gt;Preferences..-&gt;Packages，如果列出了nuclide，表示安装成功了。  </li>\n<li>升级flow<br>这样安装后可能flow不能使用，因为.flowconfig文件末尾会有一个版本，如果我们本地版本低于其中配置的版本将不能使用flow，我们可以直接删除这个版本配置，这样就能使用了。但是这个并不是好的解决方案，好的解决方案是将flow升级到最新版本。在终端中执行如下命令：<pre><code class=\"shell\">brew update\nbrew upgrade flow\n</code></pre>\n</li>\n</ol>\n<p>升级后应该flow就能正常使用了。   </p>\n<p>这样就能够正常的使用Nuclide了。</p>\n"},{"title":"iOS NavigationBar手势返回的时候跟随","date":"2015-12-23T15:22:39.000Z","_content":"\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","source":"_posts/iOS-NavigationBar手势返回的时候跟随.md","raw":"title: iOS NavigationBar手势返回的时候跟随\ndate: 2015-12-23 23:22:39\ncategories:\n  - iOS Tips\ntags:\n---\n\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","slug":"iOS-NavigationBar手势返回的时候跟随","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0h00063is6r4kn6ya9","content":"<p>在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   </p>\n<p><img src=\"/images/2015.12.23.NavigationBarTest.gif\" alt=\"\">  </p>\n<a id=\"more\"></a>\n<p>这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 第一个ViewController</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">    <span class=\"comment\">// 这里一定要使用这个方法 否则会有问题</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController?.setNavigationBarHidden(<span class=\"literal\">true</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个ViewController</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController?.setNavigationBarHidden(<span class=\"literal\">false</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<a href=\"https://github.com/esonchen/CCSlideNavigationTransition\" target=\"_blank\" rel=\"external\">https://github.com/esonchen/CCSlideNavigationTransition</a>。   </p>\n<p>这篇文章比较短，只是一个简单的Tip而已。</p>\n","excerpt":"<p>在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   </p>\n<p><img src=\"/images/2015.12.23.NavigationBarTest.gif\" alt=\"\">  </p>","more":"<p>这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 第一个ViewController</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">    <span class=\"comment\">// 这里一定要使用这个方法 否则会有问题</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController?.setNavigationBarHidden(<span class=\"literal\">true</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二个ViewController</span></span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.navigationController?.setNavigationBarHidden(<span class=\"literal\">false</span>, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<a href=\"https://github.com/esonchen/CCSlideNavigationTransition\">https://github.com/esonchen/CCSlideNavigationTransition</a>。   </p>\n<p>这篇文章比较短，只是一个简单的Tip而已。</p>"},{"title":"OC项目中使用Swift","date":"2016-01-11T13:37:38.000Z","_content":"\n最近公司的项目开始计划使用Swift，由于原先的工程都是使用OC编写的，不可能一下全部转换成Swift，所以采用OC与Swift混编的方式是最好的选择。这篇文章只是一个简单的介绍，并没有太高深的知识。\n\n我新建了一个演示的OC工程，当然你可以使用你已经存在的OC的工程。如果我们想要在OC工程中使用Swift的代码，Swift的代码默认是使用module管理的，同样这里我们也需要把我们的Swift代码作为一个module暴露给我们的OC工程，修改下面的配置：\n![](/images/2016.01.11/01.png)\n\n上面的修改了一个配置项，有一个Product Module Name在后面会使用。\n\n<!---more---->\n\n在工程里面点击File/New/File...,选择iOS/Source/Cocoa Touch Class,按照如下填写创建一个新的文件：\n![](/images/2016.01.11/02.png)\n\n上图中的Subclass of一定要设置为NSObject或其子类，否则OC工程将不会找到该类。   \n\n点击确认后会选择保存路径，点击Create，出现如下界面：\n![](/images/2016.01.11/03.png)\n\n> 这个界面是询问是否创建桥接的头文件，这个文件在Swift调用OC代码的时候比较管用，但是在OC中调用Swift的时候我发现没有什么卵用。   \n\n选择Don't Create按钮。   \n\n在Test.swift中添加如下的代码(解释都在注释里面了)：\n{% codeblock lang:swift %}\nimport UIKit\n\n/*\n    如果Swift类想要被OC发现，必须继承自NSObject并且使用public标记，并且该类中想要被OC访问的方法也必须使用public标记，具体知识可以去看Swift的访问控制\n    原因：Swift的代码对于OC来说是作为一个module存在的\n\n    当然全局的Swift函数，我还没发现怎么在OC中访问，如果哪位清楚还请告诉一下，谢谢！\n*/\n\n\npublic class Test: NSObject {\n    public func log() {\n        print(\"这是Swift的方法\")\n    }\n}\n\npublic func globalLog() {\n    print(\"这是Swift全局的log方法\")\n}\n{% endcodeblock %}   \n\n我们在我们想要调用Swift类的方法里面引入头文件：\"Product Module Name-Swift.h\",其中Product Module Name替换成在上面配置项中显示的内容，例如：\n{% codeblock lang:swift %}\n#import \"ViewController.h\"\n// 引入Swift头文件\n#import \"OCAndSwift-Swift.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 使用Swift的类\n    Test *test = [[Test alloc] init];\n    [test log];\n}\n\n@end\n{% endcodeblock %}  \n\n这样我们就能够在OC中使用Swift的代码了，最后还要说明一点：\"Product Module Name-Swift.h\"（例子中的是OCAndSwift-Swift.h），是由编译器自动生成的，如果import后没有提示，编译一下。并且只有在工程中包含至少一个Swift文件的时候，才会自动生成这个文件，所以如果工程中如果没有Swift文件的时候，就算在配置中设置对了，import该文件也会报错。\n","source":"_posts/OC项目中使用Swift.md","raw":"title: OC项目中使用Swift\ndate: 2016-01-11 21:37:38\ncategories:\n  - iOS Tips\ntags:\n  - iOS 9\n---\n\n最近公司的项目开始计划使用Swift，由于原先的工程都是使用OC编写的，不可能一下全部转换成Swift，所以采用OC与Swift混编的方式是最好的选择。这篇文章只是一个简单的介绍，并没有太高深的知识。\n\n我新建了一个演示的OC工程，当然你可以使用你已经存在的OC的工程。如果我们想要在OC工程中使用Swift的代码，Swift的代码默认是使用module管理的，同样这里我们也需要把我们的Swift代码作为一个module暴露给我们的OC工程，修改下面的配置：\n![](/images/2016.01.11/01.png)\n\n上面的修改了一个配置项，有一个Product Module Name在后面会使用。\n\n<!---more---->\n\n在工程里面点击File/New/File...,选择iOS/Source/Cocoa Touch Class,按照如下填写创建一个新的文件：\n![](/images/2016.01.11/02.png)\n\n上图中的Subclass of一定要设置为NSObject或其子类，否则OC工程将不会找到该类。   \n\n点击确认后会选择保存路径，点击Create，出现如下界面：\n![](/images/2016.01.11/03.png)\n\n> 这个界面是询问是否创建桥接的头文件，这个文件在Swift调用OC代码的时候比较管用，但是在OC中调用Swift的时候我发现没有什么卵用。   \n\n选择Don't Create按钮。   \n\n在Test.swift中添加如下的代码(解释都在注释里面了)：\n{% codeblock lang:swift %}\nimport UIKit\n\n/*\n    如果Swift类想要被OC发现，必须继承自NSObject并且使用public标记，并且该类中想要被OC访问的方法也必须使用public标记，具体知识可以去看Swift的访问控制\n    原因：Swift的代码对于OC来说是作为一个module存在的\n\n    当然全局的Swift函数，我还没发现怎么在OC中访问，如果哪位清楚还请告诉一下，谢谢！\n*/\n\n\npublic class Test: NSObject {\n    public func log() {\n        print(\"这是Swift的方法\")\n    }\n}\n\npublic func globalLog() {\n    print(\"这是Swift全局的log方法\")\n}\n{% endcodeblock %}   \n\n我们在我们想要调用Swift类的方法里面引入头文件：\"Product Module Name-Swift.h\",其中Product Module Name替换成在上面配置项中显示的内容，例如：\n{% codeblock lang:swift %}\n#import \"ViewController.h\"\n// 引入Swift头文件\n#import \"OCAndSwift-Swift.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 使用Swift的类\n    Test *test = [[Test alloc] init];\n    [test log];\n}\n\n@end\n{% endcodeblock %}  \n\n这样我们就能够在OC中使用Swift的代码了，最后还要说明一点：\"Product Module Name-Swift.h\"（例子中的是OCAndSwift-Swift.h），是由编译器自动生成的，如果import后没有提示，编译一下。并且只有在工程中包含至少一个Swift文件的时候，才会自动生成这个文件，所以如果工程中如果没有Swift文件的时候，就算在配置中设置对了，import该文件也会报错。\n","slug":"OC项目中使用Swift","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0i00073is62p71z0zy","content":"<p>最近公司的项目开始计划使用Swift，由于原先的工程都是使用OC编写的，不可能一下全部转换成Swift，所以采用OC与Swift混编的方式是最好的选择。这篇文章只是一个简单的介绍，并没有太高深的知识。</p>\n<p>我新建了一个演示的OC工程，当然你可以使用你已经存在的OC的工程。如果我们想要在OC工程中使用Swift的代码，Swift的代码默认是使用module管理的，同样这里我们也需要把我们的Swift代码作为一个module暴露给我们的OC工程，修改下面的配置：<br><img src=\"/images/2016.01.11/01.png\" alt=\"\"></p>\n<p>上面的修改了一个配置项，有一个Product Module Name在后面会使用。</p>\n<a id=\"more\"></a>\n<p>在工程里面点击File/New/File…,选择iOS/Source/Cocoa Touch Class,按照如下填写创建一个新的文件：<br><img src=\"/images/2016.01.11/02.png\" alt=\"\"></p>\n<p>上图中的Subclass of一定要设置为NSObject或其子类，否则OC工程将不会找到该类。   </p>\n<p>点击确认后会选择保存路径，点击Create，出现如下界面：<br><img src=\"/images/2016.01.11/03.png\" alt=\"\"></p>\n<blockquote>\n<p>这个界面是询问是否创建桥接的头文件，这个文件在Swift调用OC代码的时候比较管用，但是在OC中调用Swift的时候我发现没有什么卵用。   </p>\n</blockquote>\n<p>选择Don’t Create按钮。   </p>\n<p>在Test.swift中添加如下的代码(解释都在注释里面了)：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">    如果Swift类想要被OC发现，必须继承自NSObject并且使用public标记，并且该类中想要被OC访问的方法也必须使用public标记，具体知识可以去看Swift的访问控制</span><br><span class=\"line\">    原因：Swift的代码对于OC来说是作为一个module存在的</span><br><span class=\"line\"></span><br><span class=\"line\">    当然全局的Swift函数，我还没发现怎么在OC中访问，如果哪位清楚还请告诉一下，谢谢！</span><br><span class=\"line\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">log</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"这是Swift的方法\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">globalLog</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"这是Swift全局的log方法\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>我们在我们想要调用Swift类的方法里面引入头文件：”Product Module Name-Swift.h”,其中Product Module Name替换成在上面配置项中显示的内容，例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> \"ViewController.h\"</span><br><span class=\"line\"><span class=\"comment\">// 引入Swift头文件</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> \"OCAndSwift-Swift.h\"</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用Swift的类</span></span><br><span class=\"line\">    <span class=\"type\">Test</span> *test = [[<span class=\"type\">Test</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    [test log];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>  </p>\n<p>这样我们就能够在OC中使用Swift的代码了，最后还要说明一点：”Product Module Name-Swift.h”（例子中的是OCAndSwift-Swift.h），是由编译器自动生成的，如果import后没有提示，编译一下。并且只有在工程中包含至少一个Swift文件的时候，才会自动生成这个文件，所以如果工程中如果没有Swift文件的时候，就算在配置中设置对了，import该文件也会报错。</p>\n","excerpt":"<p>最近公司的项目开始计划使用Swift，由于原先的工程都是使用OC编写的，不可能一下全部转换成Swift，所以采用OC与Swift混编的方式是最好的选择。这篇文章只是一个简单的介绍，并没有太高深的知识。</p>\n<p>我新建了一个演示的OC工程，当然你可以使用你已经存在的OC的工程。如果我们想要在OC工程中使用Swift的代码，Swift的代码默认是使用module管理的，同样这里我们也需要把我们的Swift代码作为一个module暴露给我们的OC工程，修改下面的配置：<br><img src=\"/images/2016.01.11/01.png\" alt=\"\"></p>\n<p>上面的修改了一个配置项，有一个Product Module Name在后面会使用。</p>","more":"<p>在工程里面点击File/New/File…,选择iOS/Source/Cocoa Touch Class,按照如下填写创建一个新的文件：<br><img src=\"/images/2016.01.11/02.png\" alt=\"\"></p>\n<p>上图中的Subclass of一定要设置为NSObject或其子类，否则OC工程将不会找到该类。   </p>\n<p>点击确认后会选择保存路径，点击Create，出现如下界面：<br><img src=\"/images/2016.01.11/03.png\" alt=\"\"></p>\n<blockquote>\n<p>这个界面是询问是否创建桥接的头文件，这个文件在Swift调用OC代码的时候比较管用，但是在OC中调用Swift的时候我发现没有什么卵用。   </p>\n</blockquote>\n<p>选择Don’t Create按钮。   </p>\n<p>在Test.swift中添加如下的代码(解释都在注释里面了)：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\">    如果Swift类想要被OC发现，必须继承自NSObject并且使用public标记，并且该类中想要被OC访问的方法也必须使用public标记，具体知识可以去看Swift的访问控制</span><br><span class=\"line\">    原因：Swift的代码对于OC来说是作为一个module存在的</span><br><span class=\"line\"></span><br><span class=\"line\">    当然全局的Swift函数，我还没发现怎么在OC中访问，如果哪位清楚还请告诉一下，谢谢！</span><br><span class=\"line\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>: <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">log</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"这是Swift的方法\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">globalLog</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"这是Swift全局的log方法\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>我们在我们想要调用Swift类的方法里面引入头文件：”Product Module Name-Swift.h”,其中Product Module Name替换成在上面配置项中显示的内容，例如：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"keyword\">import</span> \"ViewController.h\"</span><br><span class=\"line\"><span class=\"comment\">// 引入Swift头文件</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> \"OCAndSwift-Swift.h\"</span><br><span class=\"line\"></span><br><span class=\"line\">@implementation <span class=\"type\">ViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用Swift的类</span></span><br><span class=\"line\">    <span class=\"type\">Test</span> *test = [[<span class=\"type\">Test</span> alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    [test log];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@end</span><br></pre></td></tr></table></figure>  </p>\n<p>这样我们就能够在OC中使用Swift的代码了，最后还要说明一点：”Product Module Name-Swift.h”（例子中的是OCAndSwift-Swift.h），是由编译器自动生成的，如果import后没有提示，编译一下。并且只有在工程中包含至少一个Swift文件的时候，才会自动生成这个文件，所以如果工程中如果没有Swift文件的时候，就算在配置中设置对了，import该文件也会报错。</p>"},{"title":"iOS9 by Tutorials 学习笔记三：Your App on the Web","date":"2015-12-27T10:22:56.000Z","_content":"\n> 这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   \n\n在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  \n\n### Getting started   \n这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8>进行下载。APP截图如下：\n![](/images/2015.12.27.07.png)   \n\n### Linking to your app\n在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   \n\n#### Deep links\n在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app>://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   \n\n<!--more-->\n\n一旦设置了URL scheme，就能够通过openURL(\\_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(\\_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   \n* 安全 UIApplication有一个方法canOpenURL(\\_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   \n> canOpenURL(\\_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  \n\n* 冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(\\_:)，iPhone将不会知道应该怎么处理。   \n* No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   \n\niOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  \n\n#### Universal links\n这里举了一个例子：你有一个域名clownapp.com，你可以注册http://clownapp.com作为你的universal link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。   \n> PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   \n\nUniversal links与deep links有如下的有点：  \n* 唯一 由于使用的是域名，能够保证唯一性\n* 安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  \n> 这里原文如下There's also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。\n\n* 简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。\n\n#### 注册你的App，使其能够处理universal links   \n为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：  \n![](/images/2015.12.27.08.png)  \n\n> 这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   \n\n#### 注册你的服务器能够处理unilateral links  \n你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：\n{% codeblock lang:swift %}\n{\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"KFCNEC27GU.com.razeware.RWDevCon\",\n                \"paths\": [\n                    \"/videos/\\*\"\n                ]\n            }\n        ]\n    }\n}\n{% endcodeblock %}  \n其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 \\*，？ 等，如 /videos/\\*/year/201?/videoName。   \n\n这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。\n\n#### 在你的App上处理universal links\n> 这部分代码没有试验    \n\n上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：\n{% codeblock lang:swift %}\nclass func sessionByWebPath(path: String,\ncontext: NSManagedObjectContext) -> Session? {\n\n  let fetch = NSFetchRequest(entityName: \"Session\")\n  fetch.predicate = NSPredicate(format: \"webPath = %@\", [path])\n\n  do {\n    let results = try context.executeFetchRequest(fetch)\n    return results.first as? Session\n  } catch let fetchError as NSError {\n    print(\"fetch error: \\(fetchError.localizedDescription)\")\n  }\n\n  return nil\n}\n{% endcodeblock %}  \n\n在AppDelegate.swift添加如下方法：\n{% codeblock lang:swift %}\nextension AppDelegate {\n  // 辅助方法\n  func presentVideoViewController(URL: NSURL) {\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    let navID = \"NavPlayerViewController\"\n\n    let navVideoPlayerVC =\n    storyboard.instantiateViewControllerWithIdentifier(navID)\n      as! UINavigationController\n\n    navVideoPlayerVC.modalPresentationStyle = .FormSheet\n\n    if let videoPlayerVC = navVideoPlayerVC.topViewController\n      as? AVPlayerViewController {\n\n        videoPlayerVC.player = AVPlayer(URL: URL)\n\n        let rootViewController = window?.rootViewController\n        rootViewController?.presentViewController(navVideoPlayerVC,\n          animated: true, completion: nil)\n    }\n  }\n\n  func application(application: UIApplication,\n    continueUserActivity\n    userActivity: NSUserActivity,\n    restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n\n      //1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links\n      if userActivity.activityType ==\n        NSUserActivityTypeBrowsingWeb {\n\n          let universalURL = userActivity.webpageURL!\n\n          //2 提取出 url 的不同部分\n          if let components = NSURLComponents(URL: universalURL,\n            resolvingAgainstBaseURL: true),\n            let path = components.path {\n\n              if let session = Session.sessionByWebPath(path,\n                context: coreDataStack.context) {\n                  //3 找到 session，然后播放 video\n                  let videoURL = NSURL(string: session.videoUrl)!\n                  presentVideoViewController(videoURL)\n                  return true\n              } else {\n                //4 无法理解就打开网站首页\n                let app = UIApplication.sharedApplication()\n                let url = NSURL(string: \"http://www.rwdevcon.com\")!\n                app.openURL(url)\n              }\n          }\n      }\n      return false\n  }\n}\n{% endcodeblock %}   \n\n下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功\n{% codeblock lang:swift %}  \ngood link\nhttp://www.rwdevcon.com/videos/talk-tammy-coron-possible.html\nbad link\nhttp://www.rwdevcon.com/videos/tim-cook-keynote.html\n{% endcodeblock %}   \n\n### 使用web markup\nSearch 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。\n\n你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   \n\n苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   \n\n#### 使你的网站能够被发现   \n苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。\n1. 在iTunes Connect中，在设置**Support URL**的地方，设置**Marketing URL**，指向你已经使用markup的网站。  \n![](/images/2015.12.27.09.png)\n2. 保证你填写的URL能够被苹果的爬虫访问到。\n3. 检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。\n\n#### 添加Smart App Banners\n添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：\n![](/images/2015.12.27.10.png)   \n\n实现这个效果的方式，在你想要添加banner的网页上添加如下代码：\n{% codeblock lang:html %}\n<meta name=\"apple-itunes-app\" content=\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}\n这里的name是App在store中的名字，下面的content包含两部分内容：\n* app-id 在store上的app id\n* app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links\n> Smart App Banners 仅仅支持 Safari   \n\n你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：\n{% codeblock lang:html %}\n// Twitter Cards  具体 https://dev.twitter.com/cards/mobile\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n\n// App Links 具体http://applinks.org\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}    \n\n#### Semantic markup using Open Graph  \n苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   \n\nApple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。\n\n最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。\n{% codeblock lang:html %}\n<meta property=\"og:image\" content=\"http://www.rwdevcon.com/assets/images/  \nvideos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:secure_url\" content=\"https://www.rwdevcon.com/  \nassets/images/videos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:type\" content=\"image/jpeg\" />  \n<meta property=\"og:image:width\" content=\"640\" />  \n<meta property=\"og:image:height\" content=\"340\" />  \n<meta property=\"og:video\" content=\"http://www.rwdevcon.com/videos/Ray-  \nWenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:secure_url\" content=\"https://www.rwdevcon.com/  \nvideos/Ray-Wenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:type\" content=\"video/mp4\" />  \n<meta property=\"og:video:width\" content=\"1280\" />  \n<meta property=\"og:video:height\" content=\"720\" />  \n<meta property=\"og:description\" content=\"Learn how teamwork lets you  \ndream bigger, through the story of an indie iPhone developer who almost  \nmissed out on the greatest opportunity of his life.\" />\n{% endcodeblock %}\n\n> 上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢\n\n关于web markup相关的详细的东西可以看苹果的文档<https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html>\n\n最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。\n\n突然感觉这是最没底的一篇文章。\n","source":"_posts/iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web.md","raw":"title: iOS9 by Tutorials 学习笔记三：Your App on the Web\ndate: 2015-12-27 18:22:56\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n> 这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   \n\n在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  \n\n### Getting started   \n这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8>进行下载。APP截图如下：\n![](/images/2015.12.27.07.png)   \n\n### Linking to your app\n在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   \n\n#### Deep links\n在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app>://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   \n\n<!--more-->\n\n一旦设置了URL scheme，就能够通过openURL(\\_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(\\_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   \n* 安全 UIApplication有一个方法canOpenURL(\\_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   \n> canOpenURL(\\_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  \n\n* 冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(\\_:)，iPhone将不会知道应该怎么处理。   \n* No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   \n\niOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  \n\n#### Universal links\n这里举了一个例子：你有一个域名clownapp.com，你可以注册http://clownapp.com作为你的universal link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。   \n> PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   \n\nUniversal links与deep links有如下的有点：  \n* 唯一 由于使用的是域名，能够保证唯一性\n* 安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  \n> 这里原文如下There's also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。\n\n* 简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。\n\n#### 注册你的App，使其能够处理universal links   \n为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：  \n![](/images/2015.12.27.08.png)  \n\n> 这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   \n\n#### 注册你的服务器能够处理unilateral links  \n你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：\n{% codeblock lang:swift %}\n{\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"KFCNEC27GU.com.razeware.RWDevCon\",\n                \"paths\": [\n                    \"/videos/\\*\"\n                ]\n            }\n        ]\n    }\n}\n{% endcodeblock %}  \n其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 \\*，？ 等，如 /videos/\\*/year/201?/videoName。   \n\n这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。\n\n#### 在你的App上处理universal links\n> 这部分代码没有试验    \n\n上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：\n{% codeblock lang:swift %}\nclass func sessionByWebPath(path: String,\ncontext: NSManagedObjectContext) -> Session? {\n\n  let fetch = NSFetchRequest(entityName: \"Session\")\n  fetch.predicate = NSPredicate(format: \"webPath = %@\", [path])\n\n  do {\n    let results = try context.executeFetchRequest(fetch)\n    return results.first as? Session\n  } catch let fetchError as NSError {\n    print(\"fetch error: \\(fetchError.localizedDescription)\")\n  }\n\n  return nil\n}\n{% endcodeblock %}  \n\n在AppDelegate.swift添加如下方法：\n{% codeblock lang:swift %}\nextension AppDelegate {\n  // 辅助方法\n  func presentVideoViewController(URL: NSURL) {\n    let storyboard = UIStoryboard(name: \"Main\", bundle: nil)\n    let navID = \"NavPlayerViewController\"\n\n    let navVideoPlayerVC =\n    storyboard.instantiateViewControllerWithIdentifier(navID)\n      as! UINavigationController\n\n    navVideoPlayerVC.modalPresentationStyle = .FormSheet\n\n    if let videoPlayerVC = navVideoPlayerVC.topViewController\n      as? AVPlayerViewController {\n\n        videoPlayerVC.player = AVPlayer(URL: URL)\n\n        let rootViewController = window?.rootViewController\n        rootViewController?.presentViewController(navVideoPlayerVC,\n          animated: true, completion: nil)\n    }\n  }\n\n  func application(application: UIApplication,\n    continueUserActivity\n    userActivity: NSUserActivity,\n    restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n\n      //1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links\n      if userActivity.activityType ==\n        NSUserActivityTypeBrowsingWeb {\n\n          let universalURL = userActivity.webpageURL!\n\n          //2 提取出 url 的不同部分\n          if let components = NSURLComponents(URL: universalURL,\n            resolvingAgainstBaseURL: true),\n            let path = components.path {\n\n              if let session = Session.sessionByWebPath(path,\n                context: coreDataStack.context) {\n                  //3 找到 session，然后播放 video\n                  let videoURL = NSURL(string: session.videoUrl)!\n                  presentVideoViewController(videoURL)\n                  return true\n              } else {\n                //4 无法理解就打开网站首页\n                let app = UIApplication.sharedApplication()\n                let url = NSURL(string: \"http://www.rwdevcon.com\")!\n                app.openURL(url)\n              }\n          }\n      }\n      return false\n  }\n}\n{% endcodeblock %}   \n\n下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功\n{% codeblock lang:swift %}  \ngood link\nhttp://www.rwdevcon.com/videos/talk-tammy-coron-possible.html\nbad link\nhttp://www.rwdevcon.com/videos/tim-cook-keynote.html\n{% endcodeblock %}   \n\n### 使用web markup\nSearch 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。\n\n你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   \n\n苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   \n\n#### 使你的网站能够被发现   \n苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。\n1. 在iTunes Connect中，在设置**Support URL**的地方，设置**Marketing URL**，指向你已经使用markup的网站。  \n![](/images/2015.12.27.09.png)\n2. 保证你填写的URL能够被苹果的爬虫访问到。\n3. 检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。\n\n#### 添加Smart App Banners\n添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：\n![](/images/2015.12.27.10.png)   \n\n实现这个效果的方式，在你想要添加banner的网页上添加如下代码：\n{% codeblock lang:html %}\n<meta name=\"apple-itunes-app\" content=\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}\n这里的name是App在store中的名字，下面的content包含两部分内容：\n* app-id 在store上的app id\n* app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links\n> Smart App Banners 仅仅支持 Safari   \n\n你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：\n{% codeblock lang:html %}\n// Twitter Cards  具体 https://dev.twitter.com/cards/mobile\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n\n// App Links 具体http://applinks.org\n<meta name=\"twitter:app:name:iphone\" content=\"RWDevCon\">\n<meta name=\"twitter:app:id:iphone\" content=\"958625272\">\n<meta name=\"twitter:app:url:iphone\" content=\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\">\n{% endcodeblock %}    \n\n#### Semantic markup using Open Graph  \n苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   \n\nApple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。\n\n最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。\n{% codeblock lang:html %}\n<meta property=\"og:image\" content=\"http://www.rwdevcon.com/assets/images/  \nvideos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:secure_url\" content=\"https://www.rwdevcon.com/  \nassets/images/videos/talk-ray-wenderlich-teamwork.jpg\" />  \n<meta property=\"og:image:type\" content=\"image/jpeg\" />  \n<meta property=\"og:image:width\" content=\"640\" />  \n<meta property=\"og:image:height\" content=\"340\" />  \n<meta property=\"og:video\" content=\"http://www.rwdevcon.com/videos/Ray-  \nWenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:secure_url\" content=\"https://www.rwdevcon.com/  \nvideos/Ray-Wenderlich-Teamwork.mp4\" />  \n<meta property=\"og:video:type\" content=\"video/mp4\" />  \n<meta property=\"og:video:width\" content=\"1280\" />  \n<meta property=\"og:video:height\" content=\"720\" />  \n<meta property=\"og:description\" content=\"Learn how teamwork lets you  \ndream bigger, through the story of an indie iPhone developer who almost  \nmissed out on the greatest opportunity of his life.\" />\n{% endcodeblock %}\n\n> 上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢\n\n关于web markup相关的详细的东西可以看苹果的文档<https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html>\n\n最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。\n\n突然感觉这是最没底的一篇文章。\n","slug":"iOS9-by-Tutorials-学习笔记三：Your-App-on-the-Web","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0j00093is6dedgsgw5","content":"<blockquote>\n<p>这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   </p>\n</blockquote>\n<p>在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  </p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<a href=\"https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8\" target=\"_blank\" rel=\"external\">https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8</a>进行下载。APP截图如下：<br><img src=\"/images/2015.12.27.07.png\" alt=\"\">   </p>\n<h3 id=\"Linking-to-your-app\"><a href=\"#Linking-to-your-app\" class=\"headerlink\" title=\"Linking to your app\"></a>Linking to your app</h3><p>在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   </p>\n<h4 id=\"Deep-links\"><a href=\"#Deep-links\" class=\"headerlink\" title=\"Deep links\"></a>Deep links</h4><p>在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app=\"\">://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   </your></p>\n<a id=\"more\"></a>\n<p>一旦设置了URL scheme，就能够通过openURL(_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   </p>\n<ul>\n<li><p>安全 UIApplication有一个方法canOpenURL(_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   </p>\n<blockquote>\n<p>canOpenURL(_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  </p>\n</blockquote>\n</li>\n<li><p>冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(_:)，iPhone将不会知道应该怎么处理。   </p>\n</li>\n<li>No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   </li>\n</ul>\n<p>iOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  </p>\n<h4 id=\"Universal-links\"><a href=\"#Universal-links\" class=\"headerlink\" title=\"Universal links\"></a>Universal links</h4><p>这里举了一个例子：你有一个域名clownapp.com，你可以注册<a href=\"http://clownapp.com作为你的universal\" target=\"_blank\" rel=\"external\">http://clownapp.com作为你的universal</a> link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接<a href=\"http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。\" target=\"_blank\" rel=\"external\">http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。</a>   </p>\n<blockquote>\n<p>PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   </p>\n</blockquote>\n<p>Universal links与deep links有如下的有点：  </p>\n<ul>\n<li>唯一 由于使用的是域名，能够保证唯一性</li>\n<li><p>安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  </p>\n<blockquote>\n<p>这里原文如下There’s also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。</p>\n</blockquote>\n</li>\n<li><p>简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。</p>\n</li>\n</ul>\n<h4 id=\"注册你的App，使其能够处理universal-links\"><a href=\"#注册你的App，使其能够处理universal-links\" class=\"headerlink\" title=\"注册你的App，使其能够处理universal links\"></a>注册你的App，使其能够处理universal links</h4><p>为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：<br><img src=\"/images/2015.12.27.08.png\" alt=\"\">  </p>\n<blockquote>\n<p>这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   </p>\n</blockquote>\n<h4 id=\"注册你的服务器能够处理unilateral-links\"><a href=\"#注册你的服务器能够处理unilateral-links\" class=\"headerlink\" title=\"注册你的服务器能够处理unilateral links\"></a>注册你的服务器能够处理unilateral links</h4><p>你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"applinks\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"apps\"</span>: [],</span><br><span class=\"line\">        <span class=\"string\">\"details\"</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">\"appID\"</span>: <span class=\"string\">\"KFCNEC27GU.com.razeware.RWDevCon\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"paths\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"/videos/\\*\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 *，？ 等，如 /videos/*/year/201?/videoName。   </p>\n<p>这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。</p>\n<h4 id=\"在你的App上处理universal-links\"><a href=\"#在你的App上处理universal-links\" class=\"headerlink\" title=\"在你的App上处理universal links\"></a>在你的App上处理universal links</h4><blockquote>\n<p>这部分代码没有试验    </p>\n</blockquote>\n<p>上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">sessionByWebPath</span>(<span class=\"title\">path</span>: <span class=\"title\">String</span>,</span><br><span class=\"line\"><span class=\"title\">context</span>: <span class=\"title\">NSManagedObjectContext</span>) -&gt; <span class=\"title\">Session</span>? </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fetch = <span class=\"type\">NSFetchRequest</span>(entityName: <span class=\"string\">\"Session\"</span>)</span><br><span class=\"line\">  fetch.predicate = <span class=\"type\">NSPredicate</span>(format: <span class=\"string\">\"webPath = %@\"</span>, [path])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">try</span> context.executeFetchRequest(fetch)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results.first <span class=\"keyword\">as</span>? <span class=\"type\">Session</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> fetchError <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"fetch error: \\(fetchError.localizedDescription)\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>在AppDelegate.swift添加如下方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppDelegate</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 辅助方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentVideoViewController</span><span class=\"params\">(URL: NSURL)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navID = <span class=\"string\">\"NavPlayerViewController\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> navVideoPlayerVC =</span><br><span class=\"line\">    storyboard.instantiateViewControllerWithIdentifier(navID)</span><br><span class=\"line\">      <span class=\"keyword\">as</span>! <span class=\"type\">UINavigationController</span></span><br><span class=\"line\"></span><br><span class=\"line\">    navVideoPlayerVC.modalPresentationStyle = .<span class=\"type\">FormSheet</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> videoPlayerVC = navVideoPlayerVC.topViewController</span><br><span class=\"line\">      <span class=\"keyword\">as</span>? <span class=\"type\">AVPlayerViewController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        videoPlayerVC.player = <span class=\"type\">AVPlayer</span>(<span class=\"type\">URL</span>: <span class=\"type\">URL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> rootViewController = window?.rootViewController</span><br><span class=\"line\">        rootViewController?.presentViewController(navVideoPlayerVC,</span><br><span class=\"line\">          animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication,</span><br><span class=\"line\">    continueUserActivity</span><br><span class=\"line\">    userActivity: NSUserActivity,</span><br><span class=\"line\">    restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> userActivity.activityType ==</span><br><span class=\"line\">        <span class=\"type\">NSUserActivityTypeBrowsingWeb</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">let</span> universalURL = userActivity.webpageURL!</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">//2 提取出 url 的不同部分</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> components = <span class=\"type\">NSURLComponents</span>(<span class=\"type\">URL</span>: universalURL,</span><br><span class=\"line\">            resolvingAgainstBaseURL: <span class=\"literal\">true</span>),</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path = components.path &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> session = <span class=\"type\">Session</span>.sessionByWebPath(path,</span><br><span class=\"line\">                context: coreDataStack.context) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//3 找到 session，然后播放 video</span></span><br><span class=\"line\">                  <span class=\"keyword\">let</span> videoURL = <span class=\"type\">NSURL</span>(string: session.videoUrl)!</span><br><span class=\"line\">                  presentVideoViewController(videoURL)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//4 无法理解就打开网站首页</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> app = <span class=\"type\">UIApplication</span>.sharedApplication()</span><br><span class=\"line\">                <span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://www.rwdevcon.com\"</span>)!</span><br><span class=\"line\">                app.openURL(url)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">good link</span><br><span class=\"line\">http:<span class=\"comment\">//www.rwdevcon.com/videos/talk-tammy-coron-possible.html</span></span><br><span class=\"line\">bad link</span><br><span class=\"line\">http:<span class=\"comment\">//www.rwdevcon.com/videos/tim-cook-keynote.html</span></span><br></pre></td></tr></table></figure>   </p>\n<h3 id=\"使用web-markup\"><a href=\"#使用web-markup\" class=\"headerlink\" title=\"使用web markup\"></a>使用web markup</h3><p>Search 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。</p>\n<p>你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   </p>\n<p>苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   </p>\n<h4 id=\"使你的网站能够被发现\"><a href=\"#使你的网站能够被发现\" class=\"headerlink\" title=\"使你的网站能够被发现\"></a>使你的网站能够被发现</h4><p>苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。</p>\n<ol>\n<li>在iTunes Connect中，在设置<strong>Support URL</strong>的地方，设置<strong>Marketing URL</strong>，指向你已经使用markup的网站。<br><img src=\"/images/2015.12.27.09.png\" alt=\"\"></li>\n<li>保证你填写的URL能够被苹果的爬虫访问到。</li>\n<li>检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。</li>\n</ol>\n<h4 id=\"添加Smart-App-Banners\"><a href=\"#添加Smart-App-Banners\" class=\"headerlink\" title=\"添加Smart App Banners\"></a>添加Smart App Banners</h4><p>添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：<br><img src=\"/images/2015.12.27.10.png\" alt=\"\">   </p>\n<p>实现这个效果的方式，在你想要添加banner的网页上添加如下代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-itunes-app\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这里的name是App在store中的名字，下面的content包含两部分内容：</p>\n<ul>\n<li>app-id 在store上的app id</li>\n<li>app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links<blockquote>\n<p>Smart App Banners 仅仅支持 Safari   </p>\n</blockquote>\n</li>\n</ul>\n<p>你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Twitter Cards  具体 https://dev.twitter.com/cards/mobile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:name:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"RWDevCon\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:id:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"958625272\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:url:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// App Links 具体http://applinks.org</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:name:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"RWDevCon\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:id:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"958625272\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:url:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br></pre></td></tr></table></figure>    </p>\n<h4 id=\"Semantic-markup-using-Open-Graph\"><a href=\"#Semantic-markup-using-Open-Graph\" class=\"headerlink\" title=\"Semantic markup using Open Graph\"></a>Semantic markup using Open Graph</h4><p>苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   </p>\n<p>Apple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。</p>\n<p>最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/assets/images/  </span><br><span class=\"line\">videos/talk-ray-wenderlich-teamwork.jpg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:secure_url\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"https://www.rwdevcon.com/  </span><br><span class=\"line\">assets/images/videos/talk-ray-wenderlich-teamwork.jpg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"image/jpeg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:width\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"640\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:height\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"340\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/videos/Ray-  </span><br><span class=\"line\">Wenderlich-Teamwork.mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:secure_url\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"https://www.rwdevcon.com/  </span><br><span class=\"line\">videos/Ray-Wenderlich-Teamwork.mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"video/mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:width\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"1280\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:height\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"720\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:description\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Learn how teamwork lets you  </span><br><span class=\"line\">dream bigger, through the story of an indie iPhone developer who almost  </span><br><span class=\"line\">missed out on the greatest opportunity of his life.\"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢</p>\n</blockquote>\n<p>关于web markup相关的详细的东西可以看苹果的文档<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html\" target=\"_blank\" rel=\"external\">https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html</a></p>\n<p>最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。</p>\n<p>突然感觉这是最没底的一篇文章。</p>\n","excerpt":"<blockquote>\n<p>这里首先说明一下：这篇文章由于一些限制，我也没有能够进行实验测试，只是尽可能的解释书中的一些知识，可能会有错误，等以后有条件了，我会实验这篇文章中的内容。但是作为了解内容还是不错的。   </p>\n</blockquote>\n<p>在iOS 9之前在iPhone上native和web之间，基本上算是独立的的两部分内容。但是Apple正在努力缩小两者之间的距离，使其越来越近。在iOS 9退出了universal links和web markup，使你能够提供deep links直接进入你的app和在Spotlight和Safari中能够搜索出来你的内容。  </p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>这一章书中提供了两个工程，一个是APP端的，一个是Server端的，因为这个需要Server端修改一些东西。APP可以通过地址：<a href=\"https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8\">https://itunes.apple.com/us/app/rwdevcon-tutorial-conference/id958625272?mt=8</a>进行下载。APP截图如下：<br><img src=\"/images/2015.12.27.07.png\" alt=\"\">   </p>\n<h3 id=\"Linking-to-your-app\"><a href=\"#Linking-to-your-app\" class=\"headerlink\" title=\"Linking to your app\"></a>Linking to your app</h3><p>在真正开始前，先回顾一下universal link的前辈：deep links。通过这个回顾，了解一下deep links存在的一些问题。   </p>\n<h4 id=\"Deep-links\"><a href=\"#Deep-links\" class=\"headerlink\" title=\"Deep links\"></a>Deep links</h4><p>在iOS 9之前我们可以给APP设置URL scheme，在Info.plist里面添加CFBundleURLTypes key。一般格式类似<your app>://。 另外应该也看到过Apple自己的URL scheme，类似tel://、sms://等。   </p>","more":"<p>一旦设置了URL scheme，就能够通过openURL(_:)方法调用起来该APP，调用的时候后面可以带着一些参数。然后在我们自己的程序里面可以再AppDelegate的application(_:handleOpenURL:)中进行对应的处理。这套系统已经存在很久了，但是现在暴露出来一些问题：   </p>\n<ul>\n<li><p>安全 UIApplication有一个方法canOpenURL(_:),可以用来检测用户是否能够打开某个URL secheme，本来苹果的设计是好的，但是不幸的是现在好多开发商使用这个来检测用户手机安排了什么APP，这样就收集了用户的APP列表，涉及到了用户的隐私。   </p>\n<blockquote>\n<p>canOpenURL(_:)这个方法在iOS9中有了限制，如果想使用这个方法必须首先把所有的地址添加到info.plist中，不能按照原来由服务器下发来检测APP安装了。  </p>\n</blockquote>\n</li>\n<li><p>冲突 由于URL scheme是每个APP开发商自己定义的，很有可能两个APP开发商定义相同，这时候如果使用openURL(_:)，iPhone将不会知道应该怎么处理。   </p>\n</li>\n<li>No fallback：如果 iOS 试图打开没有注册的 URL scheme，会静默失败，然后用户并不知道发生了什么。   </li>\n</ul>\n<p>iOS使用universal links来解决这些问题。使用universal links来代替URL scheme。universal links使用标准的HTTP和HTTPS链接。  </p>\n<h4 id=\"Universal-links\"><a href=\"#Universal-links\" class=\"headerlink\" title=\"Universal links\"></a>Universal links</h4><p>这里举了一个例子：你有一个域名clownapp.com，你可以注册<a href=\"http://clownapp.com作为你的universal\">http://clownapp.com作为你的universal</a> link。如果用户安装了你的clownapp。当他在Safari或者web view中点击链接<a href=\"http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。\">http://clownapp.com/clowns/fizbo的时候，将会直接进入到你的APP的fizbo的profile页面。如果你没有安装这个将会直接跳转到你的网站上的fizbo的profile页面。如果你使用openURL(\\_:)打开，也会与这个动作一样。</a>   </p>\n<blockquote>\n<p>PS: 这里我运行书中的例子，在模拟器的Safari中打不开。可能是我的原因   </p>\n</blockquote>\n<p>Universal links与deep links有如下的有点：  </p>\n<ul>\n<li>唯一 由于使用的是域名，能够保证唯一性</li>\n<li><p>安全 将你的app与你的域名绑定，上传一个安全签名到你的网站服务器。同样其他的APP也不会轻易的知道手机上是否安装了你的APP。  </p>\n<blockquote>\n<p>这里原文如下There’s also no way for other apps to tell whether your app is installed.这里不是没有方式，只是说没有原来那么容易。使用URL scheme白名单的方式还是能够检测。</p>\n</blockquote>\n</li>\n<li><p>简单 由于跳转到APP和服务器的链接统一了，所以不用考虑在APP和手机上需要使用两套不同的链接了。</p>\n</li>\n</ul>\n<h4 id=\"注册你的App，使其能够处理universal-links\"><a href=\"#注册你的App，使其能够处理universal-links\" class=\"headerlink\" title=\"注册你的App，使其能够处理universal links\"></a>注册你的App，使其能够处理universal links</h4><p>为了使App能够处理对应的链接，首先需要让App知道应该处理什么链接。这里使用的链接是rwdecon.com。按照下图添加对应的链接：<br><img src=\"/images/2015.12.27.08.png\" alt=\"\">  </p>\n<blockquote>\n<p>这里可能会出现选择账户，这时候就选择你对应的就好了，如果没有账户可以进入到Account添加。   </p>\n</blockquote>\n<h4 id=\"注册你的服务器能够处理unilateral-links\"><a href=\"#注册你的服务器能够处理unilateral-links\" class=\"headerlink\" title=\"注册你的服务器能够处理unilateral links\"></a>注册你的服务器能够处理unilateral links</h4><p>你需要在服务器的根目录下面，添加文件名为apple-app-site-association(没有后缀)的一个文件，然后在里面添加上如下的内容：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"applinks\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"apps\"</span>: [],</span><br><span class=\"line\">        <span class=\"string\">\"details\"</span>: [</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"string\">\"appID\"</span>: <span class=\"string\">\"KFCNEC27GU.com.razeware.RWDevCon\"</span>,</span><br><span class=\"line\">                <span class=\"string\">\"paths\"</span>: [</span><br><span class=\"line\">                    <span class=\"string\">\"/videos/\\*\"</span></span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中的appId是由team ID和bundle ID拼成的。Paths 数组包含了一个你的App应该处理的 URLs 白名单，这个 paths 数组还支持 基本的模式匹配，例如 *，？ 等，如 /videos/*/year/201?/videoName。   </p>\n<p>这个文件需要上传到服务器的根目录，并且能够通过HTTPS访问到，并且没有重定向。</p>\n<h4 id=\"在你的App上处理universal-links\"><a href=\"#在你的App上处理universal-links\" class=\"headerlink\" title=\"在你的App上处理universal links\"></a>在你的App上处理universal links</h4><blockquote>\n<p>这部分代码没有试验    </p>\n</blockquote>\n<p>上面已经添加对应的universal links，下面需要在App中处理对应的链接了。这里需要解析对应的链接，然后做一些相关的业务逻辑。在Session.swift添加下面的方法，这个方法主要是用来解析对应的url的：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">sessionByWebPath</span>(<span class=\"title\">path</span>: <span class=\"title\">String</span>,</span><br><span class=\"line\"><span class=\"title\">context</span>: <span class=\"title\">NSManagedObjectContext</span>) -&gt; <span class=\"title\">Session</span>? </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> fetch = <span class=\"type\">NSFetchRequest</span>(entityName: <span class=\"string\">\"Session\"</span>)</span><br><span class=\"line\">  fetch.predicate = <span class=\"type\">NSPredicate</span>(format: <span class=\"string\">\"webPath = %@\"</span>, [path])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> results = <span class=\"keyword\">try</span> context.executeFetchRequest(fetch)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> results.first <span class=\"keyword\">as</span>? <span class=\"type\">Session</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> fetchError <span class=\"keyword\">as</span> <span class=\"type\">NSError</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"fetch error: \\(fetchError.localizedDescription)\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>在AppDelegate.swift添加如下方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">AppDelegate</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 辅助方法</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentVideoViewController</span><span class=\"params\">(URL: NSURL)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> storyboard = <span class=\"type\">UIStoryboard</span>(name: <span class=\"string\">\"Main\"</span>, bundle: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> navID = <span class=\"string\">\"NavPlayerViewController\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> navVideoPlayerVC =</span><br><span class=\"line\">    storyboard.instantiateViewControllerWithIdentifier(navID)</span><br><span class=\"line\">      <span class=\"keyword\">as</span>! <span class=\"type\">UINavigationController</span></span><br><span class=\"line\"></span><br><span class=\"line\">    navVideoPlayerVC.modalPresentationStyle = .<span class=\"type\">FormSheet</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> videoPlayerVC = navVideoPlayerVC.topViewController</span><br><span class=\"line\">      <span class=\"keyword\">as</span>? <span class=\"type\">AVPlayerViewController</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        videoPlayerVC.player = <span class=\"type\">AVPlayer</span>(<span class=\"type\">URL</span>: <span class=\"type\">URL</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> rootViewController = window?.rootViewController</span><br><span class=\"line\">        rootViewController?.presentViewController(navVideoPlayerVC,</span><br><span class=\"line\">          animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication,</span><br><span class=\"line\">    continueUserActivity</span><br><span class=\"line\">    userActivity: NSUserActivity,</span><br><span class=\"line\">    restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//1 系统用 NSUserActivityTypeBrowsingWeb 表示对应的 universal HTTP links</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> userActivity.activityType ==</span><br><span class=\"line\">        <span class=\"type\">NSUserActivityTypeBrowsingWeb</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"keyword\">let</span> universalURL = userActivity.webpageURL!</span><br><span class=\"line\"></span><br><span class=\"line\">          <span class=\"comment\">//2 提取出 url 的不同部分</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> components = <span class=\"type\">NSURLComponents</span>(<span class=\"type\">URL</span>: universalURL,</span><br><span class=\"line\">            resolvingAgainstBaseURL: <span class=\"literal\">true</span>),</span><br><span class=\"line\">            <span class=\"keyword\">let</span> path = components.path &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">              <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> session = <span class=\"type\">Session</span>.sessionByWebPath(path,</span><br><span class=\"line\">                context: coreDataStack.context) &#123;</span><br><span class=\"line\">                  <span class=\"comment\">//3 找到 session，然后播放 video</span></span><br><span class=\"line\">                  <span class=\"keyword\">let</span> videoURL = <span class=\"type\">NSURL</span>(string: session.videoUrl)!</span><br><span class=\"line\">                  presentVideoViewController(videoURL)</span><br><span class=\"line\">                  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//4 无法理解就打开网站首页</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> app = <span class=\"type\">UIApplication</span>.sharedApplication()</span><br><span class=\"line\">                <span class=\"keyword\">let</span> url = <span class=\"type\">NSURL</span>(string: <span class=\"string\">\"http://www.rwdevcon.com\"</span>)!</span><br><span class=\"line\">                app.openURL(url)</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>下面有两个链接，可以给自己写一封邮件带上下面的两个链接，第一个是能够正常打开视频播放的，第二个直接打开网站首页。PS：我没有试验成功<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\">good link</span><br><span class=\"line\">http:<span class=\"comment\">//www.rwdevcon.com/videos/talk-tammy-coron-possible.html</span></span><br><span class=\"line\">bad link</span><br><span class=\"line\">http:<span class=\"comment\">//www.rwdevcon.com/videos/tim-cook-keynote.html</span></span><br></pre></td></tr></table></figure>   </p>\n<h3 id=\"使用web-markup\"><a href=\"#使用web-markup\" class=\"headerlink\" title=\"使用web markup\"></a>使用web markup</h3><p>Search 包含三种不同的 API：NSUserActivity，CoreSpotlight，web markup。前两种已经介绍过了，现在来看第三种。</p>\n<p>你可以使用 web markup 在搜索结果中得到你 app 应用里面的内容。如果你有一个网站，内容与 APP 的内容一致，你可以使用基本的 markup、Smart App Banners、native App能够处理universal links来修改你的网站，使其能够更好的被搜索、展示。   </p>\n<p>苹果有自己的爬虫，如果你的网站使用web markup，苹果的爬虫能够收集到对应的信息，然后保存到自己的服务器上，然后其他用户在搜索的时候能够搜索到对应的内容，不管用户是否安装了你的App，这样也能够帮助你获取一部分用户。   </p>\n<h4 id=\"使你的网站能够被发现\"><a href=\"#使你的网站能够被发现\" class=\"headerlink\" title=\"使你的网站能够被发现\"></a>使你的网站能够被发现</h4><p>苹果的爬虫会到处去爬数据，但是不一定能够很快的发现你的网站，这里有个方法能够帮助苹果爬虫发现你的网站。</p>\n<ol>\n<li>在iTunes Connect中，在设置<strong>Support URL</strong>的地方，设置<strong>Marketing URL</strong>，指向你已经使用markup的网站。<br><img src=\"/images/2015.12.27.09.png\" alt=\"\"></li>\n<li>保证你填写的URL能够被苹果的爬虫访问到。</li>\n<li>检查你Robots.txt文件，保证苹果的爬虫能够正常的爬取你的网站。PS:关于Robots.txt自行百度吧。</li>\n</ol>\n<h4 id=\"添加Smart-App-Banners\"><a href=\"#添加Smart-App-Banners\" class=\"headerlink\" title=\"添加Smart App Banners\"></a>添加Smart App Banners</h4><p>添加了Smart App Banners后，打开网站的时候会在顶部出现一个banner,对于已经安装App的用户，会显示一个OPEN按钮方便用户打开对应的App，对于未安装App的用户，将会出现一个view按钮，点击将会进入App store下载该App。效果图类似如下：<br><img src=\"/images/2015.12.27.10.png\" alt=\"\">   </p>\n<p>实现这个效果的方式，在你想要添加banner的网页上添加如下代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"apple-itunes-app\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"app-id=958625272, app- argument=http://www.rwdevcon.com/videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这里的name是App在store中的名字，下面的content包含两部分内容：</p>\n<ul>\n<li>app-id 在store上的app id</li>\n<li>app- argument 包含跳转回 App 的 URL，iOS 9 之前这个参数是自定义的 URL scheme deep link，现在 Apple 推荐使用 HTTP/HTTPS universal links<blockquote>\n<p>Smart App Banners 仅仅支持 Safari   </p>\n</blockquote>\n</li>\n</ul>\n<p>你能使用Applebot支持的开放的mobile links，比如：Twitter Cards和App Links，但是这两种标记我自己也没有试验，所以只是贴出来代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Twitter Cards  具体 https://dev.twitter.com/cards/mobile</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:name:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"RWDevCon\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:id:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"958625272\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:url:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">// App Links 具体http://applinks.org</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:name:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"RWDevCon\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:id:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"958625272\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">\"twitter:app:url:iphone\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/ videos/talk-ray-wenderlich-teamwork.html\"</span>&gt;</span></span><br></pre></td></tr></table></figure>    </p>\n<h4 id=\"Semantic-markup-using-Open-Graph\"><a href=\"#Semantic-markup-using-Open-Graph\" class=\"headerlink\" title=\"Semantic markup using Open Graph\"></a>Semantic markup using Open Graph</h4><p>苹果爬虫爬到你的内容并不保证会显示在 Spotlight 的搜索结果中，因为他还会和其他搜索结果内容进行竞争。   </p>\n<p>Apple 并没有公布具体的评级算法，只是确保你的内容会被考虑。而当用户明显地点击或搜索结果与你的内容高度相关，那么就会优先被 Apple 考虑。</p>\n<p>最后，Apple 建议为 markup 添加一些结构化的数据，来使其更好地以富文本的形式显示在 Spotlight 中。<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/assets/images/  </span><br><span class=\"line\">videos/talk-ray-wenderlich-teamwork.jpg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:secure_url\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"https://www.rwdevcon.com/  </span><br><span class=\"line\">assets/images/videos/talk-ray-wenderlich-teamwork.jpg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"image/jpeg\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:width\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"640\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:image:height\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"340\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"http://www.rwdevcon.com/videos/Ray-  </span><br><span class=\"line\">Wenderlich-Teamwork.mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:secure_url\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"https://www.rwdevcon.com/  </span><br><span class=\"line\">videos/Ray-Wenderlich-Teamwork.mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"video/mp4\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:width\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"1280\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:video:height\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"720\"</span> /&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">property</span>=<span class=\"string\">\"og:description\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"Learn how teamwork lets you  </span><br><span class=\"line\">dream bigger, through the story of an indie iPhone developer who almost  </span><br><span class=\"line\">missed out on the greatest opportunity of his life.\"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>上面的og后面的属性，我也没有找到出处，有谁清楚麻烦留言说明一下。谢谢</p>\n</blockquote>\n<p>关于web markup相关的详细的东西可以看苹果的文档<a href=\"https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html\">https://developer.apple.com/library/ios/documentation/General/Conceptual/AppSearch/WebContent.html</a></p>\n<p>最后说明一下：这篇文章由于一些资源问题，我没有做什么测试，可能有地方不对，如果哪里错误了，请指出来，谢谢。</p>\n<p>突然感觉这是最没底的一篇文章。</p>"},{"title":"iOS9-by-Tutorials-学习笔记七：UIStackView 进阶","date":"2016-01-21T15:40:43.000Z","_content":"\n继续接着上篇文章介绍UIStackView，这一篇将涉及到一些稍微深一点的知识点。\n\n### Getting started\n首先回顾一下我们计划完善SpotInfoViewController需要完成的任务情况：\n1. 底部按钮间距不相同。 完成。\n2. 点击Hide按钮，底部的内容应该填充空白位置。 未完成。\n3. 交换what to see和weather两部分的内容。 未完成。\n4. weather详情隐藏的时候，rating部分纵向显示。\n\n### Converting the sections   \n在完成上面的任务之前，你需要将SpotInfoViewController中的所有的sections转换为使用stack view。在下面的内容中能够学到一下配置stack view的属性，例如alignment、distribution和spacing。\n\n#### Rating section\n\n<!--- more --->   \nRating 部分是很容易修改的，只要把它们嵌入到一个stack view就可以了。  \n\n打开Main.storyboard,在Spot Info View Controller场景中选中RATING Lable和stars Label：\n![](/images/2016.01.21/01.png)\n\n选中后点击图片右下角指出来的Stack按钮。按照如图设置stack view的约束：\n![](/images/2016.01.21/02.png)    \n\n设置stack view的spacing属性为8，storyboard中显示如下，看起来是错误的，我们只需要修改属性distribution为其他值，然后再修改为Fill，就好了。\n![](/images/2016.01.21/03.png)  \n\n#### Unembedding a stack view   \n有时候我们想要取消一个Stack View，可以选中Stack View，按住Option键点击Stack按钮，在弹出的菜单中选择**Umembed**:\n![](/images/2016.01.21/04.png)  \n\n### Your first vertical stack view   \n现在你讲创建第一个纵向的stack view。选中WHY VISIT label和<whyVisitLabel> label,点击Stack按钮，Xcode会根据控件的位置创建stack view的正确方向。这两个label嵌入到stack view中后，与外部view的约束被自动去掉了，我们需要设置一下stack view的约束，点击Pin 按钮，弹出菜单设置四个方向的约束，这里的约束默认情况下都是与最近的元素之间的，我们可以通过点击下拉框选择约束的对应关系。\n![](/images/2016.01.21/05.png)   \n\n到目前为止，你已经得到了一个扩展到view右侧边缘的stack view，但是现在下面的label还是原来的宽度。你将要学习stack view的alignment属性，能够修复这个问题。   \n\n#### Alignment property  \nAlignment属性可以设置stack view元素的对齐方式，对于Axis未Vertical的stack view该属性值可选：Fill、Leading、Center、Trailling，对于Axis为Horizontal的stack view，该属性值可选：Fill、Top、Center、Bottom、FirstBaseline、LastBaseline。\n![](/images/2016.01.21/06.png)\n![](/images/2016.01.21/07.png)\n![](/images/2016.01.21/08.png)\n![](/images/2016.01.21/09.png)\n选中我们刚才创建的stack view设置Alignment、Distribution都为Fill。我们发现两个label都已经填充到stack view的宽度了。运行一下程序，发现运行良好。\n\n### Convert the \"what to see\" section\n下面转换what to see部分。\n1. 选中WHAT TO SEE label和 the <whatToSeeLabel> label。\n2. 点击Stack按钮\n3. 点击Pin按钮，选中Constrain to margins，设置四个约束：top：20， leading：0， Trailing：0， bottom： 20\n4. 设置stack view的Alignment属性为Fill\n运行一下程序，发现程序跟原来一样。现在只剩下weather部分了。   \n\n### Convert the weather section\n我们可以将weather部分嵌入到一个stack view，但是别忘了Hide按钮，它将会使我们的stack view变得更加复杂。\n\n#### One possible approach\n> 这种方案只是探讨，并不会在Xcode中实现。  \n\n你能够将WEATHER label和Hide按钮嵌入到一个横向的stack view中，然后在将新的stack view和<weatherInfoLabel>一起嵌入到一个纵向的stackview中。   \n\n#### Actual approach\n我们实际使用的方案是将Hide按钮不嵌入到weather部分的stack view中，设置其与WEATHER label的约束。这里将要添加stack view外部元素与stack view内部元素之间的约束。  \n\n##### Change the weather section – for real\n1. 选中WEATHER label和<weatherInfoLabel>\n2. 点击Stack按钮。点击Pin按钮，选中Constrain to margins，\n3. 设置四个约束：top：20， leading：0， Trailing：0， bottom： 20。\n4. 设置stack view的Alignment属性为Fill。设置完如下：\n![](/images/2016.01.21/10.png)   \n\n下面我们需要设置Hide按钮与WEATHER的约束。我们需要设置Hide按钮的左边缘与WEATHER右边缘建立约束。但是现在WEATHER充满了整个stack view。我们可以将WEATHER嵌入到一个纵向的stack view中，然后设置alignment属性为Leading。运行我们的程序，发现Hide按钮位置错误了，那是因为我们将WEATHER label嵌入到stack view之后，在Hide按钮上的所有约束都被移除了。我们需要重新为Hide添加约束：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints：\n>我自己做测试的时候，发现不把WEATHER嵌入到纵向的stack view中，直接添加约束也是可以的。\n\n![](/images/2016.01.21/11.png)   \n\n运行程序，Hide按钮的位置现在是正常的了。现在点击Hide按钮，内容被隐藏后，并且空白区域也被下面的内容填充了。现在所有的内容都在一个单独的stack view中，下面将会将其添加到一个统一的stack view中。\n\n### Top-level stack view\n1. 选中所有的外层的stack view，嵌入到一个stack view中\n![](/images/2016.01.21/12.png)   \n2. 点击Pin按钮，选中Constraints to margins，添加四个方向的约束为0\n3. 设置spacing为20，Alignment为Fill\nstoryboard显示如下：\n![](/images/2016.01.21/13.png)  \n运行程序发现Hide按钮又出问题了。需要重复上面的步骤：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints。  \n\n运行程序，运行结果变得正常了。\n\n### Repositioning views\n将what to see移动到weather上面。选中what to see嵌入的stack view，拖动到weather嵌入的stack view的上面。\n![](/images/2016.01.21/14.png)\n\nHide按钮的位置又错了，选中Hide按钮，点击Update Frames就能够解决了。运行程序，what to see已经移动到weather上面。\n\n### Arranged subviews\nUIStackView有一个属性叫做arrangedSubviews，该属性保存着UIStackView中包含的View，其中View的顺序就是View在UIStackView排列的顺序。UIStackView也是UIView的子类，也可以使用addSubview添加子View（例如设置background View），但是在storyboard添加的view都不是subview，都是arrangedSubviews中一个View。  \n\n我们可以使用addArrangedSubview(\\_:) or insertArrangedSubview(\\_:atIndex:)添加插入View。使用removeArrangedSubview(\\_:)从stack view中删除一个View，但是使用该方法删除的View并不会在视图树中真正的删除，需要调用view的removeFromSuperview()才会真正的删除。如果我们直接调用view的removeFromSuperview()，该view在stack view删除的同时还会在视图树中删除。\n\n### Animation\n现在点击Hide或者Show按钮的时候，weather详情部分的变化有些生硬，我们可以添加一些动画，让其变得更加好一点。\n\n#### Animating hidden  \nUIStackView同样适用于UIView的动画引擎。打开SpotInfoViewController.swift,修改对应方法如下：\n{% codeblock lang:swift %}\nfunc updateWeatherInfoViews(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool) {\n   let newButtonTitle = shouldHideWeatherInfo ? \"Show\" : \"Hide\"\n   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .Normal)\n\n   // TODO: Animate when animated == true\n   if animated {\n       UIView.animateWithDuration(0.3,\n           delay: 0.0,\n           usingSpringWithDamping: 0.6,\n           initialSpringVelocity: 10,\n           options: [],\n           animations: {\n               self.weatherInfoLabel.hidden = shouldHideWeatherInfo\n           }, completion: { finished in\n\n           }\n       )\n   } else {\n       weatherInfoLabel.hidden = shouldHideWeatherInfo\n   }\n }\n {% endcodeblock %}  \n\n运行程序，运行良好。\n\n#### Animating the axis\n下面修改一下rating 部分的动画，使其在不同情况下按照不同的方向显示。\n将storyboard的中的rating stack view与对应的类连线，创建IBOutlet属性@IBOutlet weak var ratingStackView: UIStackView!。修改对应方法如下（注释add是新添加的）\n {% codeblock lang:swift %}\n func updateWeatherInfoViews(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool) {\n   let newButtonTitle = shouldHideWeatherInfo ? \"Show\" : \"Hide\"\n   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .Normal)\n\n   // TODO: Animate when animated == true\n   if animated {\n       UIView.animateWithDuration(0.3,\n           delay: 0.0,\n           usingSpringWithDamping: 0.6,\n           initialSpringVelocity: 10,\n           options: [],\n           animations: {\n               self.weatherInfoLabel.hidden = shouldHideWeatherInfo\n           }, completion: { finished in // add\n               UIView.animateWithDuration(0.3) {\n                   self.ratingStackView.axis = shouldHideWeatherInfo ? .Vertical : .Horizontal\n               }\n           }\n       )\n   } else {\n       weatherInfoLabel.hidden = shouldHideWeatherInfo\n       // add\n       self.ratingStackView.axis = shouldHideWeatherInfo ? .Vertical : .Horizontal\n   }\n\n }\n {% endcodeblock %}  \n","source":"_posts/iOS9-by-Tutorials-学习笔记七：UIStackView-进阶.md","raw":"title: iOS9-by-Tutorials-学习笔记七：UIStackView 进阶\ndate: 2016-01-21 23:40:43\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n继续接着上篇文章介绍UIStackView，这一篇将涉及到一些稍微深一点的知识点。\n\n### Getting started\n首先回顾一下我们计划完善SpotInfoViewController需要完成的任务情况：\n1. 底部按钮间距不相同。 完成。\n2. 点击Hide按钮，底部的内容应该填充空白位置。 未完成。\n3. 交换what to see和weather两部分的内容。 未完成。\n4. weather详情隐藏的时候，rating部分纵向显示。\n\n### Converting the sections   \n在完成上面的任务之前，你需要将SpotInfoViewController中的所有的sections转换为使用stack view。在下面的内容中能够学到一下配置stack view的属性，例如alignment、distribution和spacing。\n\n#### Rating section\n\n<!--- more --->   \nRating 部分是很容易修改的，只要把它们嵌入到一个stack view就可以了。  \n\n打开Main.storyboard,在Spot Info View Controller场景中选中RATING Lable和stars Label：\n![](/images/2016.01.21/01.png)\n\n选中后点击图片右下角指出来的Stack按钮。按照如图设置stack view的约束：\n![](/images/2016.01.21/02.png)    \n\n设置stack view的spacing属性为8，storyboard中显示如下，看起来是错误的，我们只需要修改属性distribution为其他值，然后再修改为Fill，就好了。\n![](/images/2016.01.21/03.png)  \n\n#### Unembedding a stack view   \n有时候我们想要取消一个Stack View，可以选中Stack View，按住Option键点击Stack按钮，在弹出的菜单中选择**Umembed**:\n![](/images/2016.01.21/04.png)  \n\n### Your first vertical stack view   \n现在你讲创建第一个纵向的stack view。选中WHY VISIT label和<whyVisitLabel> label,点击Stack按钮，Xcode会根据控件的位置创建stack view的正确方向。这两个label嵌入到stack view中后，与外部view的约束被自动去掉了，我们需要设置一下stack view的约束，点击Pin 按钮，弹出菜单设置四个方向的约束，这里的约束默认情况下都是与最近的元素之间的，我们可以通过点击下拉框选择约束的对应关系。\n![](/images/2016.01.21/05.png)   \n\n到目前为止，你已经得到了一个扩展到view右侧边缘的stack view，但是现在下面的label还是原来的宽度。你将要学习stack view的alignment属性，能够修复这个问题。   \n\n#### Alignment property  \nAlignment属性可以设置stack view元素的对齐方式，对于Axis未Vertical的stack view该属性值可选：Fill、Leading、Center、Trailling，对于Axis为Horizontal的stack view，该属性值可选：Fill、Top、Center、Bottom、FirstBaseline、LastBaseline。\n![](/images/2016.01.21/06.png)\n![](/images/2016.01.21/07.png)\n![](/images/2016.01.21/08.png)\n![](/images/2016.01.21/09.png)\n选中我们刚才创建的stack view设置Alignment、Distribution都为Fill。我们发现两个label都已经填充到stack view的宽度了。运行一下程序，发现运行良好。\n\n### Convert the \"what to see\" section\n下面转换what to see部分。\n1. 选中WHAT TO SEE label和 the <whatToSeeLabel> label。\n2. 点击Stack按钮\n3. 点击Pin按钮，选中Constrain to margins，设置四个约束：top：20， leading：0， Trailing：0， bottom： 20\n4. 设置stack view的Alignment属性为Fill\n运行一下程序，发现程序跟原来一样。现在只剩下weather部分了。   \n\n### Convert the weather section\n我们可以将weather部分嵌入到一个stack view，但是别忘了Hide按钮，它将会使我们的stack view变得更加复杂。\n\n#### One possible approach\n> 这种方案只是探讨，并不会在Xcode中实现。  \n\n你能够将WEATHER label和Hide按钮嵌入到一个横向的stack view中，然后在将新的stack view和<weatherInfoLabel>一起嵌入到一个纵向的stackview中。   \n\n#### Actual approach\n我们实际使用的方案是将Hide按钮不嵌入到weather部分的stack view中，设置其与WEATHER label的约束。这里将要添加stack view外部元素与stack view内部元素之间的约束。  \n\n##### Change the weather section – for real\n1. 选中WEATHER label和<weatherInfoLabel>\n2. 点击Stack按钮。点击Pin按钮，选中Constrain to margins，\n3. 设置四个约束：top：20， leading：0， Trailing：0， bottom： 20。\n4. 设置stack view的Alignment属性为Fill。设置完如下：\n![](/images/2016.01.21/10.png)   \n\n下面我们需要设置Hide按钮与WEATHER的约束。我们需要设置Hide按钮的左边缘与WEATHER右边缘建立约束。但是现在WEATHER充满了整个stack view。我们可以将WEATHER嵌入到一个纵向的stack view中，然后设置alignment属性为Leading。运行我们的程序，发现Hide按钮位置错误了，那是因为我们将WEATHER label嵌入到stack view之后，在Hide按钮上的所有约束都被移除了。我们需要重新为Hide添加约束：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints：\n>我自己做测试的时候，发现不把WEATHER嵌入到纵向的stack view中，直接添加约束也是可以的。\n\n![](/images/2016.01.21/11.png)   \n\n运行程序，Hide按钮的位置现在是正常的了。现在点击Hide按钮，内容被隐藏后，并且空白区域也被下面的内容填充了。现在所有的内容都在一个单独的stack view中，下面将会将其添加到一个统一的stack view中。\n\n### Top-level stack view\n1. 选中所有的外层的stack view，嵌入到一个stack view中\n![](/images/2016.01.21/12.png)   \n2. 点击Pin按钮，选中Constraints to margins，添加四个方向的约束为0\n3. 设置spacing为20，Alignment为Fill\nstoryboard显示如下：\n![](/images/2016.01.21/13.png)  \n运行程序发现Hide按钮又出问题了。需要重复上面的步骤：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints。  \n\n运行程序，运行结果变得正常了。\n\n### Repositioning views\n将what to see移动到weather上面。选中what to see嵌入的stack view，拖动到weather嵌入的stack view的上面。\n![](/images/2016.01.21/14.png)\n\nHide按钮的位置又错了，选中Hide按钮，点击Update Frames就能够解决了。运行程序，what to see已经移动到weather上面。\n\n### Arranged subviews\nUIStackView有一个属性叫做arrangedSubviews，该属性保存着UIStackView中包含的View，其中View的顺序就是View在UIStackView排列的顺序。UIStackView也是UIView的子类，也可以使用addSubview添加子View（例如设置background View），但是在storyboard添加的view都不是subview，都是arrangedSubviews中一个View。  \n\n我们可以使用addArrangedSubview(\\_:) or insertArrangedSubview(\\_:atIndex:)添加插入View。使用removeArrangedSubview(\\_:)从stack view中删除一个View，但是使用该方法删除的View并不会在视图树中真正的删除，需要调用view的removeFromSuperview()才会真正的删除。如果我们直接调用view的removeFromSuperview()，该view在stack view删除的同时还会在视图树中删除。\n\n### Animation\n现在点击Hide或者Show按钮的时候，weather详情部分的变化有些生硬，我们可以添加一些动画，让其变得更加好一点。\n\n#### Animating hidden  \nUIStackView同样适用于UIView的动画引擎。打开SpotInfoViewController.swift,修改对应方法如下：\n{% codeblock lang:swift %}\nfunc updateWeatherInfoViews(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool) {\n   let newButtonTitle = shouldHideWeatherInfo ? \"Show\" : \"Hide\"\n   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .Normal)\n\n   // TODO: Animate when animated == true\n   if animated {\n       UIView.animateWithDuration(0.3,\n           delay: 0.0,\n           usingSpringWithDamping: 0.6,\n           initialSpringVelocity: 10,\n           options: [],\n           animations: {\n               self.weatherInfoLabel.hidden = shouldHideWeatherInfo\n           }, completion: { finished in\n\n           }\n       )\n   } else {\n       weatherInfoLabel.hidden = shouldHideWeatherInfo\n   }\n }\n {% endcodeblock %}  \n\n运行程序，运行良好。\n\n#### Animating the axis\n下面修改一下rating 部分的动画，使其在不同情况下按照不同的方向显示。\n将storyboard的中的rating stack view与对应的类连线，创建IBOutlet属性@IBOutlet weak var ratingStackView: UIStackView!。修改对应方法如下（注释add是新添加的）\n {% codeblock lang:swift %}\n func updateWeatherInfoViews(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool) {\n   let newButtonTitle = shouldHideWeatherInfo ? \"Show\" : \"Hide\"\n   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .Normal)\n\n   // TODO: Animate when animated == true\n   if animated {\n       UIView.animateWithDuration(0.3,\n           delay: 0.0,\n           usingSpringWithDamping: 0.6,\n           initialSpringVelocity: 10,\n           options: [],\n           animations: {\n               self.weatherInfoLabel.hidden = shouldHideWeatherInfo\n           }, completion: { finished in // add\n               UIView.animateWithDuration(0.3) {\n                   self.ratingStackView.axis = shouldHideWeatherInfo ? .Vertical : .Horizontal\n               }\n           }\n       )\n   } else {\n       weatherInfoLabel.hidden = shouldHideWeatherInfo\n       // add\n       self.ratingStackView.axis = shouldHideWeatherInfo ? .Vertical : .Horizontal\n   }\n\n }\n {% endcodeblock %}  \n","slug":"iOS9-by-Tutorials-学习笔记七：UIStackView-进阶","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0n000b3is6iliojajv","content":"<p>继续接着上篇文章介绍UIStackView，这一篇将涉及到一些稍微深一点的知识点。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>首先回顾一下我们计划完善SpotInfoViewController需要完成的任务情况：</p>\n<ol>\n<li>底部按钮间距不相同。 完成。</li>\n<li>点击Hide按钮，底部的内容应该填充空白位置。 未完成。</li>\n<li>交换what to see和weather两部分的内容。 未完成。</li>\n<li>weather详情隐藏的时候，rating部分纵向显示。</li>\n</ol>\n<h3 id=\"Converting-the-sections\"><a href=\"#Converting-the-sections\" class=\"headerlink\" title=\"Converting the sections\"></a>Converting the sections</h3><p>在完成上面的任务之前，你需要将SpotInfoViewController中的所有的sections转换为使用stack view。在下面的内容中能够学到一下配置stack view的属性，例如alignment、distribution和spacing。</p>\n<h4 id=\"Rating-section\"><a href=\"#Rating-section\" class=\"headerlink\" title=\"Rating section\"></a>Rating section</h4><a id=\"more\"></a>   \n<p>Rating 部分是很容易修改的，只要把它们嵌入到一个stack view就可以了。  </p>\n<p>打开Main.storyboard,在Spot Info View Controller场景中选中RATING Lable和stars Label：<br><img src=\"/images/2016.01.21/01.png\" alt=\"\"></p>\n<p>选中后点击图片右下角指出来的Stack按钮。按照如图设置stack view的约束：<br><img src=\"/images/2016.01.21/02.png\" alt=\"\">    </p>\n<p>设置stack view的spacing属性为8，storyboard中显示如下，看起来是错误的，我们只需要修改属性distribution为其他值，然后再修改为Fill，就好了。<br><img src=\"/images/2016.01.21/03.png\" alt=\"\">  </p>\n<h4 id=\"Unembedding-a-stack-view\"><a href=\"#Unembedding-a-stack-view\" class=\"headerlink\" title=\"Unembedding a stack view\"></a>Unembedding a stack view</h4><p>有时候我们想要取消一个Stack View，可以选中Stack View，按住Option键点击Stack按钮，在弹出的菜单中选择<strong>Umembed</strong>:<br><img src=\"/images/2016.01.21/04.png\" alt=\"\">  </p>\n<h3 id=\"Your-first-vertical-stack-view\"><a href=\"#Your-first-vertical-stack-view\" class=\"headerlink\" title=\"Your first vertical stack view\"></a>Your first vertical stack view</h3><p>现在你讲创建第一个纵向的stack view。选中WHY VISIT label和<whyvisitlabel> label,点击Stack按钮，Xcode会根据控件的位置创建stack view的正确方向。这两个label嵌入到stack view中后，与外部view的约束被自动去掉了，我们需要设置一下stack view的约束，点击Pin 按钮，弹出菜单设置四个方向的约束，这里的约束默认情况下都是与最近的元素之间的，我们可以通过点击下拉框选择约束的对应关系。<br><img src=\"/images/2016.01.21/05.png\" alt=\"\">   </whyvisitlabel></p>\n<p>到目前为止，你已经得到了一个扩展到view右侧边缘的stack view，但是现在下面的label还是原来的宽度。你将要学习stack view的alignment属性，能够修复这个问题。   </p>\n<h4 id=\"Alignment-property\"><a href=\"#Alignment-property\" class=\"headerlink\" title=\"Alignment property\"></a>Alignment property</h4><p>Alignment属性可以设置stack view元素的对齐方式，对于Axis未Vertical的stack view该属性值可选：Fill、Leading、Center、Trailling，对于Axis为Horizontal的stack view，该属性值可选：Fill、Top、Center、Bottom、FirstBaseline、LastBaseline。<br><img src=\"/images/2016.01.21/06.png\" alt=\"\"><br><img src=\"/images/2016.01.21/07.png\" alt=\"\"><br><img src=\"/images/2016.01.21/08.png\" alt=\"\"><br><img src=\"/images/2016.01.21/09.png\" alt=\"\"><br>选中我们刚才创建的stack view设置Alignment、Distribution都为Fill。我们发现两个label都已经填充到stack view的宽度了。运行一下程序，发现运行良好。</p>\n<h3 id=\"Convert-the-“what-to-see”-section\"><a href=\"#Convert-the-“what-to-see”-section\" class=\"headerlink\" title=\"Convert the “what to see” section\"></a>Convert the “what to see” section</h3><p>下面转换what to see部分。</p>\n<ol>\n<li>选中WHAT TO SEE label和 the <whattoseelabel> label。</whattoseelabel></li>\n<li>点击Stack按钮</li>\n<li>点击Pin按钮，选中Constrain to margins，设置四个约束：top：20， leading：0， Trailing：0， bottom： 20</li>\n<li>设置stack view的Alignment属性为Fill<br>运行一下程序，发现程序跟原来一样。现在只剩下weather部分了。   </li>\n</ol>\n<h3 id=\"Convert-the-weather-section\"><a href=\"#Convert-the-weather-section\" class=\"headerlink\" title=\"Convert the weather section\"></a>Convert the weather section</h3><p>我们可以将weather部分嵌入到一个stack view，但是别忘了Hide按钮，它将会使我们的stack view变得更加复杂。</p>\n<h4 id=\"One-possible-approach\"><a href=\"#One-possible-approach\" class=\"headerlink\" title=\"One possible approach\"></a>One possible approach</h4><blockquote>\n<p>这种方案只是探讨，并不会在Xcode中实现。  </p>\n</blockquote>\n<p>你能够将WEATHER label和Hide按钮嵌入到一个横向的stack view中，然后在将新的stack view和<weatherinfolabel>一起嵌入到一个纵向的stackview中。   </weatherinfolabel></p>\n<h4 id=\"Actual-approach\"><a href=\"#Actual-approach\" class=\"headerlink\" title=\"Actual approach\"></a>Actual approach</h4><p>我们实际使用的方案是将Hide按钮不嵌入到weather部分的stack view中，设置其与WEATHER label的约束。这里将要添加stack view外部元素与stack view内部元素之间的约束。  </p>\n<h5 id=\"Change-the-weather-section-–-for-real\"><a href=\"#Change-the-weather-section-–-for-real\" class=\"headerlink\" title=\"Change the weather section – for real\"></a>Change the weather section – for real</h5><ol>\n<li>选中WEATHER label和<weatherinfolabel></weatherinfolabel></li>\n<li>点击Stack按钮。点击Pin按钮，选中Constrain to margins，</li>\n<li>设置四个约束：top：20， leading：0， Trailing：0， bottom： 20。</li>\n<li>设置stack view的Alignment属性为Fill。设置完如下：<br><img src=\"/images/2016.01.21/10.png\" alt=\"\">   </li>\n</ol>\n<p>下面我们需要设置Hide按钮与WEATHER的约束。我们需要设置Hide按钮的左边缘与WEATHER右边缘建立约束。但是现在WEATHER充满了整个stack view。我们可以将WEATHER嵌入到一个纵向的stack view中，然后设置alignment属性为Leading。运行我们的程序，发现Hide按钮位置错误了，那是因为我们将WEATHER label嵌入到stack view之后，在Hide按钮上的所有约束都被移除了。我们需要重新为Hide添加约束：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints：</p>\n<blockquote>\n<p>我自己做测试的时候，发现不把WEATHER嵌入到纵向的stack view中，直接添加约束也是可以的。</p>\n</blockquote>\n<p><img src=\"/images/2016.01.21/11.png\" alt=\"\">   </p>\n<p>运行程序，Hide按钮的位置现在是正常的了。现在点击Hide按钮，内容被隐藏后，并且空白区域也被下面的内容填充了。现在所有的内容都在一个单独的stack view中，下面将会将其添加到一个统一的stack view中。</p>\n<h3 id=\"Top-level-stack-view\"><a href=\"#Top-level-stack-view\" class=\"headerlink\" title=\"Top-level stack view\"></a>Top-level stack view</h3><ol>\n<li>选中所有的外层的stack view，嵌入到一个stack view中<br><img src=\"/images/2016.01.21/12.png\" alt=\"\">   </li>\n<li>点击Pin按钮，选中Constraints to margins，添加四个方向的约束为0</li>\n<li>设置spacing为20，Alignment为Fill<br>storyboard显示如下：<br><img src=\"/images/2016.01.21/13.png\" alt=\"\"><br>运行程序发现Hide按钮又出问题了。需要重复上面的步骤：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints。  </li>\n</ol>\n<p>运行程序，运行结果变得正常了。</p>\n<h3 id=\"Repositioning-views\"><a href=\"#Repositioning-views\" class=\"headerlink\" title=\"Repositioning views\"></a>Repositioning views</h3><p>将what to see移动到weather上面。选中what to see嵌入的stack view，拖动到weather嵌入的stack view的上面。<br><img src=\"/images/2016.01.21/14.png\" alt=\"\"></p>\n<p>Hide按钮的位置又错了，选中Hide按钮，点击Update Frames就能够解决了。运行程序，what to see已经移动到weather上面。</p>\n<h3 id=\"Arranged-subviews\"><a href=\"#Arranged-subviews\" class=\"headerlink\" title=\"Arranged subviews\"></a>Arranged subviews</h3><p>UIStackView有一个属性叫做arrangedSubviews，该属性保存着UIStackView中包含的View，其中View的顺序就是View在UIStackView排列的顺序。UIStackView也是UIView的子类，也可以使用addSubview添加子View（例如设置background View），但是在storyboard添加的view都不是subview，都是arrangedSubviews中一个View。  </p>\n<p>我们可以使用addArrangedSubview(_:) or insertArrangedSubview(_:atIndex:)添加插入View。使用removeArrangedSubview(_:)从stack view中删除一个View，但是使用该方法删除的View并不会在视图树中真正的删除，需要调用view的removeFromSuperview()才会真正的删除。如果我们直接调用view的removeFromSuperview()，该view在stack view删除的同时还会在视图树中删除。</p>\n<h3 id=\"Animation\"><a href=\"#Animation\" class=\"headerlink\" title=\"Animation\"></a>Animation</h3><p>现在点击Hide或者Show按钮的时候，weather详情部分的变化有些生硬，我们可以添加一些动画，让其变得更加好一点。</p>\n<h4 id=\"Animating-hidden\"><a href=\"#Animating-hidden\" class=\"headerlink\" title=\"Animating hidden\"></a>Animating hidden</h4><p>UIStackView同样适用于UIView的动画引擎。打开SpotInfoViewController.swift,修改对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateWeatherInfoViews</span><span class=\"params\">(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newButtonTitle = shouldHideWeatherInfo ? <span class=\"string\">\"Show\"</span> : <span class=\"string\">\"Hide\"</span></span><br><span class=\"line\">   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .<span class=\"type\">Normal</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Animate when animated == true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> animated &#123;</span><br><span class=\"line\">       <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>,</span><br><span class=\"line\">           delay: <span class=\"number\">0.0</span>,</span><br><span class=\"line\">           usingSpringWithDamping: <span class=\"number\">0.6</span>,</span><br><span class=\"line\">           initialSpringVelocity: <span class=\"number\">10</span>,</span><br><span class=\"line\">           options: [],</span><br><span class=\"line\">           animations: &#123;</span><br><span class=\"line\">               <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">           &#125;, completion: &#123; finished <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       )</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>  </p>\n<p>运行程序，运行良好。</p>\n<h4 id=\"Animating-the-axis\"><a href=\"#Animating-the-axis\" class=\"headerlink\" title=\"Animating the axis\"></a>Animating the axis</h4><p>下面修改一下rating 部分的动画，使其在不同情况下按照不同的方向显示。<br>将storyboard的中的rating stack view与对应的类连线，创建IBOutlet属性@IBOutlet weak var ratingStackView: UIStackView!。修改对应方法如下（注释add是新添加的）<br> <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateWeatherInfoViews</span><span class=\"params\">(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newButtonTitle = shouldHideWeatherInfo ? <span class=\"string\">\"Show\"</span> : <span class=\"string\">\"Hide\"</span></span><br><span class=\"line\">  weatherHideOrShowButton.setTitle(newButtonTitle, forState: .<span class=\"type\">Normal</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Animate when animated == true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> animated &#123;</span><br><span class=\"line\">      <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>,</span><br><span class=\"line\">          delay: <span class=\"number\">0.0</span>,</span><br><span class=\"line\">          usingSpringWithDamping: <span class=\"number\">0.6</span>,</span><br><span class=\"line\">          initialSpringVelocity: <span class=\"number\">10</span>,</span><br><span class=\"line\">          options: [],</span><br><span class=\"line\">          animations: &#123;</span><br><span class=\"line\">              <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">          &#125;, completion: &#123; finished <span class=\"keyword\">in</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">              <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">self</span>.ratingStackView.axis = shouldHideWeatherInfo ? .<span class=\"type\">Vertical</span> : .<span class=\"type\">Horizontal</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">      <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"keyword\">self</span>.ratingStackView.axis = shouldHideWeatherInfo ? .<span class=\"type\">Vertical</span> : .<span class=\"type\">Horizontal</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n","excerpt":"<p>继续接着上篇文章介绍UIStackView，这一篇将涉及到一些稍微深一点的知识点。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>首先回顾一下我们计划完善SpotInfoViewController需要完成的任务情况：</p>\n<ol>\n<li>底部按钮间距不相同。 完成。</li>\n<li>点击Hide按钮，底部的内容应该填充空白位置。 未完成。</li>\n<li>交换what to see和weather两部分的内容。 未完成。</li>\n<li>weather详情隐藏的时候，rating部分纵向显示。</li>\n</ol>\n<h3 id=\"Converting-the-sections\"><a href=\"#Converting-the-sections\" class=\"headerlink\" title=\"Converting the sections\"></a>Converting the sections</h3><p>在完成上面的任务之前，你需要将SpotInfoViewController中的所有的sections转换为使用stack view。在下面的内容中能够学到一下配置stack view的属性，例如alignment、distribution和spacing。</p>\n<h4 id=\"Rating-section\"><a href=\"#Rating-section\" class=\"headerlink\" title=\"Rating section\"></a>Rating section</h4>","more":"<p>Rating 部分是很容易修改的，只要把它们嵌入到一个stack view就可以了。  </p>\n<p>打开Main.storyboard,在Spot Info View Controller场景中选中RATING Lable和stars Label：<br><img src=\"/images/2016.01.21/01.png\" alt=\"\"></p>\n<p>选中后点击图片右下角指出来的Stack按钮。按照如图设置stack view的约束：<br><img src=\"/images/2016.01.21/02.png\" alt=\"\">    </p>\n<p>设置stack view的spacing属性为8，storyboard中显示如下，看起来是错误的，我们只需要修改属性distribution为其他值，然后再修改为Fill，就好了。<br><img src=\"/images/2016.01.21/03.png\" alt=\"\">  </p>\n<h4 id=\"Unembedding-a-stack-view\"><a href=\"#Unembedding-a-stack-view\" class=\"headerlink\" title=\"Unembedding a stack view\"></a>Unembedding a stack view</h4><p>有时候我们想要取消一个Stack View，可以选中Stack View，按住Option键点击Stack按钮，在弹出的菜单中选择<strong>Umembed</strong>:<br><img src=\"/images/2016.01.21/04.png\" alt=\"\">  </p>\n<h3 id=\"Your-first-vertical-stack-view\"><a href=\"#Your-first-vertical-stack-view\" class=\"headerlink\" title=\"Your first vertical stack view\"></a>Your first vertical stack view</h3><p>现在你讲创建第一个纵向的stack view。选中WHY VISIT label和<whyVisitLabel> label,点击Stack按钮，Xcode会根据控件的位置创建stack view的正确方向。这两个label嵌入到stack view中后，与外部view的约束被自动去掉了，我们需要设置一下stack view的约束，点击Pin 按钮，弹出菜单设置四个方向的约束，这里的约束默认情况下都是与最近的元素之间的，我们可以通过点击下拉框选择约束的对应关系。<br><img src=\"/images/2016.01.21/05.png\" alt=\"\">   </p>\n<p>到目前为止，你已经得到了一个扩展到view右侧边缘的stack view，但是现在下面的label还是原来的宽度。你将要学习stack view的alignment属性，能够修复这个问题。   </p>\n<h4 id=\"Alignment-property\"><a href=\"#Alignment-property\" class=\"headerlink\" title=\"Alignment property\"></a>Alignment property</h4><p>Alignment属性可以设置stack view元素的对齐方式，对于Axis未Vertical的stack view该属性值可选：Fill、Leading、Center、Trailling，对于Axis为Horizontal的stack view，该属性值可选：Fill、Top、Center、Bottom、FirstBaseline、LastBaseline。<br><img src=\"/images/2016.01.21/06.png\" alt=\"\"><br><img src=\"/images/2016.01.21/07.png\" alt=\"\"><br><img src=\"/images/2016.01.21/08.png\" alt=\"\"><br><img src=\"/images/2016.01.21/09.png\" alt=\"\"><br>选中我们刚才创建的stack view设置Alignment、Distribution都为Fill。我们发现两个label都已经填充到stack view的宽度了。运行一下程序，发现运行良好。</p>\n<h3 id=\"Convert-the-“what-to-see”-section\"><a href=\"#Convert-the-“what-to-see”-section\" class=\"headerlink\" title=\"Convert the “what to see” section\"></a>Convert the “what to see” section</h3><p>下面转换what to see部分。</p>\n<ol>\n<li>选中WHAT TO SEE label和 the <whatToSeeLabel> label。</li>\n<li>点击Stack按钮</li>\n<li>点击Pin按钮，选中Constrain to margins，设置四个约束：top：20， leading：0， Trailing：0， bottom： 20</li>\n<li>设置stack view的Alignment属性为Fill<br>运行一下程序，发现程序跟原来一样。现在只剩下weather部分了。   </li>\n</ol>\n<h3 id=\"Convert-the-weather-section\"><a href=\"#Convert-the-weather-section\" class=\"headerlink\" title=\"Convert the weather section\"></a>Convert the weather section</h3><p>我们可以将weather部分嵌入到一个stack view，但是别忘了Hide按钮，它将会使我们的stack view变得更加复杂。</p>\n<h4 id=\"One-possible-approach\"><a href=\"#One-possible-approach\" class=\"headerlink\" title=\"One possible approach\"></a>One possible approach</h4><blockquote>\n<p>这种方案只是探讨，并不会在Xcode中实现。  </p>\n</blockquote>\n<p>你能够将WEATHER label和Hide按钮嵌入到一个横向的stack view中，然后在将新的stack view和<weatherInfoLabel>一起嵌入到一个纵向的stackview中。   </p>\n<h4 id=\"Actual-approach\"><a href=\"#Actual-approach\" class=\"headerlink\" title=\"Actual approach\"></a>Actual approach</h4><p>我们实际使用的方案是将Hide按钮不嵌入到weather部分的stack view中，设置其与WEATHER label的约束。这里将要添加stack view外部元素与stack view内部元素之间的约束。  </p>\n<h5 id=\"Change-the-weather-section-–-for-real\"><a href=\"#Change-the-weather-section-–-for-real\" class=\"headerlink\" title=\"Change the weather section – for real\"></a>Change the weather section – for real</h5><ol>\n<li>选中WEATHER label和<weatherInfoLabel></li>\n<li>点击Stack按钮。点击Pin按钮，选中Constrain to margins，</li>\n<li>设置四个约束：top：20， leading：0， Trailing：0， bottom： 20。</li>\n<li>设置stack view的Alignment属性为Fill。设置完如下：<br><img src=\"/images/2016.01.21/10.png\" alt=\"\">   </li>\n</ol>\n<p>下面我们需要设置Hide按钮与WEATHER的约束。我们需要设置Hide按钮的左边缘与WEATHER右边缘建立约束。但是现在WEATHER充满了整个stack view。我们可以将WEATHER嵌入到一个纵向的stack view中，然后设置alignment属性为Leading。运行我们的程序，发现Hide按钮位置错误了，那是因为我们将WEATHER label嵌入到stack view之后，在Hide按钮上的所有约束都被移除了。我们需要重新为Hide添加约束：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints：</p>\n<blockquote>\n<p>我自己做测试的时候，发现不把WEATHER嵌入到纵向的stack view中，直接添加约束也是可以的。</p>\n</blockquote>\n<p><img src=\"/images/2016.01.21/11.png\" alt=\"\">   </p>\n<p>运行程序，Hide按钮的位置现在是正常的了。现在点击Hide按钮，内容被隐藏后，并且空白区域也被下面的内容填充了。现在所有的内容都在一个单独的stack view中，下面将会将其添加到一个统一的stack view中。</p>\n<h3 id=\"Top-level-stack-view\"><a href=\"#Top-level-stack-view\" class=\"headerlink\" title=\"Top-level stack view\"></a>Top-level stack view</h3><ol>\n<li>选中所有的外层的stack view，嵌入到一个stack view中<br><img src=\"/images/2016.01.21/12.png\" alt=\"\">   </li>\n<li>点击Pin按钮，选中Constraints to margins，添加四个方向的约束为0</li>\n<li>设置spacing为20，Alignment为Fill<br>storyboard显示如下：<br><img src=\"/images/2016.01.21/13.png\" alt=\"\"><br>运行程序发现Hide按钮又出问题了。需要重复上面的步骤：从Hide按钮按住Control连线到WEATHER label，在弹出菜单中按住Shift，选中Horizontal Space和Baseline，然后点击Add Constraints。  </li>\n</ol>\n<p>运行程序，运行结果变得正常了。</p>\n<h3 id=\"Repositioning-views\"><a href=\"#Repositioning-views\" class=\"headerlink\" title=\"Repositioning views\"></a>Repositioning views</h3><p>将what to see移动到weather上面。选中what to see嵌入的stack view，拖动到weather嵌入的stack view的上面。<br><img src=\"/images/2016.01.21/14.png\" alt=\"\"></p>\n<p>Hide按钮的位置又错了，选中Hide按钮，点击Update Frames就能够解决了。运行程序，what to see已经移动到weather上面。</p>\n<h3 id=\"Arranged-subviews\"><a href=\"#Arranged-subviews\" class=\"headerlink\" title=\"Arranged subviews\"></a>Arranged subviews</h3><p>UIStackView有一个属性叫做arrangedSubviews，该属性保存着UIStackView中包含的View，其中View的顺序就是View在UIStackView排列的顺序。UIStackView也是UIView的子类，也可以使用addSubview添加子View（例如设置background View），但是在storyboard添加的view都不是subview，都是arrangedSubviews中一个View。  </p>\n<p>我们可以使用addArrangedSubview(_:) or insertArrangedSubview(_:atIndex:)添加插入View。使用removeArrangedSubview(_:)从stack view中删除一个View，但是使用该方法删除的View并不会在视图树中真正的删除，需要调用view的removeFromSuperview()才会真正的删除。如果我们直接调用view的removeFromSuperview()，该view在stack view删除的同时还会在视图树中删除。</p>\n<h3 id=\"Animation\"><a href=\"#Animation\" class=\"headerlink\" title=\"Animation\"></a>Animation</h3><p>现在点击Hide或者Show按钮的时候，weather详情部分的变化有些生硬，我们可以添加一些动画，让其变得更加好一点。</p>\n<h4 id=\"Animating-hidden\"><a href=\"#Animating-hidden\" class=\"headerlink\" title=\"Animating hidden\"></a>Animating hidden</h4><p>UIStackView同样适用于UIView的动画引擎。打开SpotInfoViewController.swift,修改对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateWeatherInfoViews</span><span class=\"params\">(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">let</span> newButtonTitle = shouldHideWeatherInfo ? <span class=\"string\">\"Show\"</span> : <span class=\"string\">\"Hide\"</span></span><br><span class=\"line\">   weatherHideOrShowButton.setTitle(newButtonTitle, forState: .<span class=\"type\">Normal</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Animate when animated == true</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> animated &#123;</span><br><span class=\"line\">       <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>,</span><br><span class=\"line\">           delay: <span class=\"number\">0.0</span>,</span><br><span class=\"line\">           usingSpringWithDamping: <span class=\"number\">0.6</span>,</span><br><span class=\"line\">           initialSpringVelocity: <span class=\"number\">10</span>,</span><br><span class=\"line\">           options: [],</span><br><span class=\"line\">           animations: &#123;</span><br><span class=\"line\">               <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">           &#125;, completion: &#123; finished <span class=\"keyword\">in</span></span><br><span class=\"line\"></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       )</span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>  </p>\n<p>运行程序，运行良好。</p>\n<h4 id=\"Animating-the-axis\"><a href=\"#Animating-the-axis\" class=\"headerlink\" title=\"Animating the axis\"></a>Animating the axis</h4><p>下面修改一下rating 部分的动画，使其在不同情况下按照不同的方向显示。<br>将storyboard的中的rating stack view与对应的类连线，创建IBOutlet属性@IBOutlet weak var ratingStackView: UIStackView!。修改对应方法如下（注释add是新添加的）<br> <figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateWeatherInfoViews</span><span class=\"params\">(hideWeatherInfo shouldHideWeatherInfo: Bool, animated: Bool)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newButtonTitle = shouldHideWeatherInfo ? <span class=\"string\">\"Show\"</span> : <span class=\"string\">\"Hide\"</span></span><br><span class=\"line\">  weatherHideOrShowButton.setTitle(newButtonTitle, forState: .<span class=\"type\">Normal</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Animate when animated == true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> animated &#123;</span><br><span class=\"line\">      <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>,</span><br><span class=\"line\">          delay: <span class=\"number\">0.0</span>,</span><br><span class=\"line\">          usingSpringWithDamping: <span class=\"number\">0.6</span>,</span><br><span class=\"line\">          initialSpringVelocity: <span class=\"number\">10</span>,</span><br><span class=\"line\">          options: [],</span><br><span class=\"line\">          animations: &#123;</span><br><span class=\"line\">              <span class=\"keyword\">self</span>.weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">          &#125;, completion: &#123; finished <span class=\"keyword\">in</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">              <span class=\"type\">UIView</span>.animateWithDuration(<span class=\"number\">0.3</span>) &#123;</span><br><span class=\"line\">                  <span class=\"keyword\">self</span>.ratingStackView.axis = shouldHideWeatherInfo ? .<span class=\"type\">Vertical</span> : .<span class=\"type\">Horizontal</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      weatherInfoLabel.hidden = shouldHideWeatherInfo</span><br><span class=\"line\">      <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"keyword\">self</span>.ratingStackView.axis = shouldHideWeatherInfo ? .<span class=\"type\">Vertical</span> : .<span class=\"type\">Horizontal</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>"},{"title":"iOS9-by-Tutorials-学习笔记九：3D Touch","date":"2016-02-23T14:40:27.000Z","_content":"\n很久没有更新文章了，自己也感觉自己懒得要发霉了。为了让自己不至于发霉，今天开始继续更新文章。   \n\n本篇文章介绍一下3D Touch。3D Touch 是iPhone 6s推出的一项新的技术，利用该技术能够更快的预览内容，更加平滑的进行多任务等。Apple提供一下与3D Touch 相关的API：   \n* UITouch有一个 **force** 属性用来检测用户按下的程度。\n* UIViewController提供了一个新的API，允许你展示新的view Controller的预览，这个预览成为 **peek**。此时继续用力，将会 **pop** 该预览，进入对应的View Controller 界面。\n* UIApplicationShortcutItem 是一个新的类，你能使用它给home屏幕上的icon添加快捷操作。\n\n### Getting Started\n在这篇文章中将会使用一个叫做 **Doodles(涂鸦)** App, 这个APP 比较简单，就两个界面：列表+详情，截图如下：\n![](/images/2016.02.23/01.png)  \n\n<!--- more --->  \n\n代码结构如下：\n![](/images/2016.02.23/02.png)   \n\n### UITouch force\niOS9后，UITouch 添加了一个force属性，这个属性表示的按压屏幕的力量，取值范围为0~maximumPossibleForce(touch.maximumPossibleForce,这个值不是1)。我们可以利用force属性去改造我们的APP，让线条的粗细随着按压屏幕力量的变化而变化。\n修改Canvas.swift中方法如下（下面标记update的为修改的）：\n{% codeblock lang:swift %}\nprivate func addLineFromPoint(from: CGPoint, toPoint: CGPoint, withForce force: CGFloat = 1) { // update\n    UIGraphicsBeginImageContextWithOptions(bounds.size, false, 0.0)\n    print(\"force:\\(force)\")\n    drawing?.drawInRect(bounds)\n\n    let cxt = UIGraphicsGetCurrentContext()\n    CGContextMoveToPoint(cxt, from.x, from.y)\n    CGContextAddLineToPoint(cxt, toPoint.x, toPoint.y)\n\n    CGContextSetLineCap(cxt, .Round)\n\n    CGContextSetLineWidth(cxt, strokeWidth * force) // update\n\n    strokeColor.setStroke()\n\n    CGContextStrokePath(cxt)\n\n    drawing = UIGraphicsGetImageFromCurrentImageContext()\n\n    layer.contents = drawing?.CGImage\n\n    UIGraphicsEndImageContext()\n  }\n{% endcodeblock %}  \n\n继续修改如下方法：\n{% codeblock lang:swift %}\npublic override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    if let touch = touches.first {\n        // 先去验证是否支持3D Touch\n        if traitCollection.forceTouchCapability == .Available {\n            addLineFromPoint(touch.previousLocationInView(self), toPoint: touch.locationInView(self), withForce: touch.force)\n        } else {\n            addLineFromPoint(touch.previousLocationInView(self), toPoint: touch.locationInView(self))\n        }\n    }\n  }\n{% endcodeblock %}  \n\n修改完后运行一下，用不同压力绘画，效果如下：\n![](/images/2016.02.23/03.png)  \n\n### Peeking and popping\n对于 **Peek** 和 **Pop** 等写完下面的例子自然就明白了。  \n\n修改DoodlesViewController.swift对应方法如下：\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  // update\n  if traitCollection.forceTouchCapability == .Available {\n      // 添加对于3D Touch的代理\n      registerForPreviewingWithDelegate(self, sourceView: view)\n  }\n}\n\n…………\n\n// 扩展该类实现对应的协议 有两个方法用于处理peek pop\n//MARK: - 3D Touch\nextension DoodlesViewController: UIViewControllerPreviewingDelegate {\n    // peek 回调 返回一个包含对应内容的UIViewController\n    func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController? {\n        guard let indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) as? DoodleCell else { // 获取点击的cell\n            return nil\n        }\n        let identifier = \"DoodleDetailViewController\"\n        guard let detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) as? DoodleDetailViewController else { // 创建对应的View Controller\n            return nil\n        }\n        detailVC.doodle = cell.doodle // 设置数据\n\n        // 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊\n        previewingContext.sourceRect = cell.frame //CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame\n        return detailVC\n    }\n\n    // pop commitViewController是上面方法返回的\n    func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {\n        // peek之后继续用力 将会调用该方法 进入对应的view Controller\n        showViewController(viewControllerToCommit, sender: self)\n    }\n}\n{% endcodeblock %}   \n\n运行效果如下：\n![](/images/2016.02.23/04.png)  \n\n#### Preview actions\n在 **Peek** 状态下，我们可以添加一些快捷操作，通过上划就能显示出来这些快捷操作。这些快捷操作是需要添加到 **Peek** 显示的View Controller中的。\n在DoodleDetailViewController.swift 末尾添加如下代码：\n{% codeblock lang:swift %}\nweak var doodlesViewController:  DoodlesViewController?\noverride func previewActionItems() -> [UIPreviewActionItem] {\n    // UIPreviewAction 专门为3D Touch使用\n    let shareAction = UIPreviewAction(title: \"分享\", style: .Default) { (previewAction, viewController) -> Void in\n        if let doodlesVC = self.doodlesViewController, activityViewController = self.activityViewController {\n            doodlesVC.presentViewController(activityViewController, animated: true, completion: nil)\n        }\n    }\n\n    let deleteAction = UIPreviewAction(title: \"删除\", style: .Default) { (previewAction, viewController) -> Void in\n        guard let doodle = self.doodle else {\n            return\n        }\n        Doodle.deleteDoodle(doodle)\n        if let doodlesViewController = self.doodlesViewController {\n            doodlesViewController.tableView.reloadData()\n        }\n    }\n    return [shareAction, deleteAction]\n}\n{% endcodeblock %}\n上面的代码添加了两个快捷键，一个是分享一个是删除。\n\n在DoodlesViewController.swift中也需要修改一下代码：\n{% codeblock lang:swift %}\n// 注释new add 是新添加的\nfunc previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController? {\n    guard let indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) as? DoodleCell else { // 获取点击的cell\n        return nil\n    }\n    let identifier = \"DoodleDetailViewController\"\n    guard let detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) as? DoodleDetailViewController else { // 创建对应的View Controller\n        return nil\n    }\n    detailVC.doodle = cell.doodle // 设置数据\n\n    detailVC.doodlesViewController = self // new add\n\n    // 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊\n    previewingContext.sourceRect = cell.frame //CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame\n    return detailVC\n}\n{% endcodeblock %}    \n\n运行程序，在 **Peek** 状态上划效果如下：\n![](/images/2016.02.23/05.png)   \n\n### Home screen quick actions  \n3D Touch 另一个作用就是能够在Home界面的图标上，通过按压在图标的周围显示一个快捷操作（shortcuts）的菜单，通过这个菜单，我们能够更加快速直接的进入某项功能。现在主流的App都已经支持这项功能，可以在图标上按按试试。   \n\n这种快捷操作（shortcuts）分两种：\n* **Static shortcuts** 静态的，在Info.plist里面配置，在程序安装后就会存在。\n* **Dynamic shortcuts** 动态的，在运行时创建的，直到程序第一次运行后才会存在。\n\n#### Adding a static shortcut  \n添加一个静态的shortcut，首先需要在Info.plist里面配置，按照下图进行相应的配置：\n![](/images/2016.02.23/06.png)\n\n配置好了之后运行程序，在Home页面App Icon上按压能够看到我们配置的shortcut，点击后发现应用启动，但是不是我们想要的结果。我们需要在Appdelegate.swift中添加如下的代码：\n{% codeblock lang:swift %}   \n// 响应shortcut的点击\nfunc application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -> Void) {\n    handleShortcutItem(shortcutItem)\n\n    // 如果你自己处理了shortcut 这里参数为true 否则为false\n    completionHandler(true)\n}\n\nfunc handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {\n    print(shortcutItem.userInfo)\n    switch shortcutItem.type {\n    case \"com.razeware.Doodles.new\":\n        presentNewDoodleViewController()\n    default:\n        break\n    }\n}\n\nfunc presentNewDoodleViewController() {\n    let identifier = \"NewDoodleNavigationController\"\n    let doodleViewController = UIStoryboard.mainStoryboard .instantiateViewControllerWithIdentifier(identifier)\n\n    window?.rootViewController? .presentViewController(doodleViewController, animated: true, completion: nil)\n}\n{% endcodeblock %}  \n\n运行程序，点击shortcut会进入新建View Controller。   \n\n#### Adding a dynamic shortcut\n当然我们也能动态的通过程序添加shortcut，这个有一个限制就是程序必须运行一次才会生效。   \n修改Doodle.swift对应的方法如下（注释add地方为新加的）：\n{% codeblock lang:swift %}\nstatic func addDoodle(doodle: Doodle) {\n  allDoodles.append(doodle)\n  Doodle.configureDynamicShortcuts() // add\n}\n\nstatic func deleteDoodle(doodle: Doodle) {\n  if let index = allDoodles.indexOf({ $0.name == doodle.name }) {\n    allDoodles.removeAtIndex(index)\n      Doodle.configureDynamicShortcuts() // add\n  }\n}\n\n// 这个方法添加\nstatic func configureDynamicShortcuts() {\n    if let mostRecentDoodle = Doodle.sortedDoodles.first {\n        let shortcutType = \"com.razeware.Doodles.share\"\n        let shortcutItem = UIApplicationShortcutItem(type: shortcutType, localizedTitle: \"Share latest Doodle\", localizedSubtitle: mostRecentDoodle.name, icon: UIApplicationShortcutIcon(type: .Share), userInfo: nil)\n        UIApplication.sharedApplication().shortcutItems = [shortcutItem]\n    } else {\n        UIApplication.sharedApplication().shortcutItems = []\n    }\n}\n{% endcodeblock %}   \n\n修改AppDelegate.swift对应的方法：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n  configureAppAppearance()\n  Doodle.configureDynamicShortcuts() // add\n  return true\n}\n\n…………\n\nfunc handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {\n    print(shortcutItem.userInfo)\n    switch shortcutItem.type {\n    case \"com.razeware.Doodles.new\":\n        presentNewDoodleViewController()\n    case \"com.razeware.Doodles.share\": // 处理share\n        shareMostRecentDoodle()\n    default:\n        break\n    }\n}\n\nfunc shareMostRecentDoodle() {\n    guard let mostRecentDoodle = Doodle.sortedDoodles.first, navigationController = window?.rootViewController as? UINavigationController else {\n        return\n    }\n\n    let identifier = \"DoodleDetailViewController\"\n    let doodleViewController = UIStoryboard.mainStoryboard.instantiateViewControllerWithIdentifier(identifier) as! DoodleDetailViewController\n\n    doodleViewController.doodle = mostRecentDoodle\n    doodleViewController.shareDoodle = true\n    navigationController.pushViewController(doodleViewController, animated: true)\n}\n\n{% endcodeblock %}   \n运行程序，然后退出到Home界面，按压图标，点击share，能够进入程序对应的详情页面，调用起来分享。\n![](/images/2016.02.23/07.png)  \n\n3D Touch相关的内容到这里就已经更新完了，初步计划以后录制视频关于动画相关的，希望有兴趣的朋友关注一下。\n","source":"_posts/iOS9-by-Tutorials-学习笔记九：3D-Touch.md","raw":"title: iOS9-by-Tutorials-学习笔记九：3D Touch\ndate: 2016-02-23 22:40:27\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n很久没有更新文章了，自己也感觉自己懒得要发霉了。为了让自己不至于发霉，今天开始继续更新文章。   \n\n本篇文章介绍一下3D Touch。3D Touch 是iPhone 6s推出的一项新的技术，利用该技术能够更快的预览内容，更加平滑的进行多任务等。Apple提供一下与3D Touch 相关的API：   \n* UITouch有一个 **force** 属性用来检测用户按下的程度。\n* UIViewController提供了一个新的API，允许你展示新的view Controller的预览，这个预览成为 **peek**。此时继续用力，将会 **pop** 该预览，进入对应的View Controller 界面。\n* UIApplicationShortcutItem 是一个新的类，你能使用它给home屏幕上的icon添加快捷操作。\n\n### Getting Started\n在这篇文章中将会使用一个叫做 **Doodles(涂鸦)** App, 这个APP 比较简单，就两个界面：列表+详情，截图如下：\n![](/images/2016.02.23/01.png)  \n\n<!--- more --->  \n\n代码结构如下：\n![](/images/2016.02.23/02.png)   \n\n### UITouch force\niOS9后，UITouch 添加了一个force属性，这个属性表示的按压屏幕的力量，取值范围为0~maximumPossibleForce(touch.maximumPossibleForce,这个值不是1)。我们可以利用force属性去改造我们的APP，让线条的粗细随着按压屏幕力量的变化而变化。\n修改Canvas.swift中方法如下（下面标记update的为修改的）：\n{% codeblock lang:swift %}\nprivate func addLineFromPoint(from: CGPoint, toPoint: CGPoint, withForce force: CGFloat = 1) { // update\n    UIGraphicsBeginImageContextWithOptions(bounds.size, false, 0.0)\n    print(\"force:\\(force)\")\n    drawing?.drawInRect(bounds)\n\n    let cxt = UIGraphicsGetCurrentContext()\n    CGContextMoveToPoint(cxt, from.x, from.y)\n    CGContextAddLineToPoint(cxt, toPoint.x, toPoint.y)\n\n    CGContextSetLineCap(cxt, .Round)\n\n    CGContextSetLineWidth(cxt, strokeWidth * force) // update\n\n    strokeColor.setStroke()\n\n    CGContextStrokePath(cxt)\n\n    drawing = UIGraphicsGetImageFromCurrentImageContext()\n\n    layer.contents = drawing?.CGImage\n\n    UIGraphicsEndImageContext()\n  }\n{% endcodeblock %}  \n\n继续修改如下方法：\n{% codeblock lang:swift %}\npublic override func touchesMoved(touches: Set<UITouch>, withEvent event: UIEvent?) {\n    if let touch = touches.first {\n        // 先去验证是否支持3D Touch\n        if traitCollection.forceTouchCapability == .Available {\n            addLineFromPoint(touch.previousLocationInView(self), toPoint: touch.locationInView(self), withForce: touch.force)\n        } else {\n            addLineFromPoint(touch.previousLocationInView(self), toPoint: touch.locationInView(self))\n        }\n    }\n  }\n{% endcodeblock %}  \n\n修改完后运行一下，用不同压力绘画，效果如下：\n![](/images/2016.02.23/03.png)  \n\n### Peeking and popping\n对于 **Peek** 和 **Pop** 等写完下面的例子自然就明白了。  \n\n修改DoodlesViewController.swift对应方法如下：\n{% codeblock lang:swift %}\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  // update\n  if traitCollection.forceTouchCapability == .Available {\n      // 添加对于3D Touch的代理\n      registerForPreviewingWithDelegate(self, sourceView: view)\n  }\n}\n\n…………\n\n// 扩展该类实现对应的协议 有两个方法用于处理peek pop\n//MARK: - 3D Touch\nextension DoodlesViewController: UIViewControllerPreviewingDelegate {\n    // peek 回调 返回一个包含对应内容的UIViewController\n    func previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController? {\n        guard let indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) as? DoodleCell else { // 获取点击的cell\n            return nil\n        }\n        let identifier = \"DoodleDetailViewController\"\n        guard let detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) as? DoodleDetailViewController else { // 创建对应的View Controller\n            return nil\n        }\n        detailVC.doodle = cell.doodle // 设置数据\n\n        // 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊\n        previewingContext.sourceRect = cell.frame //CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame\n        return detailVC\n    }\n\n    // pop commitViewController是上面方法返回的\n    func previewingContext(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController) {\n        // peek之后继续用力 将会调用该方法 进入对应的view Controller\n        showViewController(viewControllerToCommit, sender: self)\n    }\n}\n{% endcodeblock %}   \n\n运行效果如下：\n![](/images/2016.02.23/04.png)  \n\n#### Preview actions\n在 **Peek** 状态下，我们可以添加一些快捷操作，通过上划就能显示出来这些快捷操作。这些快捷操作是需要添加到 **Peek** 显示的View Controller中的。\n在DoodleDetailViewController.swift 末尾添加如下代码：\n{% codeblock lang:swift %}\nweak var doodlesViewController:  DoodlesViewController?\noverride func previewActionItems() -> [UIPreviewActionItem] {\n    // UIPreviewAction 专门为3D Touch使用\n    let shareAction = UIPreviewAction(title: \"分享\", style: .Default) { (previewAction, viewController) -> Void in\n        if let doodlesVC = self.doodlesViewController, activityViewController = self.activityViewController {\n            doodlesVC.presentViewController(activityViewController, animated: true, completion: nil)\n        }\n    }\n\n    let deleteAction = UIPreviewAction(title: \"删除\", style: .Default) { (previewAction, viewController) -> Void in\n        guard let doodle = self.doodle else {\n            return\n        }\n        Doodle.deleteDoodle(doodle)\n        if let doodlesViewController = self.doodlesViewController {\n            doodlesViewController.tableView.reloadData()\n        }\n    }\n    return [shareAction, deleteAction]\n}\n{% endcodeblock %}\n上面的代码添加了两个快捷键，一个是分享一个是删除。\n\n在DoodlesViewController.swift中也需要修改一下代码：\n{% codeblock lang:swift %}\n// 注释new add 是新添加的\nfunc previewingContext(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -> UIViewController? {\n    guard let indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) as? DoodleCell else { // 获取点击的cell\n        return nil\n    }\n    let identifier = \"DoodleDetailViewController\"\n    guard let detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) as? DoodleDetailViewController else { // 创建对应的View Controller\n        return nil\n    }\n    detailVC.doodle = cell.doodle // 设置数据\n\n    detailVC.doodlesViewController = self // new add\n\n    // 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊\n    previewingContext.sourceRect = cell.frame //CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame\n    return detailVC\n}\n{% endcodeblock %}    \n\n运行程序，在 **Peek** 状态上划效果如下：\n![](/images/2016.02.23/05.png)   \n\n### Home screen quick actions  \n3D Touch 另一个作用就是能够在Home界面的图标上，通过按压在图标的周围显示一个快捷操作（shortcuts）的菜单，通过这个菜单，我们能够更加快速直接的进入某项功能。现在主流的App都已经支持这项功能，可以在图标上按按试试。   \n\n这种快捷操作（shortcuts）分两种：\n* **Static shortcuts** 静态的，在Info.plist里面配置，在程序安装后就会存在。\n* **Dynamic shortcuts** 动态的，在运行时创建的，直到程序第一次运行后才会存在。\n\n#### Adding a static shortcut  \n添加一个静态的shortcut，首先需要在Info.plist里面配置，按照下图进行相应的配置：\n![](/images/2016.02.23/06.png)\n\n配置好了之后运行程序，在Home页面App Icon上按压能够看到我们配置的shortcut，点击后发现应用启动，但是不是我们想要的结果。我们需要在Appdelegate.swift中添加如下的代码：\n{% codeblock lang:swift %}   \n// 响应shortcut的点击\nfunc application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -> Void) {\n    handleShortcutItem(shortcutItem)\n\n    // 如果你自己处理了shortcut 这里参数为true 否则为false\n    completionHandler(true)\n}\n\nfunc handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {\n    print(shortcutItem.userInfo)\n    switch shortcutItem.type {\n    case \"com.razeware.Doodles.new\":\n        presentNewDoodleViewController()\n    default:\n        break\n    }\n}\n\nfunc presentNewDoodleViewController() {\n    let identifier = \"NewDoodleNavigationController\"\n    let doodleViewController = UIStoryboard.mainStoryboard .instantiateViewControllerWithIdentifier(identifier)\n\n    window?.rootViewController? .presentViewController(doodleViewController, animated: true, completion: nil)\n}\n{% endcodeblock %}  \n\n运行程序，点击shortcut会进入新建View Controller。   \n\n#### Adding a dynamic shortcut\n当然我们也能动态的通过程序添加shortcut，这个有一个限制就是程序必须运行一次才会生效。   \n修改Doodle.swift对应的方法如下（注释add地方为新加的）：\n{% codeblock lang:swift %}\nstatic func addDoodle(doodle: Doodle) {\n  allDoodles.append(doodle)\n  Doodle.configureDynamicShortcuts() // add\n}\n\nstatic func deleteDoodle(doodle: Doodle) {\n  if let index = allDoodles.indexOf({ $0.name == doodle.name }) {\n    allDoodles.removeAtIndex(index)\n      Doodle.configureDynamicShortcuts() // add\n  }\n}\n\n// 这个方法添加\nstatic func configureDynamicShortcuts() {\n    if let mostRecentDoodle = Doodle.sortedDoodles.first {\n        let shortcutType = \"com.razeware.Doodles.share\"\n        let shortcutItem = UIApplicationShortcutItem(type: shortcutType, localizedTitle: \"Share latest Doodle\", localizedSubtitle: mostRecentDoodle.name, icon: UIApplicationShortcutIcon(type: .Share), userInfo: nil)\n        UIApplication.sharedApplication().shortcutItems = [shortcutItem]\n    } else {\n        UIApplication.sharedApplication().shortcutItems = []\n    }\n}\n{% endcodeblock %}   \n\n修改AppDelegate.swift对应的方法：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool {\n  configureAppAppearance()\n  Doodle.configureDynamicShortcuts() // add\n  return true\n}\n\n…………\n\nfunc handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {\n    print(shortcutItem.userInfo)\n    switch shortcutItem.type {\n    case \"com.razeware.Doodles.new\":\n        presentNewDoodleViewController()\n    case \"com.razeware.Doodles.share\": // 处理share\n        shareMostRecentDoodle()\n    default:\n        break\n    }\n}\n\nfunc shareMostRecentDoodle() {\n    guard let mostRecentDoodle = Doodle.sortedDoodles.first, navigationController = window?.rootViewController as? UINavigationController else {\n        return\n    }\n\n    let identifier = \"DoodleDetailViewController\"\n    let doodleViewController = UIStoryboard.mainStoryboard.instantiateViewControllerWithIdentifier(identifier) as! DoodleDetailViewController\n\n    doodleViewController.doodle = mostRecentDoodle\n    doodleViewController.shareDoodle = true\n    navigationController.pushViewController(doodleViewController, animated: true)\n}\n\n{% endcodeblock %}   \n运行程序，然后退出到Home界面，按压图标，点击share，能够进入程序对应的详情页面，调用起来分享。\n![](/images/2016.02.23/07.png)  \n\n3D Touch相关的内容到这里就已经更新完了，初步计划以后录制视频关于动画相关的，希望有兴趣的朋友关注一下。\n","slug":"iOS9-by-Tutorials-学习笔记九：3D-Touch","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0p000d3is6uq57m4zy","content":"<p>很久没有更新文章了，自己也感觉自己懒得要发霉了。为了让自己不至于发霉，今天开始继续更新文章。   </p>\n<p>本篇文章介绍一下3D Touch。3D Touch 是iPhone 6s推出的一项新的技术，利用该技术能够更快的预览内容，更加平滑的进行多任务等。Apple提供一下与3D Touch 相关的API：   </p>\n<ul>\n<li>UITouch有一个 <strong>force</strong> 属性用来检测用户按下的程度。</li>\n<li>UIViewController提供了一个新的API，允许你展示新的view Controller的预览，这个预览成为 <strong>peek</strong>。此时继续用力，将会 <strong>pop</strong> 该预览，进入对应的View Controller 界面。</li>\n<li>UIApplicationShortcutItem 是一个新的类，你能使用它给home屏幕上的icon添加快捷操作。</li>\n</ul>\n<h3 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h3><p>在这篇文章中将会使用一个叫做 <strong>Doodles(涂鸦)</strong> App, 这个APP 比较简单，就两个界面：列表+详情，截图如下：<br><img src=\"/images/2016.02.23/01.png\" alt=\"\">  </p>\n<a id=\"more\"></a>  \n<p>代码结构如下：<br><img src=\"/images/2016.02.23/02.png\" alt=\"\">   </p>\n<h3 id=\"UITouch-force\"><a href=\"#UITouch-force\" class=\"headerlink\" title=\"UITouch force\"></a>UITouch force</h3><p>iOS9后，UITouch 添加了一个force属性，这个属性表示的按压屏幕的力量，取值范围为0~maximumPossibleForce(touch.maximumPossibleForce,这个值不是1)。我们可以利用force属性去改造我们的APP，让线条的粗细随着按压屏幕力量的变化而变化。<br>修改Canvas.swift中方法如下（下面标记update的为修改的）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addLineFromPoint</span><span class=\"params\">(from: CGPoint, toPoint: CGPoint, withForce force: CGFloat = <span class=\"number\">1</span>)</span></span> &#123; <span class=\"comment\">// update</span></span><br><span class=\"line\">    <span class=\"type\">UIGraphicsBeginImageContextWithOptions</span>(bounds.size, <span class=\"literal\">false</span>, <span class=\"number\">0.0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"force:\\(force)\"</span>)</span><br><span class=\"line\">    drawing?.drawInRect(bounds)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cxt = <span class=\"type\">UIGraphicsGetCurrentContext</span>()</span><br><span class=\"line\">    <span class=\"type\">CGContextMoveToPoint</span>(cxt, from.x, from.y)</span><br><span class=\"line\">    <span class=\"type\">CGContextAddLineToPoint</span>(cxt, toPoint.x, toPoint.y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextSetLineCap</span>(cxt, .<span class=\"type\">Round</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextSetLineWidth</span>(cxt, strokeWidth * force) <span class=\"comment\">// update</span></span><br><span class=\"line\"></span><br><span class=\"line\">    strokeColor.setStroke()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextStrokePath</span>(cxt)</span><br><span class=\"line\"></span><br><span class=\"line\">    drawing = <span class=\"type\">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    layer.contents = drawing?.<span class=\"type\">CGImage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UIGraphicsEndImageContext</span>()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>继续修改如下方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesMoved</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> touch = touches.first &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先去验证是否支持3D Touch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> traitCollection.forceTouchCapability == .<span class=\"type\">Available</span> &#123;</span><br><span class=\"line\">            addLineFromPoint(touch.previousLocationInView(<span class=\"keyword\">self</span>), toPoint: touch.locationInView(<span class=\"keyword\">self</span>), withForce: touch.force)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addLineFromPoint(touch.previousLocationInView(<span class=\"keyword\">self</span>), toPoint: touch.locationInView(<span class=\"keyword\">self</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>修改完后运行一下，用不同压力绘画，效果如下：<br><img src=\"/images/2016.02.23/03.png\" alt=\"\">  </p>\n<h3 id=\"Peeking-and-popping\"><a href=\"#Peeking-and-popping\" class=\"headerlink\" title=\"Peeking and popping\"></a>Peeking and popping</h3><p>对于 <strong>Peek</strong> 和 <strong>Pop</strong> 等写完下面的例子自然就明白了。  </p>\n<p>修改DoodlesViewController.swift对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">  <span class=\"comment\">// update</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> traitCollection.forceTouchCapability == .<span class=\"type\">Available</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加对于3D Touch的代理</span></span><br><span class=\"line\">      registerForPreviewingWithDelegate(<span class=\"keyword\">self</span>, sourceView: view)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">…………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展该类实现对应的协议 有两个方法用于处理peek pop</span></span><br><span class=\"line\"><span class=\"comment\">//MARK: - 3D Touch</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">DoodlesViewController</span>: <span class=\"title\">UIViewControllerPreviewingDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// peek 回调 返回一个包含对应内容的UIViewController</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class=\"type\">UIViewController</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleCell</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 获取点击的cell</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleDetailViewController</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 创建对应的View Controller</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        detailVC.doodle = cell.doodle <span class=\"comment\">// 设置数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊</span></span><br><span class=\"line\">        previewingContext.sourceRect = cell.frame <span class=\"comment\">//CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> detailVC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pop commitViewController是上面方法返回的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// peek之后继续用力 将会调用该方法 进入对应的view Controller</span></span><br><span class=\"line\">        showViewController(viewControllerToCommit, sender: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>运行效果如下：<br><img src=\"/images/2016.02.23/04.png\" alt=\"\">  </p>\n<h4 id=\"Preview-actions\"><a href=\"#Preview-actions\" class=\"headerlink\" title=\"Preview actions\"></a>Preview actions</h4><p>在 <strong>Peek</strong> 状态下，我们可以添加一些快捷操作，通过上划就能显示出来这些快捷操作。这些快捷操作是需要添加到 <strong>Peek</strong> 显示的View Controller中的。<br>在DoodleDetailViewController.swift 末尾添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> doodlesViewController:  <span class=\"type\">DoodlesViewController</span>?</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewActionItems</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">UIPreviewActionItem</span>] &#123;</span><br><span class=\"line\">    <span class=\"comment\">// UIPreviewAction 专门为3D Touch使用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> shareAction = <span class=\"type\">UIPreviewAction</span>(title: <span class=\"string\">\"分享\"</span>, style: .<span class=\"type\">Default</span>) &#123; (previewAction, viewController) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> doodlesVC = <span class=\"keyword\">self</span>.doodlesViewController, activityViewController = <span class=\"keyword\">self</span>.activityViewController &#123;</span><br><span class=\"line\">            doodlesVC.presentViewController(activityViewController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIPreviewAction</span>(title: <span class=\"string\">\"删除\"</span>, style: .<span class=\"type\">Default</span>) &#123; (previewAction, viewController) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> doodle = <span class=\"keyword\">self</span>.doodle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Doodle</span>.deleteDoodle(doodle)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> doodlesViewController = <span class=\"keyword\">self</span>.doodlesViewController &#123;</span><br><span class=\"line\">            doodlesViewController.tableView.reloadData()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [shareAction, deleteAction]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码添加了两个快捷键，一个是分享一个是删除。</p>\n<p>在DoodlesViewController.swift中也需要修改一下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释new add 是新添加的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class=\"type\">UIViewController</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleCell</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 获取点击的cell</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleDetailViewController</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 创建对应的View Controller</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    detailVC.doodle = cell.doodle <span class=\"comment\">// 设置数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    detailVC.doodlesViewController = <span class=\"keyword\">self</span> <span class=\"comment\">// new add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊</span></span><br><span class=\"line\">    previewingContext.sourceRect = cell.frame <span class=\"comment\">//CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> detailVC</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>运行程序，在 <strong>Peek</strong> 状态上划效果如下：<br><img src=\"/images/2016.02.23/05.png\" alt=\"\">   </p>\n<h3 id=\"Home-screen-quick-actions\"><a href=\"#Home-screen-quick-actions\" class=\"headerlink\" title=\"Home screen quick actions\"></a>Home screen quick actions</h3><p>3D Touch 另一个作用就是能够在Home界面的图标上，通过按压在图标的周围显示一个快捷操作（shortcuts）的菜单，通过这个菜单，我们能够更加快速直接的进入某项功能。现在主流的App都已经支持这项功能，可以在图标上按按试试。   </p>\n<p>这种快捷操作（shortcuts）分两种：</p>\n<ul>\n<li><strong>Static shortcuts</strong> 静态的，在Info.plist里面配置，在程序安装后就会存在。</li>\n<li><strong>Dynamic shortcuts</strong> 动态的，在运行时创建的，直到程序第一次运行后才会存在。</li>\n</ul>\n<h4 id=\"Adding-a-static-shortcut\"><a href=\"#Adding-a-static-shortcut\" class=\"headerlink\" title=\"Adding a static shortcut\"></a>Adding a static shortcut</h4><p>添加一个静态的shortcut，首先需要在Info.plist里面配置，按照下图进行相应的配置：<br><img src=\"/images/2016.02.23/06.png\" alt=\"\"></p>\n<p>配置好了之后运行程序，在Home页面App Icon上按压能够看到我们配置的shortcut，点击后发现应用启动，但是不是我们想要的结果。我们需要在Appdelegate.swift中添加如下的代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">// 响应shortcut的点击</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class=\"params\">(Bool)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    handleShortcutItem(shortcutItem)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果你自己处理了shortcut 这里参数为true 否则为false</span></span><br><span class=\"line\">    completionHandler(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleShortcutItem</span><span class=\"params\">(shortcutItem: UIApplicationShortcutItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(shortcutItem.userInfo)</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> shortcutItem.type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.new\"</span>:</span><br><span class=\"line\">        presentNewDoodleViewController()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentNewDoodleViewController</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"NewDoodleNavigationController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> doodleViewController = <span class=\"type\">UIStoryboard</span>.mainStoryboard .instantiateViewControllerWithIdentifier(identifier)</span><br><span class=\"line\"></span><br><span class=\"line\">    window?.rootViewController? .presentViewController(doodleViewController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>运行程序，点击shortcut会进入新建View Controller。   </p>\n<h4 id=\"Adding-a-dynamic-shortcut\"><a href=\"#Adding-a-dynamic-shortcut\" class=\"headerlink\" title=\"Adding a dynamic shortcut\"></a>Adding a dynamic shortcut</h4><p>当然我们也能动态的通过程序添加shortcut，这个有一个限制就是程序必须运行一次才会生效。<br>修改Doodle.swift对应的方法如下（注释add地方为新加的）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addDoodle</span><span class=\"params\">(doodle: Doodle)</span></span> &#123;</span><br><span class=\"line\">  allDoodles.append(doodle)</span><br><span class=\"line\">  <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deleteDoodle</span><span class=\"params\">(doodle: Doodle)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> index = allDoodles.indexOf(&#123; $<span class=\"number\">0</span>.name == doodle.name &#125;) &#123;</span><br><span class=\"line\">    allDoodles.removeAtIndex(index)</span><br><span class=\"line\">      <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法添加</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">configureDynamicShortcuts</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mostRecentDoodle = <span class=\"type\">Doodle</span>.sortedDoodles.first &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> shortcutType = <span class=\"string\">\"com.razeware.Doodles.share\"</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> shortcutItem = <span class=\"type\">UIApplicationShortcutItem</span>(type: shortcutType, localizedTitle: <span class=\"string\">\"Share latest Doodle\"</span>, localizedSubtitle: mostRecentDoodle.name, icon: <span class=\"type\">UIApplicationShortcutIcon</span>(type: .<span class=\"type\">Share</span>), userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().shortcutItems = [shortcutItem]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().shortcutItems = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>修改AppDelegate.swift对应的方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  configureAppAppearance()</span><br><span class=\"line\">  <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">…………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleShortcutItem</span><span class=\"params\">(shortcutItem: UIApplicationShortcutItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(shortcutItem.userInfo)</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> shortcutItem.type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.new\"</span>:</span><br><span class=\"line\">        presentNewDoodleViewController()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.share\"</span>: <span class=\"comment\">// 处理share</span></span><br><span class=\"line\">        shareMostRecentDoodle()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shareMostRecentDoodle</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> mostRecentDoodle = <span class=\"type\">Doodle</span>.sortedDoodles.first, navigationController = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> doodleViewController = <span class=\"type\">UIStoryboard</span>.mainStoryboard.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>! <span class=\"type\">DoodleDetailViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\">    doodleViewController.doodle = mostRecentDoodle</span><br><span class=\"line\">    doodleViewController.shareDoodle = <span class=\"literal\">true</span></span><br><span class=\"line\">    navigationController.pushViewController(doodleViewController, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>运行程序，然后退出到Home界面，按压图标，点击share，能够进入程序对应的详情页面，调用起来分享。<br><img src=\"/images/2016.02.23/07.png\" alt=\"\">  </p>\n<p>3D Touch相关的内容到这里就已经更新完了，初步计划以后录制视频关于动画相关的，希望有兴趣的朋友关注一下。</p>\n","excerpt":"<p>很久没有更新文章了，自己也感觉自己懒得要发霉了。为了让自己不至于发霉，今天开始继续更新文章。   </p>\n<p>本篇文章介绍一下3D Touch。3D Touch 是iPhone 6s推出的一项新的技术，利用该技术能够更快的预览内容，更加平滑的进行多任务等。Apple提供一下与3D Touch 相关的API：   </p>\n<ul>\n<li>UITouch有一个 <strong>force</strong> 属性用来检测用户按下的程度。</li>\n<li>UIViewController提供了一个新的API，允许你展示新的view Controller的预览，这个预览成为 <strong>peek</strong>。此时继续用力，将会 <strong>pop</strong> 该预览，进入对应的View Controller 界面。</li>\n<li>UIApplicationShortcutItem 是一个新的类，你能使用它给home屏幕上的icon添加快捷操作。</li>\n</ul>\n<h3 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h3><p>在这篇文章中将会使用一个叫做 <strong>Doodles(涂鸦)</strong> App, 这个APP 比较简单，就两个界面：列表+详情，截图如下：<br><img src=\"/images/2016.02.23/01.png\" alt=\"\">  </p>","more":"<p>代码结构如下：<br><img src=\"/images/2016.02.23/02.png\" alt=\"\">   </p>\n<h3 id=\"UITouch-force\"><a href=\"#UITouch-force\" class=\"headerlink\" title=\"UITouch force\"></a>UITouch force</h3><p>iOS9后，UITouch 添加了一个force属性，这个属性表示的按压屏幕的力量，取值范围为0~maximumPossibleForce(touch.maximumPossibleForce,这个值不是1)。我们可以利用force属性去改造我们的APP，让线条的粗细随着按压屏幕力量的变化而变化。<br>修改Canvas.swift中方法如下（下面标记update的为修改的）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addLineFromPoint</span><span class=\"params\">(from: CGPoint, toPoint: CGPoint, withForce force: CGFloat = <span class=\"number\">1</span>)</span></span> &#123; <span class=\"comment\">// update</span></span><br><span class=\"line\">    <span class=\"type\">UIGraphicsBeginImageContextWithOptions</span>(bounds.size, <span class=\"literal\">false</span>, <span class=\"number\">0.0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"force:\\(force)\"</span>)</span><br><span class=\"line\">    drawing?.drawInRect(bounds)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> cxt = <span class=\"type\">UIGraphicsGetCurrentContext</span>()</span><br><span class=\"line\">    <span class=\"type\">CGContextMoveToPoint</span>(cxt, from.x, from.y)</span><br><span class=\"line\">    <span class=\"type\">CGContextAddLineToPoint</span>(cxt, toPoint.x, toPoint.y)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextSetLineCap</span>(cxt, .<span class=\"type\">Round</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextSetLineWidth</span>(cxt, strokeWidth * force) <span class=\"comment\">// update</span></span><br><span class=\"line\"></span><br><span class=\"line\">    strokeColor.setStroke()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">CGContextStrokePath</span>(cxt)</span><br><span class=\"line\"></span><br><span class=\"line\">    drawing = <span class=\"type\">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    layer.contents = drawing?.<span class=\"type\">CGImage</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">UIGraphicsEndImageContext</span>()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>继续修改如下方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesMoved</span><span class=\"params\">(touches: Set&lt;UITouch&gt;, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> touch = touches.first &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先去验证是否支持3D Touch</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> traitCollection.forceTouchCapability == .<span class=\"type\">Available</span> &#123;</span><br><span class=\"line\">            addLineFromPoint(touch.previousLocationInView(<span class=\"keyword\">self</span>), toPoint: touch.locationInView(<span class=\"keyword\">self</span>), withForce: touch.force)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            addLineFromPoint(touch.previousLocationInView(<span class=\"keyword\">self</span>), toPoint: touch.locationInView(<span class=\"keyword\">self</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>修改完后运行一下，用不同压力绘画，效果如下：<br><img src=\"/images/2016.02.23/03.png\" alt=\"\">  </p>\n<h3 id=\"Peeking-and-popping\"><a href=\"#Peeking-and-popping\" class=\"headerlink\" title=\"Peeking and popping\"></a>Peeking and popping</h3><p>对于 <strong>Peek</strong> 和 <strong>Pop</strong> 等写完下面的例子自然就明白了。  </p>\n<p>修改DoodlesViewController.swift对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">  <span class=\"comment\">// update</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> traitCollection.forceTouchCapability == .<span class=\"type\">Available</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 添加对于3D Touch的代理</span></span><br><span class=\"line\">      registerForPreviewingWithDelegate(<span class=\"keyword\">self</span>, sourceView: view)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">…………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展该类实现对应的协议 有两个方法用于处理peek pop</span></span><br><span class=\"line\"><span class=\"comment\">//MARK: - 3D Touch</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">DoodlesViewController</span>: <span class=\"title\">UIViewControllerPreviewingDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// peek 回调 返回一个包含对应内容的UIViewController</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class=\"type\">UIViewController</span>? &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleCell</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 获取点击的cell</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleDetailViewController</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 创建对应的View Controller</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        detailVC.doodle = cell.doodle <span class=\"comment\">// 设置数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊</span></span><br><span class=\"line\">        previewingContext.sourceRect = cell.frame <span class=\"comment\">//CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> detailVC</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// pop commitViewController是上面方法返回的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, commitViewController viewControllerToCommit: UIViewController)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// peek之后继续用力 将会调用该方法 进入对应的view Controller</span></span><br><span class=\"line\">        showViewController(viewControllerToCommit, sender: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>运行效果如下：<br><img src=\"/images/2016.02.23/04.png\" alt=\"\">  </p>\n<h4 id=\"Preview-actions\"><a href=\"#Preview-actions\" class=\"headerlink\" title=\"Preview actions\"></a>Preview actions</h4><p>在 <strong>Peek</strong> 状态下，我们可以添加一些快捷操作，通过上划就能显示出来这些快捷操作。这些快捷操作是需要添加到 <strong>Peek</strong> 显示的View Controller中的。<br>在DoodleDetailViewController.swift 末尾添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> doodlesViewController:  <span class=\"type\">DoodlesViewController</span>?</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewActionItems</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">UIPreviewActionItem</span>] &#123;</span><br><span class=\"line\">    <span class=\"comment\">// UIPreviewAction 专门为3D Touch使用</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> shareAction = <span class=\"type\">UIPreviewAction</span>(title: <span class=\"string\">\"分享\"</span>, style: .<span class=\"type\">Default</span>) &#123; (previewAction, viewController) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> doodlesVC = <span class=\"keyword\">self</span>.doodlesViewController, activityViewController = <span class=\"keyword\">self</span>.activityViewController &#123;</span><br><span class=\"line\">            doodlesVC.presentViewController(activityViewController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> deleteAction = <span class=\"type\">UIPreviewAction</span>(title: <span class=\"string\">\"删除\"</span>, style: .<span class=\"type\">Default</span>) &#123; (previewAction, viewController) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> doodle = <span class=\"keyword\">self</span>.doodle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">Doodle</span>.deleteDoodle(doodle)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> doodlesViewController = <span class=\"keyword\">self</span>.doodlesViewController &#123;</span><br><span class=\"line\">            doodlesViewController.tableView.reloadData()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [shareAction, deleteAction]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码添加了两个快捷键，一个是分享一个是删除。</p>\n<p>在DoodlesViewController.swift中也需要修改一下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释new add 是新添加的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">previewingContext</span><span class=\"params\">(previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint)</span></span> -&gt; <span class=\"type\">UIViewController</span>? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> indexPath = tableView.indexPathForRowAtPoint(location), cell = tableView.cellForRowAtIndexPath(indexPath) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleCell</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 获取点击的cell</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> detailVC = storyboard?.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>? <span class=\"type\">DoodleDetailViewController</span> <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 创建对应的View Controller</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    detailVC.doodle = cell.doodle <span class=\"comment\">// 设置数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    detailVC.doodlesViewController = <span class=\"keyword\">self</span> <span class=\"comment\">// new add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 显示那部分区域响应的3D Touch 在peek之前，该frame之外的内容将会被模糊</span></span><br><span class=\"line\">    previewingContext.sourceRect = cell.frame <span class=\"comment\">//CGRect(x: 0, y: 100, width: 300, height: 40)// cell.frame</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> detailVC</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>运行程序，在 <strong>Peek</strong> 状态上划效果如下：<br><img src=\"/images/2016.02.23/05.png\" alt=\"\">   </p>\n<h3 id=\"Home-screen-quick-actions\"><a href=\"#Home-screen-quick-actions\" class=\"headerlink\" title=\"Home screen quick actions\"></a>Home screen quick actions</h3><p>3D Touch 另一个作用就是能够在Home界面的图标上，通过按压在图标的周围显示一个快捷操作（shortcuts）的菜单，通过这个菜单，我们能够更加快速直接的进入某项功能。现在主流的App都已经支持这项功能，可以在图标上按按试试。   </p>\n<p>这种快捷操作（shortcuts）分两种：</p>\n<ul>\n<li><strong>Static shortcuts</strong> 静态的，在Info.plist里面配置，在程序安装后就会存在。</li>\n<li><strong>Dynamic shortcuts</strong> 动态的，在运行时创建的，直到程序第一次运行后才会存在。</li>\n</ul>\n<h4 id=\"Adding-a-static-shortcut\"><a href=\"#Adding-a-static-shortcut\" class=\"headerlink\" title=\"Adding a static shortcut\"></a>Adding a static shortcut</h4><p>添加一个静态的shortcut，首先需要在Info.plist里面配置，按照下图进行相应的配置：<br><img src=\"/images/2016.02.23/06.png\" alt=\"\"></p>\n<p>配置好了之后运行程序，在Home页面App Icon上按压能够看到我们配置的shortcut，点击后发现应用启动，但是不是我们想要的结果。我们需要在Appdelegate.swift中添加如下的代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">// 响应shortcut的点击</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: <span class=\"params\">(Bool)</span></span></span> -&gt; <span class=\"type\">Void</span>) &#123;</span><br><span class=\"line\">    handleShortcutItem(shortcutItem)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果你自己处理了shortcut 这里参数为true 否则为false</span></span><br><span class=\"line\">    completionHandler(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleShortcutItem</span><span class=\"params\">(shortcutItem: UIApplicationShortcutItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(shortcutItem.userInfo)</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> shortcutItem.type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.new\"</span>:</span><br><span class=\"line\">        presentNewDoodleViewController()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentNewDoodleViewController</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"NewDoodleNavigationController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> doodleViewController = <span class=\"type\">UIStoryboard</span>.mainStoryboard .instantiateViewControllerWithIdentifier(identifier)</span><br><span class=\"line\"></span><br><span class=\"line\">    window?.rootViewController? .presentViewController(doodleViewController, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>运行程序，点击shortcut会进入新建View Controller。   </p>\n<h4 id=\"Adding-a-dynamic-shortcut\"><a href=\"#Adding-a-dynamic-shortcut\" class=\"headerlink\" title=\"Adding a dynamic shortcut\"></a>Adding a dynamic shortcut</h4><p>当然我们也能动态的通过程序添加shortcut，这个有一个限制就是程序必须运行一次才会生效。<br>修改Doodle.swift对应的方法如下（注释add地方为新加的）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addDoodle</span><span class=\"params\">(doodle: Doodle)</span></span> &#123;</span><br><span class=\"line\">  allDoodles.append(doodle)</span><br><span class=\"line\">  <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deleteDoodle</span><span class=\"params\">(doodle: Doodle)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> index = allDoodles.indexOf(&#123; $<span class=\"number\">0</span>.name == doodle.name &#125;) &#123;</span><br><span class=\"line\">    allDoodles.removeAtIndex(index)</span><br><span class=\"line\">      <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法添加</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">configureDynamicShortcuts</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> mostRecentDoodle = <span class=\"type\">Doodle</span>.sortedDoodles.first &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> shortcutType = <span class=\"string\">\"com.razeware.Doodles.share\"</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> shortcutItem = <span class=\"type\">UIApplicationShortcutItem</span>(type: shortcutType, localizedTitle: <span class=\"string\">\"Share latest Doodle\"</span>, localizedSubtitle: mostRecentDoodle.name, icon: <span class=\"type\">UIApplicationShortcutIcon</span>(type: .<span class=\"type\">Share</span>), userInfo: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().shortcutItems = [shortcutItem]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().shortcutItems = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>修改AppDelegate.swift对应的方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  configureAppAppearance()</span><br><span class=\"line\">  <span class=\"type\">Doodle</span>.configureDynamicShortcuts() <span class=\"comment\">// add</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">…………</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleShortcutItem</span><span class=\"params\">(shortcutItem: UIApplicationShortcutItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(shortcutItem.userInfo)</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> shortcutItem.type &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.new\"</span>:</span><br><span class=\"line\">        presentNewDoodleViewController()</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"com.razeware.Doodles.share\"</span>: <span class=\"comment\">// 处理share</span></span><br><span class=\"line\">        shareMostRecentDoodle()</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shareMostRecentDoodle</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> mostRecentDoodle = <span class=\"type\">Doodle</span>.sortedDoodles.first, navigationController = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> identifier = <span class=\"string\">\"DoodleDetailViewController\"</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> doodleViewController = <span class=\"type\">UIStoryboard</span>.mainStoryboard.instantiateViewControllerWithIdentifier(identifier) <span class=\"keyword\">as</span>! <span class=\"type\">DoodleDetailViewController</span></span><br><span class=\"line\"></span><br><span class=\"line\">    doodleViewController.doodle = mostRecentDoodle</span><br><span class=\"line\">    doodleViewController.shareDoodle = <span class=\"literal\">true</span></span><br><span class=\"line\">    navigationController.pushViewController(doodleViewController, animated: <span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>运行程序，然后退出到Home界面，按压图标，点击share，能够进入程序对应的详情页面，调用起来分享。<br><img src=\"/images/2016.02.23/07.png\" alt=\"\">  </p>\n<p>3D Touch相关的内容到这里就已经更新完了，初步计划以后录制视频关于动画相关的，希望有兴趣的朋友关注一下。</p>"},{"title":"iOS9 by Tutorials 学习笔记一：Swift 2.0","date":"2015-12-22T14:15:07.000Z","_content":"\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","source":"_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","raw":"title: iOS9 by Tutorials 学习笔记一：Swift 2.0\ndate: 2015-12-22 22:15:07\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","slug":"iOS9-by-Tutorials-学习笔记一：Swift-2-0","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0r000h3is6iy36490h","content":"<p>Apple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。<br>前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。<br>扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    </p>\n<p>Swift 2中加入了几个（作者认为）比较重要的改进，如下：</p>\n<ul>\n<li>新的控制流</li>\n<li>（相对）完善的错误处理模型</li>\n<li>协议扩展</li>\n<li>模式匹配的增强</li>\n<li>API可用性检测</li>\n<li>其他一些。。。。。。</li>\n</ul>\n<h3 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h3><p>在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered “control flow”.   </p>\n<h4 id=\"repeat…while\"><a href=\"#repeat…while\" class=\"headerlink\" title=\"repeat…while\"></a>repeat…while</h4><p>repeat…while是重复的意思，类似于其他语言中的do…while。其实在Swift 1.x中还是使用的do…while，在2.x中为了与do…catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   </p>\n<blockquote>\n<p>本例子中的代码都是在Playground中实现的    </p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">repeat</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"x:\\(x)\"</span>)</span><br><span class=\"line\">    x += <span class=\"number\">1</span> <span class=\"comment\">// Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> x &lt; <span class=\"number\">10</span> <span class=\"comment\">// 这个地方可以添加括号</span></span><br></pre></td></tr></table></figure>\n<p>上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。</p>\n<a id=\"more\"></a>\n<h4 id=\"guard\"><a href=\"#guard\" class=\"headerlink\" title=\"guard\"></a>guard</h4><p>guard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> !name.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">printName(<span class=\"string\">\"MengXiangYue\"</span>)</span><br></pre></td></tr></table></figure>  \n<p>上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。<strong>guard</strong> 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(inName: String?)</span></span> &#123; <span class=\"comment\">// 这里变成了可选值了</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name = inName <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> !name.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">printName(<span class=\"string\">\"MengXiangYue\"</span>)</span><br></pre></td></tr></table></figure>    \n<p>上面的例子中传入的参数是一个可选值，这时候使用『guard let name = _name else…』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。</p>\n<h3 id=\"（相对）完善的错误处理模型\"><a href=\"#（相对）完善的错误处理模型\" class=\"headerlink\" title=\"（相对）完善的错误处理模型\"></a>（相对）完善的错误处理模型</h3><p>这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    </p>\n<p>另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。<br>定义下面的一个协议：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> swift</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">JSONParsable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parse</span><span class=\"params\">(json: [String: AnyObject])</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了<strong>throws</strong> 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   </p>\n<p>那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守<strong>ErrorType</strong> 协议就可以了。OC中的NSError同样也实现了<strong>ErrorType</strong> 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ParseError</span>: <span class=\"title\">ErrorType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MissingAttribute</span>(message: <span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。<br>又扯远了，回到正题。下面我们实现一个结构体Person：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">JSONParsable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> firstName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastName: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parse</span><span class=\"params\">(json: [String : AnyObject])</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> firstName = json[<span class=\"string\">\"first_name\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> message = <span class=\"string\">\"Expected first_name String\"</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(message: message) <span class=\"comment\">// 1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> lastName = json[<span class=\"string\">\"last_name\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> message = <span class=\"string\">\"Expected last_name String\"</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(message: message) <span class=\"comment\">// 2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Person</span>(firstName: firstName, lastName: lastName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do…catch。下面是代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> person = <span class=\"keyword\">try</span> <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>])</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(<span class=\"keyword\">let</span> message) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(message)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Unexpected ErrorType\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n<p>do后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   </p>\n<p>如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">try</span>? <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>])  <span class=\"comment\">// nil</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">try</span>! <span class=\"type\">Person</span>.parse([<span class=\"string\">\"first_name\"</span>: <span class=\"string\">\"Ray\"</span>, <span class=\"string\">\"last_name\"</span>: <span class=\"string\">\"Wenderlich\"</span>]) <span class=\"comment\">// Person</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = <span class=\"keyword\">try</span>! <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>]) <span class=\"comment\">// error crash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"协议扩展\"><a href=\"#协议扩展\" class=\"headerlink\" title=\"协议扩展\"></a>协议扩展</h3><p>在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 验证是否合法的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123; <span class=\"keyword\">get</span> &#125;  <span class=\"comment\">// error的类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>上面定义了校验规则的协议，下面定义一个校验器协议：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> validationRules: [<span class=\"type\">StringValidationRule</span>] &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> -&gt; (valid: <span class=\"type\">Bool</span>, errors: [<span class=\"type\">StringValidationError</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>StringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> -&gt; (valid: <span class=\"type\">Bool</span>, errors:[<span class=\"type\">StringValidationError</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> errors = [<span class=\"type\">StringValidationError</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> rule <span class=\"keyword\">in</span> validationRules &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> rule.validate(string)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">                errors.append(error)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"Unexpected error type: \\(error)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (valid: errors.isEmpty, errors: errors)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StringValidationError</span>: <span class=\"title\">ErrorType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MustStartWith</span>(<span class=\"keyword\">set</span>: <span class=\"type\">NSCharacterSet</span>, description: <span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MustEndWith</span>(<span class=\"keyword\">set</span>: <span class=\"type\">NSCharacterSet</span>, description: <span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> errorString: <span class=\"type\">String</span></span><br><span class=\"line\">      <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">MustStartWith</span>(\\<span class=\"number\">_</span>, <span class=\"keyword\">let</span> description):</span><br><span class=\"line\">        errorString = <span class=\"string\">\"Must start with \\(description).\"</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">MustEndWith</span>(\\<span class=\"number\">_</span>, <span class=\"keyword\">let</span> description):</span><br><span class=\"line\">        errorString = <span class=\"string\">\"Must end with \\(description).\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> errorString</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展String</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startsWithCharacterFromSet</span><span class=\"params\">(<span class=\"keyword\">set</span>: NSCharacterSet)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeOfCharacterFromSet(<span class=\"keyword\">set</span>, options: [], range: startIndex..&lt;startIndex.successor()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">endsWithCharacterFromSet</span><span class=\"params\">(<span class=\"keyword\">set</span>: NSCharacterSet)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeOfCharacterFromSet(<span class=\"keyword\">set</span>, options: [], range: endIndex.predecessor()..&lt;endIndex) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StartsWithCharacterStringValidationRule</span> : <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> characterSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .<span class=\"type\">MustStartWith</span>(<span class=\"keyword\">set</span>: characterSet, description: description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        string</span><br><span class=\"line\">        <span class=\"keyword\">if</span> string.startsWithCharacterFromSet(characterSet) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> errorType <span class=\"comment\">// 4</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EndsWithCharacterStringValidationRule</span>: <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> characterSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .<span class=\"type\">MustEndWith</span>(<span class=\"keyword\">set</span>: characterSet, description: description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> string.endsWithCharacterFromSet(characterSet) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> errorType</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>两个验证规则创建好了，下面我们创建一个校验器：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -&gt; (valid: Bool, errors:[StringValidationError])方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StartsAndEndsWithStringValidator</span>: <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startsWithSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> startsWithDescription: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> endsWithSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> endsWithDescription: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> validationRules: [<span class=\"type\">StringValidationRule</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      <span class=\"type\">StartsWithCharacterStringValidationRule</span>(characterSet: startsWithSet, description: startsWithDescription),</span><br><span class=\"line\">      <span class=\"type\">EndsWithCharacterStringValidationRule</span>(characterSet: endsWithSet, description: endsWithDescription)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面使用一下</span></span><br><span class=\"line\">et numberSet = <span class=\"type\">NSCharacterSet</span>.decimalDigitCharacterSet()</span><br><span class=\"line\"><span class=\"keyword\">let</span> startsAndEndsWithValidator = <span class=\"type\">StartsAndEndsWithStringValidator</span>(startsWithSet: letterSet, startsWithDescription: <span class=\"string\">\"letter\"</span>, endsWithSet: numberSet, endsWithDescription: <span class=\"string\">\"number\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">startsAndEndsWithValidator.validate(<span class=\"string\">\"1foo\"</span>).errors.description</span><br></pre></td></tr></table></figure>   </p>\n<p>上面的内容是一个简单的例子，我将书中的例子做了一些简化。   </p>\n<p>下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  </span></span><br><span class=\"line\"><span class=\"comment\">// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">MutableCollectionType</span> <span class=\"title\">where</span> <span class=\"title\">Index</span> == <span class=\"title\">Int</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 该方法任意的交换集合元素</span></span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shuffleInPlace</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"keyword\">self</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;(<span class=\"built_in\">c</span>-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = <span class=\"type\">Int</span>(arc4random_uniform(<span class=\"type\">UInt32</span>(<span class=\"built_in\">c</span> - i))) + i</span><br><span class=\"line\">      <span class=\"keyword\">guard</span> i != j <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">continue</span> &#125;</span><br><span class=\"line\">      <span class=\"built_in\">swap</span>(&amp;<span class=\"keyword\">self</span>[i], &amp;<span class=\"keyword\">self</span>[j])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> people = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Ray\"</span>, <span class=\"string\">\"Sam\"</span>, <span class=\"string\">\"Jake\"</span>, <span class=\"string\">\"Charlie\"</span>]</span><br><span class=\"line\">people.shuffleInPlace()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模式匹配的增强\"><a href=\"#模式匹配的增强\" class=\"headerlink\" title=\"模式匹配的增强\"></a>模式匹配的增强</h3><p>在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Charlie\"</span>, <span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Mic\"</span>, <span class=\"string\">\"John\"</span>, <span class=\"string\">\"Craig\"</span>, <span class=\"string\">\"Felipe\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> namesThatStartWithC = [<span class=\"type\">String</span>]()</span><br><span class=\"line\"><span class=\"comment\">// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> cName <span class=\"keyword\">in</span> names <span class=\"keyword\">where</span> cName.hasPrefix(<span class=\"string\">\"C\"</span>) &#123;</span><br><span class=\"line\">  namesThatStartWithC.append(cName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Author</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Author</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> status: <span class=\"type\">Additional_Things_PageSources</span>.<span class=\"type\">AuthorStatus</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, status: <span class=\"type\">Additional_Things_PageSources</span>.<span class=\"type\">AuthorStatus</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> authors = [</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Chris Wagner\"</span>, status: .<span class=\"type\">Late</span>(daysLate: <span class=\"number\">5</span>)),</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Charlie Fulton\"</span>, status: .<span class=\"type\">Late</span>(daysLate: <span class=\"number\">10</span>)),</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Evan Dekhayser\"</span>, status: .<span class=\"type\">OnTime</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> slapLog = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> author <span class=\"keyword\">in</span> authors &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">case</span> .<span class=\"type\">Late</span>(<span class=\"keyword\">let</span> daysLate) = author.status <span class=\"keyword\">where</span> daysLate &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    slapLog += <span class=\"string\">\"Ray slaps \\(author.name) around a bit with a large trout \\n\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"API可用性检测\"><a href=\"#API可用性检测\" class=\"headerlink\" title=\"API可用性检测\"></a>API可用性检测</h3><p>在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">9.0</span>, \\*) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用在iOS 9下才能使用的API</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h3><p>defer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   </p>\n<p>例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ATM</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispenseFunds</span><span class=\"params\">(amount: Float, <span class=\"keyword\">inout</span> account: Account)</span></span> <span class=\"keyword\">throws</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> &#123;  <span class=\"comment\">// 保证一定能够退卡成功</span></span><br><span class=\"line\">     log += <span class=\"string\">\"Card for \\(account.name) has been returned to customer.\\n\"</span></span><br><span class=\"line\">     ejectCard()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 其他的逻辑处理</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ejectCard</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// physically eject card</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。</p>\n","excerpt":"<p>Apple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。<br>前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。<br>扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    </p>\n<p>Swift 2中加入了几个（作者认为）比较重要的改进，如下：</p>\n<ul>\n<li>新的控制流</li>\n<li>（相对）完善的错误处理模型</li>\n<li>协议扩展</li>\n<li>模式匹配的增强</li>\n<li>API可用性检测</li>\n<li>其他一些。。。。。。</li>\n</ul>\n<h3 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h3><p>在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered “control flow”.   </p>\n<h4 id=\"repeat…while\"><a href=\"#repeat…while\" class=\"headerlink\" title=\"repeat…while\"></a>repeat…while</h4><p>repeat…while是重复的意思，类似于其他语言中的do…while。其实在Swift 1.x中还是使用的do…while，在2.x中为了与do…catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   </p>\n<blockquote>\n<p>本例子中的代码都是在Playground中实现的    </p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">repeat</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"x:\\(x)\"</span>)</span><br><span class=\"line\">    x += <span class=\"number\">1</span> <span class=\"comment\">// Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> x &lt; <span class=\"number\">10</span> <span class=\"comment\">// 这个地方可以添加括号</span></span><br></pre></td></tr></table></figure>\n<p>上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。</p>","more":"<h4 id=\"guard\"><a href=\"#guard\" class=\"headerlink\" title=\"guard\"></a>guard</h4><p>guard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> !name.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">printName(<span class=\"string\">\"MengXiangYue\"</span>)</span><br></pre></td></tr></table></figure>  \n<p>上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。<strong>guard</strong> 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">printName</span><span class=\"params\">(inName: String?)</span></span> &#123; <span class=\"comment\">// 这里变成了可选值了</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> name = inName <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">guard</span> !name.isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"no name\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printName(<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">printName(<span class=\"string\">\"MengXiangYue\"</span>)</span><br></pre></td></tr></table></figure>    \n<p>上面的例子中传入的参数是一个可选值，这时候使用『guard let name = _name else…』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。</p>\n<h3 id=\"（相对）完善的错误处理模型\"><a href=\"#（相对）完善的错误处理模型\" class=\"headerlink\" title=\"（相对）完善的错误处理模型\"></a>（相对）完善的错误处理模型</h3><p>这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    </p>\n<p>另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。<br>定义下面的一个协议：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> swift</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">JSONParsable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parse</span><span class=\"params\">(json: [String: AnyObject])</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了<strong>throws</strong> 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   </p>\n<p>那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守<strong>ErrorType</strong> 协议就可以了。OC中的NSError同样也实现了<strong>ErrorType</strong> 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">ParseError</span>: <span class=\"title\">ErrorType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MissingAttribute</span>(message: <span class=\"type\">String</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。<br>又扯远了，回到正题。下面我们实现一个结构体Person：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span>: <span class=\"title\">JSONParsable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> firstName: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lastName: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">parse</span><span class=\"params\">(json: [String : AnyObject])</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> firstName = json[<span class=\"string\">\"first_name\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> message = <span class=\"string\">\"Expected first_name String\"</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(message: message) <span class=\"comment\">// 1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> lastName = json[<span class=\"string\">\"last_name\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> message = <span class=\"string\">\"Expected last_name String\"</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(message: message) <span class=\"comment\">// 2</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Person</span>(firstName: firstName, lastName: lastName)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do…catch。下面是代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> person = <span class=\"keyword\">try</span> <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>])</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">ParseError</span>.<span class=\"type\">MissingAttribute</span>(<span class=\"keyword\">let</span> message) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(message)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"Unexpected ErrorType\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>    \n<p>do后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   </p>\n<p>如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> p1 = <span class=\"keyword\">try</span>? <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>])  <span class=\"comment\">// nil</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p2 = <span class=\"keyword\">try</span>! <span class=\"type\">Person</span>.parse([<span class=\"string\">\"first_name\"</span>: <span class=\"string\">\"Ray\"</span>, <span class=\"string\">\"last_name\"</span>: <span class=\"string\">\"Wenderlich\"</span>]) <span class=\"comment\">// Person</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> p3 = <span class=\"keyword\">try</span>! <span class=\"type\">Person</span>.parse([<span class=\"string\">\"foo\"</span>: <span class=\"string\">\"bar\"</span>]) <span class=\"comment\">// error crash</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"协议扩展\"><a href=\"#协议扩展\" class=\"headerlink\" title=\"协议扩展\"></a>协议扩展</h3><p>在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 验证是否合法的方法</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123; <span class=\"keyword\">get</span> &#125;  <span class=\"comment\">// error的类型</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>上面定义了校验规则的协议，下面定义一个校验器协议：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> validationRules: [<span class=\"type\">StringValidationRule</span>] &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> -&gt; (valid: <span class=\"type\">Bool</span>, errors: [<span class=\"type\">StringValidationError</span>])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>StringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> -&gt; (valid: <span class=\"type\">Bool</span>, errors:[<span class=\"type\">StringValidationError</span>]) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">var</span> errors = [<span class=\"type\">StringValidationError</span>]()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> rule <span class=\"keyword\">in</span> validationRules &#123;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> rule.validate(string)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error <span class=\"keyword\">as</span> <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">                errors.append(error)</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> <span class=\"keyword\">let</span> error &#123;</span><br><span class=\"line\">                <span class=\"built_in\">fatalError</span>(<span class=\"string\">\"Unexpected error type: \\(error)\"</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (valid: errors.isEmpty, errors: errors)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">StringValidationError</span>: <span class=\"title\">ErrorType</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MustStartWith</span>(<span class=\"keyword\">set</span>: <span class=\"type\">NSCharacterSet</span>, description: <span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"type\">MustEndWith</span>(<span class=\"keyword\">set</span>: <span class=\"type\">NSCharacterSet</span>, description: <span class=\"type\">String</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> errorString: <span class=\"type\">String</span></span><br><span class=\"line\">      <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">MustStartWith</span>(\\<span class=\"number\">_</span>, <span class=\"keyword\">let</span> description):</span><br><span class=\"line\">        errorString = <span class=\"string\">\"Must start with \\(description).\"</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">MustEndWith</span>(\\<span class=\"number\">_</span>, <span class=\"keyword\">let</span> description):</span><br><span class=\"line\">        errorString = <span class=\"string\">\"Must end with \\(description).\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> errorString</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展String</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">startsWithCharacterFromSet</span><span class=\"params\">(<span class=\"keyword\">set</span>: NSCharacterSet)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeOfCharacterFromSet(<span class=\"keyword\">set</span>, options: [], range: startIndex..&lt;startIndex.successor()) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">endsWithCharacterFromSet</span><span class=\"params\">(<span class=\"keyword\">set</span>: NSCharacterSet)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> !isEmpty <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> rangeOfCharacterFromSet(<span class=\"keyword\">set</span>, options: [], range: endIndex.predecessor()..&lt;endIndex) != <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StartsWithCharacterStringValidationRule</span> : <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> characterSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .<span class=\"type\">MustStartWith</span>(<span class=\"keyword\">set</span>: characterSet, description: description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        string</span><br><span class=\"line\">        <span class=\"keyword\">if</span> string.startsWithCharacterFromSet(characterSet) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> errorType <span class=\"comment\">// 4</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">EndsWithCharacterStringValidationRule</span>: <span class=\"title\">StringValidationRule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> characterSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> errorType: <span class=\"type\">StringValidationError</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> .<span class=\"type\">MustEndWith</span>(<span class=\"keyword\">set</span>: characterSet, description: description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">validate</span><span class=\"params\">(string: String)</span></span> <span class=\"keyword\">throws</span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> string.endsWithCharacterFromSet(characterSet) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> errorType</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>两个验证规则创建好了，下面我们创建一个校验器：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -&gt; (valid: Bool, errors:[StringValidationError])方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StartsAndEndsWithStringValidator</span>: <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> startsWithSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> startsWithDescription: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> endsWithSet: <span class=\"type\">NSCharacterSet</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> endsWithDescription: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> validationRules: [<span class=\"type\">StringValidationRule</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [</span><br><span class=\"line\">      <span class=\"type\">StartsWithCharacterStringValidationRule</span>(characterSet: startsWithSet, description: startsWithDescription),</span><br><span class=\"line\">      <span class=\"type\">EndsWithCharacterStringValidationRule</span>(characterSet: endsWithSet, description: endsWithDescription)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面使用一下</span></span><br><span class=\"line\">et numberSet = <span class=\"type\">NSCharacterSet</span>.decimalDigitCharacterSet()</span><br><span class=\"line\"><span class=\"keyword\">let</span> startsAndEndsWithValidator = <span class=\"type\">StartsAndEndsWithStringValidator</span>(startsWithSet: letterSet, startsWithDescription: <span class=\"string\">\"letter\"</span>, endsWithSet: numberSet, endsWithDescription: <span class=\"string\">\"number\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">startsAndEndsWithValidator.validate(<span class=\"string\">\"1foo\"</span>).errors.description</span><br></pre></td></tr></table></figure>   </p>\n<p>上面的内容是一个简单的例子，我将书中的例子做了一些简化。   </p>\n<p>下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  </span></span><br><span class=\"line\"><span class=\"comment\">// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">MutableCollectionType</span> <span class=\"title\">where</span> <span class=\"title\">Index</span> == <span class=\"title\">Int</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 该方法任意的交换集合元素</span></span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shuffleInPlace</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"built_in\">c</span> = <span class=\"keyword\">self</span>.<span class=\"built_in\">count</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;(<span class=\"built_in\">c</span>-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> j = <span class=\"type\">Int</span>(arc4random_uniform(<span class=\"type\">UInt32</span>(<span class=\"built_in\">c</span> - i))) + i</span><br><span class=\"line\">      <span class=\"keyword\">guard</span> i != j <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">continue</span> &#125;</span><br><span class=\"line\">      <span class=\"built_in\">swap</span>(&amp;<span class=\"keyword\">self</span>[i], &amp;<span class=\"keyword\">self</span>[j])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> people = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Ray\"</span>, <span class=\"string\">\"Sam\"</span>, <span class=\"string\">\"Jake\"</span>, <span class=\"string\">\"Charlie\"</span>]</span><br><span class=\"line\">people.shuffleInPlace()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模式匹配的增强\"><a href=\"#模式匹配的增强\" class=\"headerlink\" title=\"模式匹配的增强\"></a>模式匹配的增强</h3><p>在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Charlie\"</span>, <span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Mic\"</span>, <span class=\"string\">\"John\"</span>, <span class=\"string\">\"Craig\"</span>, <span class=\"string\">\"Felipe\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> namesThatStartWithC = [<span class=\"type\">String</span>]()</span><br><span class=\"line\"><span class=\"comment\">// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> cName <span class=\"keyword\">in</span> names <span class=\"keyword\">where</span> cName.hasPrefix(<span class=\"string\">\"C\"</span>) &#123;</span><br><span class=\"line\">  namesThatStartWithC.append(cName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个Author</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Author</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">let</span> status: <span class=\"type\">Additional_Things_PageSources</span>.<span class=\"type\">AuthorStatus</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, status: <span class=\"type\">Additional_Things_PageSources</span>.<span class=\"type\">AuthorStatus</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> authors = [</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Chris Wagner\"</span>, status: .<span class=\"type\">Late</span>(daysLate: <span class=\"number\">5</span>)),</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Charlie Fulton\"</span>, status: .<span class=\"type\">Late</span>(daysLate: <span class=\"number\">10</span>)),</span><br><span class=\"line\">  <span class=\"type\">Author</span>(name: <span class=\"string\">\"Evan Dekhayser\"</span>, status: .<span class=\"type\">OnTime</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> slapLog = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> author <span class=\"keyword\">in</span> authors &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">case</span> .<span class=\"type\">Late</span>(<span class=\"keyword\">let</span> daysLate) = author.status <span class=\"keyword\">where</span> daysLate &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">    slapLog += <span class=\"string\">\"Ray slaps \\(author.name) around a bit with a large trout \\n\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"API可用性检测\"><a href=\"#API可用性检测\" class=\"headerlink\" title=\"API可用性检测\"></a>API可用性检测</h3><p>在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> #available(iOS <span class=\"number\">9.0</span>, \\*) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 调用在iOS 9下才能使用的API</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h3><p>defer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   </p>\n<p>例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ATM</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">dispenseFunds</span><span class=\"params\">(amount: Float, <span class=\"keyword\">inout</span> account: Account)</span></span> <span class=\"keyword\">throws</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">defer</span> &#123;  <span class=\"comment\">// 保证一定能够退卡成功</span></span><br><span class=\"line\">     log += <span class=\"string\">\"Card for \\(account.name) has been returned to customer.\\n\"</span></span><br><span class=\"line\">     ejectCard()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 其他的逻辑处理</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ejectCard</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// physically eject card</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。</p>"},{"title":"iOS9 by Tutorials 学习笔记二：App Search","date":"2015-12-27T03:52:58.000Z","_content":"> 本文为自己读书的一个总结，可能与原书有一定出入  \n\niOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：\n* NSUserActivity\n* Core Spotlight\n* Web markup\n\n下面简单的说一下我对于这三个API的理解：\n1. NSUserActivity:   \nNSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   \n2. Core Spotlight:   \n这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    \n3. Web markup:    \nWeb Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。\n\n<!--more-->\n\n###  Getting started\n下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：\n![](/images/2015.12.27.01.png)    \n\n下面是这个工程的截图：\n![](/images/2015.12.27.02.png)    \n\n下面是图中标注的几个关键类的解释：\n1. AppDelegate     \n  点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    \n2. EmployeeViewController    \n  人员的详细界面，这个里面主要设置NSUserActivity    \n3. EmployeeService    \n  这个主要是写CoreSpotlight中index相关的东西    \n4. EmployeeSearch    \n  主要是扩展了Employee类，添加了与搜索相关的属性    \n另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    \n\n在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  \n* Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容\n* ViewedRecords 只有打开过的才能够被搜索到  \n* AllRecords 所有的员工信息都能够被搜索到   \n\n#### 搜索我们已经打开过的内容   \n使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：\n1. 创建NSUserActivity的一个实例，设置相关的属性\n2. 赋值给UIViewController的userActivity属性   \n\n下面我们在EmployeeSearch中添加如下代码：  \n> 如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   \n\n{% codeblock lang:swift %}\nimport Foundation\nimport CoreSpotlight\n\nextension Employee {\n  // 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到\n  public static let domainIdentifier = \"com.mengxiangyue.colleagues.employee\"\n  // 字典 在处理点击的时候，可以根据该字典获取我们想要的数据\n  public var userActivityUserInfo: [NSObject: AnyObject] {\n    return [\"id\": objectId]\n  }\n\n  // 给Employee添加userActivity属性，主要是方便我们获取userActivity\n  public var userActivity: NSUserActivity {\n    let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n    activity.title = name  // 显示的名字\n    activity.userInfo = userActivityUserInfo  // 与该Activity相关的数据\n    activity.keywords = [email, department]  // 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索\n    return activity\n  }\n}  \n{% endcodeblock %}\n这里扩展了Employee，然后添加了几个属性，属性的意义见注释。  \n这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   \n\n下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：\n{% codeblock lang:swift %}\nlet activity = employee.userActivity\nswitch Setting.searchIndexingPreference {\ncase .Disabled:\n  activity.eligibleForSearch = false\ncase .ViewedRecords:\n  activity.eligibleForSearch = true\n  // relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复\n  activity.contentAttributeSet?.relatedUniqueIdentifier = nil\ncase .AllRecords:\n  activity.eligibleForSearch = true\n}\n\nuserActivity = activity\n{% endcodeblock %}   \n\n下面在该类中添加如下的方法，用于在合适的时机更新Activity：\n{% codeblock lang:swift %}\n// 更新NSUserActivity关联的信息\n  override func updateUserActivityState(activity: NSUserActivity) {\n    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)\n  }\n{% endcodeblock %}  \n\n下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：  \n![](/images/2015.12.27.03.png)   \n\n看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：  \n![](/images/2015.12.27.04.png)   \n\n下面我们在EmployeeSearch.swift添加如下属性：\n\n{% codeblock lang:swift %}\npublic var attributeSet: CSSearchableItemAttributeSet {\n  let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact as String)\n  attributeSet.title = name  // 不太清楚是干啥的\n  attributeSet.contentDescription = \"\\(department), \\(title)\\n\\(phone)\"\n  attributeSet.thumbnailData = UIImageJPEGRepresentation(loadPicture(), 0.9)\n  attributeSet.supportsPhoneCall = true\n  attributeSet.phoneNumbers = [phone]\n  attributeSet.emailAddresses = [email]\n  attributeSet.keywords = skills\n  attributeSet.relatedUniqueIdentifier = objectId  \n\n  return attributeSet\n}\n{% endcodeblock %}  \n\n然后将给userActivity添加如下属性：   \n\n{% codeblock lang:swift %}\npublic var userActivity: NSUserActivity {\n  let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n  activity.title = name\n  activity.userInfo = userActivityUserInfo\n  activity.keywords = [email, department]\n  activity.contentAttributeSet = attributeSet   // 新添加的这一行\n  return activity\n}\n{% endcodeblock %}  \n\n然后运行程序，搜索结果如下：\n![](/images/2015.12.27.05.png)   \n\n但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：\n\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n  let objectId: String\n  // 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId\n  if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n    objectId = activityObjectId\n  }\n  // 获取对应Employee实例 然后跳转到对应的界面\n  if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n    nav.popToRootViewControllerAnimated(false)\n    let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n    employeeViewController.employee = employee\n    nav.pushViewController(employeeViewController, animated: false)\n    return true\n  }\n  return false\n}   \n{% endcodeblock %}\n这时候我们再点击搜索结果就能够跳转到对应的详细界面了。\n\n### CoreSpotlight\n下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：\n\n{% codeblock lang:swift %}\n// 在前面的代码中已经设置过了\nattributeSet.relatedUniqueIdentifier = objectId\n{% endcodeblock %}\n这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   \n\n然后在EmployeeSearch.swift添加如下的代码：\n\n{% codeblock lang:swift %}\n// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用\nvar searchableItem: CSSearchableItem {\n  let item = CSSearchableItem(uniqueIdentifier: objectId, domainIdentifier: Employee.domainIdentifier, attributeSet: attributeSet)\n  return item\n}\n{% endcodeblock %}   \n\n然后在EmployeeService.swift添加如下代码：  \n\n{% codeblock lang:swift %}   \nimport CoreSpotlight\n\n..............<省略一部分代码>\n\npublic func indexAllEmployees() {\n  let employees = fetchEmployees()\n  let searchableItems = employees.map{ $0.searchableItem }\n  // 将我们需要被索引的item放入到defaultSearchableIndex中\n  CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in\n    if let error = error {\n      print(\"Error indexing employees: \\(error)\")\n    } else {\n      print(\"Employees indexed.\")\n    }\n  }\n}\n{% endcodeblock %}   \n然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：\n![](/images/2015.12.27.06.png)\n\n但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n    let objectId: String\n    if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n      objectId = activityObjectId\n    }\n    // 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   \n    // CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值\n    else if userActivity.activityType == CSSearchableItemActionType, let activityObjectId = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String {\n      objectId = activityObjectId\n    } else {\n      return false\n    }\n    if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n      nav.popToRootViewControllerAnimated(false)\n      let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n      employeeViewController.employee = employee\n      nav.pushViewController(employeeViewController, animated: false)\n      return true\n    }\n    return false\n  }\n{% endcodeblock %}   \n这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   \n\n### 删除Item\n最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：\n{% codeblock lang:swift %}\npublic func destroyEmployeeIndexing() {\n  CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -> Void in\n    if let error = error {\n      print(\"Error deleting searching employee items: \\(error)\")\n    } else {\n      print(\"Employees indexing deleted.\")\n    }\n  }\n}\n{% endcodeblock %}\n这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   \n\n另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:[CoreSpotlight.framework注释翻译](http://blog.csdn.net/mengxiangyue/article/details/46575977)\n","source":"_posts/iOS9-by-Tutorials-学习笔记二：App-Search.md","raw":"title: iOS9 by Tutorials 学习笔记二：App Search\ndate: 2015-12-27 11:52:58\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n> 本文为自己读书的一个总结，可能与原书有一定出入  \n\niOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：\n* NSUserActivity\n* Core Spotlight\n* Web markup\n\n下面简单的说一下我对于这三个API的理解：\n1. NSUserActivity:   \nNSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   \n2. Core Spotlight:   \n这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    \n3. Web markup:    \nWeb Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。\n\n<!--more-->\n\n###  Getting started\n下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：\n![](/images/2015.12.27.01.png)    \n\n下面是这个工程的截图：\n![](/images/2015.12.27.02.png)    \n\n下面是图中标注的几个关键类的解释：\n1. AppDelegate     \n  点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    \n2. EmployeeViewController    \n  人员的详细界面，这个里面主要设置NSUserActivity    \n3. EmployeeService    \n  这个主要是写CoreSpotlight中index相关的东西    \n4. EmployeeSearch    \n  主要是扩展了Employee类，添加了与搜索相关的属性    \n另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    \n\n在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  \n* Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容\n* ViewedRecords 只有打开过的才能够被搜索到  \n* AllRecords 所有的员工信息都能够被搜索到   \n\n#### 搜索我们已经打开过的内容   \n使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：\n1. 创建NSUserActivity的一个实例，设置相关的属性\n2. 赋值给UIViewController的userActivity属性   \n\n下面我们在EmployeeSearch中添加如下代码：  \n> 如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   \n\n{% codeblock lang:swift %}\nimport Foundation\nimport CoreSpotlight\n\nextension Employee {\n  // 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到\n  public static let domainIdentifier = \"com.mengxiangyue.colleagues.employee\"\n  // 字典 在处理点击的时候，可以根据该字典获取我们想要的数据\n  public var userActivityUserInfo: [NSObject: AnyObject] {\n    return [\"id\": objectId]\n  }\n\n  // 给Employee添加userActivity属性，主要是方便我们获取userActivity\n  public var userActivity: NSUserActivity {\n    let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n    activity.title = name  // 显示的名字\n    activity.userInfo = userActivityUserInfo  // 与该Activity相关的数据\n    activity.keywords = [email, department]  // 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索\n    return activity\n  }\n}  \n{% endcodeblock %}\n这里扩展了Employee，然后添加了几个属性，属性的意义见注释。  \n这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   \n\n下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：\n{% codeblock lang:swift %}\nlet activity = employee.userActivity\nswitch Setting.searchIndexingPreference {\ncase .Disabled:\n  activity.eligibleForSearch = false\ncase .ViewedRecords:\n  activity.eligibleForSearch = true\n  // relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复\n  activity.contentAttributeSet?.relatedUniqueIdentifier = nil\ncase .AllRecords:\n  activity.eligibleForSearch = true\n}\n\nuserActivity = activity\n{% endcodeblock %}   \n\n下面在该类中添加如下的方法，用于在合适的时机更新Activity：\n{% codeblock lang:swift %}\n// 更新NSUserActivity关联的信息\n  override func updateUserActivityState(activity: NSUserActivity) {\n    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)\n  }\n{% endcodeblock %}  \n\n下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：  \n![](/images/2015.12.27.03.png)   \n\n看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：  \n![](/images/2015.12.27.04.png)   \n\n下面我们在EmployeeSearch.swift添加如下属性：\n\n{% codeblock lang:swift %}\npublic var attributeSet: CSSearchableItemAttributeSet {\n  let attributeSet = CSSearchableItemAttributeSet(itemContentType: kUTTypeContact as String)\n  attributeSet.title = name  // 不太清楚是干啥的\n  attributeSet.contentDescription = \"\\(department), \\(title)\\n\\(phone)\"\n  attributeSet.thumbnailData = UIImageJPEGRepresentation(loadPicture(), 0.9)\n  attributeSet.supportsPhoneCall = true\n  attributeSet.phoneNumbers = [phone]\n  attributeSet.emailAddresses = [email]\n  attributeSet.keywords = skills\n  attributeSet.relatedUniqueIdentifier = objectId  \n\n  return attributeSet\n}\n{% endcodeblock %}  \n\n然后将给userActivity添加如下属性：   \n\n{% codeblock lang:swift %}\npublic var userActivity: NSUserActivity {\n  let activity = NSUserActivity(activityType: Employee.domainIdentifier)\n  activity.title = name\n  activity.userInfo = userActivityUserInfo\n  activity.keywords = [email, department]\n  activity.contentAttributeSet = attributeSet   // 新添加的这一行\n  return activity\n}\n{% endcodeblock %}  \n\n然后运行程序，搜索结果如下：\n![](/images/2015.12.27.05.png)   \n\n但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：\n\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n  let objectId: String\n  // 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId\n  if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n    objectId = activityObjectId\n  }\n  // 获取对应Employee实例 然后跳转到对应的界面\n  if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n    nav.popToRootViewControllerAnimated(false)\n    let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n    employeeViewController.employee = employee\n    nav.pushViewController(employeeViewController, animated: false)\n    return true\n  }\n  return false\n}   \n{% endcodeblock %}\n这时候我们再点击搜索结果就能够跳转到对应的详细界面了。\n\n### CoreSpotlight\n下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：\n\n{% codeblock lang:swift %}\n// 在前面的代码中已经设置过了\nattributeSet.relatedUniqueIdentifier = objectId\n{% endcodeblock %}\n这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   \n\n然后在EmployeeSearch.swift添加如下的代码：\n\n{% codeblock lang:swift %}\n// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用\nvar searchableItem: CSSearchableItem {\n  let item = CSSearchableItem(uniqueIdentifier: objectId, domainIdentifier: Employee.domainIdentifier, attributeSet: attributeSet)\n  return item\n}\n{% endcodeblock %}   \n\n然后在EmployeeService.swift添加如下代码：  \n\n{% codeblock lang:swift %}   \nimport CoreSpotlight\n\n..............<省略一部分代码>\n\npublic func indexAllEmployees() {\n  let employees = fetchEmployees()\n  let searchableItems = employees.map{ $0.searchableItem }\n  // 将我们需要被索引的item放入到defaultSearchableIndex中\n  CSSearchableIndex.defaultSearchableIndex().indexSearchableItems(searchableItems) { (error) -> Void in\n    if let error = error {\n      print(\"Error indexing employees: \\(error)\")\n    } else {\n      print(\"Employees indexed.\")\n    }\n  }\n}\n{% endcodeblock %}   \n然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：\n![](/images/2015.12.27.06.png)\n\n但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：\n{% codeblock lang:swift %}\nfunc application(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: ([AnyObject]?) -> Void) -> Bool {\n    let objectId: String\n    if userActivity.activityType == Employee.domainIdentifier, let activityObjectId = userActivity.userInfo?[\"id\"] as? String {\n      objectId = activityObjectId\n    }\n    // 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   \n    // CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值\n    else if userActivity.activityType == CSSearchableItemActionType, let activityObjectId = userActivity.userInfo?[CSSearchableItemActivityIdentifier] as? String {\n      objectId = activityObjectId\n    } else {\n      return false\n    }\n    if let nav = window?.rootViewController as? UINavigationController, listVC = nav.viewControllers.first as? EmployeeListViewController, employee = EmployeeService().employeeWithObjectId(objectId) {\n      nav.popToRootViewControllerAnimated(false)\n      let employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(\"EmployeeView\") as! EmployeeViewController\n      employeeViewController.employee = employee\n      nav.pushViewController(employeeViewController, animated: false)\n      return true\n    }\n    return false\n  }\n{% endcodeblock %}   \n这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   \n\n### 删除Item\n最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：\n{% codeblock lang:swift %}\npublic func destroyEmployeeIndexing() {\n  CSSearchableIndex.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler { (error) -> Void in\n    if let error = error {\n      print(\"Error deleting searching employee items: \\(error)\")\n    } else {\n      print(\"Employees indexing deleted.\")\n    }\n  }\n}\n{% endcodeblock %}\n这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   \n\n另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:[CoreSpotlight.framework注释翻译](http://blog.csdn.net/mengxiangyue/article/details/46575977)\n","slug":"iOS9-by-Tutorials-学习笔记二：App-Search","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0s000j3is6zzaf3in1","content":"<blockquote>\n<p>本文为自己读书的一个总结，可能与原书有一定出入  </p>\n</blockquote>\n<p>iOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：</p>\n<ul>\n<li>NSUserActivity</li>\n<li>Core Spotlight</li>\n<li>Web markup</li>\n</ul>\n<p>下面简单的说一下我对于这三个API的理解：</p>\n<ol>\n<li>NSUserActivity:<br>NSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   </li>\n<li>Core Spotlight:<br>这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    </li>\n<li>Web markup:<br>Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。</li>\n</ol>\n<a id=\"more\"></a>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：<br><img src=\"/images/2015.12.27.01.png\" alt=\"\">    </p>\n<p>下面是这个工程的截图：<br><img src=\"/images/2015.12.27.02.png\" alt=\"\">    </p>\n<p>下面是图中标注的几个关键类的解释：</p>\n<ol>\n<li>AppDelegate<br>点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    </li>\n<li>EmployeeViewController<br>人员的详细界面，这个里面主要设置NSUserActivity    </li>\n<li>EmployeeService<br>这个主要是写CoreSpotlight中index相关的东西    </li>\n<li>EmployeeSearch<br>主要是扩展了Employee类，添加了与搜索相关的属性<br>另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    </li>\n</ol>\n<p>在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  </p>\n<ul>\n<li>Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容</li>\n<li>ViewedRecords 只有打开过的才能够被搜索到  </li>\n<li>AllRecords 所有的员工信息都能够被搜索到   </li>\n</ul>\n<h4 id=\"搜索我们已经打开过的内容\"><a href=\"#搜索我们已经打开过的内容\" class=\"headerlink\" title=\"搜索我们已经打开过的内容\"></a>搜索我们已经打开过的内容</h4><p>使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：</p>\n<ol>\n<li>创建NSUserActivity的一个实例，设置相关的属性</li>\n<li>赋值给UIViewController的userActivity属性   </li>\n</ol>\n<p>下面我们在EmployeeSearch中添加如下代码：  </p>\n<blockquote>\n<p>如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   </p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> CoreSpotlight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> domainIdentifier = <span class=\"string\">\"com.mengxiangyue.colleagues.employee\"</span></span><br><span class=\"line\">  <span class=\"comment\">// 字典 在处理点击的时候，可以根据该字典获取我们想要的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivityUserInfo: [<span class=\"type\">NSObject</span>: <span class=\"type\">AnyObject</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">\"id\"</span>: objectId]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 给Employee添加userActivity属性，主要是方便我们获取userActivity</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivity: <span class=\"type\">NSUserActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> activity = <span class=\"type\">NSUserActivity</span>(activityType: <span class=\"type\">Employee</span>.domainIdentifier)</span><br><span class=\"line\">    activity.title = name  <span class=\"comment\">// 显示的名字</span></span><br><span class=\"line\">    activity.userInfo = userActivityUserInfo  <span class=\"comment\">// 与该Activity相关的数据</span></span><br><span class=\"line\">    activity.keywords = [email, department]  <span class=\"comment\">// 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>这里扩展了Employee，然后添加了几个属性，属性的意义见注释。<br>这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   </p>\n<p>下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> activity = employee.userActivity</span><br><span class=\"line\"><span class=\"keyword\">switch</span> <span class=\"type\">Setting</span>.searchIndexingPreference &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">Disabled</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">ViewedRecords</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复</span></span><br><span class=\"line\">  activity.contentAttributeSet?.relatedUniqueIdentifier = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">AllRecords</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">userActivity = activity</span><br></pre></td></tr></table></figure>   </p>\n<p>下面在该类中添加如下的方法，用于在合适的时机更新Activity：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新NSUserActivity关联的信息</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateUserActivityState</span><span class=\"params\">(activity: NSUserActivity)</span></span> &#123;</span><br><span class=\"line\">    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：<br><img src=\"/images/2015.12.27.03.png\" alt=\"\">   </p>\n<p>看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：<br><img src=\"/images/2015.12.27.04.png\" alt=\"\">   </p>\n<p>下面我们在EmployeeSearch.swift添加如下属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> attributeSet: <span class=\"type\">CSSearchableItemAttributeSet</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> attributeSet = <span class=\"type\">CSSearchableItemAttributeSet</span>(itemContentType: kUTTypeContact <span class=\"keyword\">as</span> <span class=\"type\">String</span>)</span><br><span class=\"line\">  attributeSet.title = name  <span class=\"comment\">// 不太清楚是干啥的</span></span><br><span class=\"line\">  attributeSet.contentDescription = <span class=\"string\">\"\\(department), \\(title)\\n\\(phone)\"</span></span><br><span class=\"line\">  attributeSet.thumbnailData = <span class=\"type\">UIImageJPEGRepresentation</span>(loadPicture(), <span class=\"number\">0.9</span>)</span><br><span class=\"line\">  attributeSet.supportsPhoneCall = <span class=\"literal\">true</span></span><br><span class=\"line\">  attributeSet.phoneNumbers = [phone]</span><br><span class=\"line\">  attributeSet.emailAddresses = [email]</span><br><span class=\"line\">  attributeSet.keywords = skills</span><br><span class=\"line\">  attributeSet.relatedUniqueIdentifier = objectId  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> attributeSet</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>然后将给userActivity添加如下属性：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivity: <span class=\"type\">NSUserActivity</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> activity = <span class=\"type\">NSUserActivity</span>(activityType: <span class=\"type\">Employee</span>.domainIdentifier)</span><br><span class=\"line\">  activity.title = name</span><br><span class=\"line\">  activity.userInfo = userActivityUserInfo</span><br><span class=\"line\">  activity.keywords = [email, department]</span><br><span class=\"line\">  activity.contentAttributeSet = attributeSet   <span class=\"comment\">// 新添加的这一行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> activity</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>然后运行程序，搜索结果如下：<br><img src=\"/images/2015.12.27.05.png\" alt=\"\">   </p>\n<p>但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objectId: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"comment\">// 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">Employee</span>.domainIdentifier, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"string\">\"id\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    objectId = activityObjectId</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对应Employee实例 然后跳转到对应的界面</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> nav = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span>, listVC = nav.viewControllers.first <span class=\"keyword\">as</span>? <span class=\"type\">EmployeeListViewController</span>, employee = <span class=\"type\">EmployeeService</span>().employeeWithObjectId(objectId) &#123;</span><br><span class=\"line\">    nav.popToRootViewControllerAnimated(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class=\"string\">\"EmployeeView\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">EmployeeViewController</span></span><br><span class=\"line\">    employeeViewController.employee = employee</span><br><span class=\"line\">    nav.pushViewController(employeeViewController, animated: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>这时候我们再点击搜索结果就能够跳转到对应的详细界面了。</p>\n<h3 id=\"CoreSpotlight\"><a href=\"#CoreSpotlight\" class=\"headerlink\" title=\"CoreSpotlight\"></a>CoreSpotlight</h3><p>下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在前面的代码中已经设置过了</span></span><br><span class=\"line\">attributeSet.relatedUniqueIdentifier = objectId</span><br></pre></td></tr></table></figure>\n<p>这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   </p>\n<p>然后在EmployeeSearch.swift添加如下的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> searchableItem: <span class=\"type\">CSSearchableItem</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> item = <span class=\"type\">CSSearchableItem</span>(uniqueIdentifier: objectId, domainIdentifier: <span class=\"type\">Employee</span>.domainIdentifier, attributeSet: attributeSet)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>然后在EmployeeService.swift添加如下代码：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">import</span> CoreSpotlight</span><br><span class=\"line\"></span><br><span class=\"line\">..............&lt;省略一部分代码&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexAllEmployees</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> employees = fetchEmployees()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> searchableItems = employees.<span class=\"built_in\">map</span>&#123; $<span class=\"number\">0</span>.searchableItem &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将我们需要被索引的item放入到defaultSearchableIndex中</span></span><br><span class=\"line\">  <span class=\"type\">CSSearchableIndex</span>.defaultSearchableIndex().indexSearchableItems(searchableItems) &#123; (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Error indexing employees: \\(error)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Employees indexed.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：<br><img src=\"/images/2015.12.27.06.png\" alt=\"\"></p>\n<p>但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objectId: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">Employee</span>.domainIdentifier, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"string\">\"id\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      objectId = activityObjectId</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   </span></span><br><span class=\"line\">    <span class=\"comment\">// CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">CSSearchableItemActionType</span>, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"type\">CSSearchableItemActivityIdentifier</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      objectId = activityObjectId</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> nav = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span>, listVC = nav.viewControllers.first <span class=\"keyword\">as</span>? <span class=\"type\">EmployeeListViewController</span>, employee = <span class=\"type\">EmployeeService</span>().employeeWithObjectId(objectId) &#123;</span><br><span class=\"line\">      nav.popToRootViewControllerAnimated(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class=\"string\">\"EmployeeView\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">EmployeeViewController</span></span><br><span class=\"line\">      employeeViewController.employee = employee</span><br><span class=\"line\">      nav.pushViewController(employeeViewController, animated: <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   </p>\n<h3 id=\"删除Item\"><a href=\"#删除Item\" class=\"headerlink\" title=\"删除Item\"></a>删除Item</h3><p>最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">destroyEmployeeIndexing</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"type\">CSSearchableIndex</span>.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler &#123; (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Error deleting searching employee items: \\(error)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Employees indexing deleted.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   </p>\n<p>另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:<a href=\"http://blog.csdn.net/mengxiangyue/article/details/46575977\" target=\"_blank\" rel=\"external\">CoreSpotlight.framework注释翻译</a></p>\n","excerpt":"<blockquote>\n<p>本文为自己读书的一个总结，可能与原书有一定出入  </p>\n</blockquote>\n<p>iOS 9推出了搜索技术，能够让用户在Spotlight中搜索到APP内部的内容。苹果提供了三个APP Search API：</p>\n<ul>\n<li>NSUserActivity</li>\n<li>Core Spotlight</li>\n<li>Web markup</li>\n</ul>\n<p>下面简单的说一下我对于这三个API的理解：</p>\n<ol>\n<li>NSUserActivity:<br>NSUserActivity在iOS8就已经提出来了，只是那时候提出来是用作HandOff。在iOS9中它可以用来搜索App中的内容。我们可以把一些想要在Spotlight中被搜到的东西，放到NSUserActivity中，然后就能在Spotlight中被搜到，但是这个有一点限制，就是只能搜索用户访问过得内容。因为UIViewController的userActivity属性继承自UIResponser，只有在UIViewcontroller访问的时候，才有机会设置userActivity属性。   </li>\n<li>Core Spotlight:<br>这个是在iOS9新推出的技术，能够将APP的内容在Spotlight中被搜索到。这个技术我理解：苹果给开发者提供了一个全局的index数据库，我们能够把我们想要能够在Spotlight中搜索的内容，按照苹果的要求放到数据库中，然后苹果就做了其他的事情，让其能够被搜索到。同样我们也可以删除我们存储到数据库中的内容。    </li>\n<li>Web markup:<br>Web Markup在网页上显示App的内容并编入Spotlight索引，如此一来即便没有安装某个App，苹果的索引器也能在网页上搜索特别的标记（markup），在Safari或Spotlight上显示搜索结果。具体会在下一篇文章中详细介绍。</li>\n</ol>","more":"<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>下面开始试验一下相关的技术，这里还是利用书中的star工程。现在这个工程运行后，就两个界面：<br><img src=\"/images/2015.12.27.01.png\" alt=\"\">    </p>\n<p>下面是这个工程的截图：<br><img src=\"/images/2015.12.27.02.png\" alt=\"\">    </p>\n<p>下面是图中标注的几个关键类的解释：</p>\n<ol>\n<li>AppDelegate<br>点击搜索结果跳跳转到程序中，会先在这个类里面做一定的处理    </li>\n<li>EmployeeViewController<br>人员的详细界面，这个里面主要设置NSUserActivity    </li>\n<li>EmployeeService<br>这个主要是写CoreSpotlight中index相关的东西    </li>\n<li>EmployeeSearch<br>主要是扩展了Employee类，添加了与搜索相关的属性<br>另外工程中有员工相关的一些操作都封装在了一个EmployeeKit的target，由于跟主target不在一个module，所以在主target中需要import。    </li>\n</ol>\n<p>在Iphone的Setting/Colleagues/Indexing中有如下三个选项：  </p>\n<ul>\n<li>Disabled 不使用Search API，即不能在Spotlight中搜索到APP中的内容</li>\n<li>ViewedRecords 只有打开过的才能够被搜索到  </li>\n<li>AllRecords 所有的员工信息都能够被搜索到   </li>\n</ul>\n<h4 id=\"搜索我们已经打开过的内容\"><a href=\"#搜索我们已经打开过的内容\" class=\"headerlink\" title=\"搜索我们已经打开过的内容\"></a>搜索我们已经打开过的内容</h4><p>使用NSUserActivity实现这个比较简单，只要两个步骤就可以了：</p>\n<ol>\n<li>创建NSUserActivity的一个实例，设置相关的属性</li>\n<li>赋值给UIViewController的userActivity属性   </li>\n</ol>\n<p>下面我们在EmployeeSearch中添加如下代码：  </p>\n<blockquote>\n<p>如果没有该文件，需要手动创建一个，然后target选择EmployeeKit   </p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> CoreSpotlight</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这个用于区分Activity，会在点击搜索结果进入APP，相关处理的时候用到，同样也可以在CoreSpotlight中使用到，对于添加、删除index数据的时候都会用到</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> domainIdentifier = <span class=\"string\">\"com.mengxiangyue.colleagues.employee\"</span></span><br><span class=\"line\">  <span class=\"comment\">// 字典 在处理点击的时候，可以根据该字典获取我们想要的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivityUserInfo: [<span class=\"type\">NSObject</span>: <span class=\"type\">AnyObject</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"string\">\"id\"</span>: objectId]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 给Employee添加userActivity属性，主要是方便我们获取userActivity</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivity: <span class=\"type\">NSUserActivity</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> activity = <span class=\"type\">NSUserActivity</span>(activityType: <span class=\"type\">Employee</span>.domainIdentifier)</span><br><span class=\"line\">    activity.title = name  <span class=\"comment\">// 显示的名字</span></span><br><span class=\"line\">    activity.userInfo = userActivityUserInfo  <span class=\"comment\">// 与该Activity相关的数据</span></span><br><span class=\"line\">    activity.keywords = [email, department]  <span class=\"comment\">// 关键字 表示搜索什么关键字，能够搜索出来该条记录，当然这个只是补充，这里没有添加name，同样也是可以按照name搜索</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> activity</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>这里扩展了Employee，然后添加了几个属性，属性的意义见注释。<br>这时候我们需要重新编译一下EmployeeKit（因为与主target不是同一个target）。   </p>\n<p>下面打开EmployeeViewController.swift，在viewDidLoad()中添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> activity = employee.userActivity</span><br><span class=\"line\"><span class=\"keyword\">switch</span> <span class=\"type\">Setting</span>.searchIndexingPreference &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">Disabled</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">ViewedRecords</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\">// relatedUniqueIdentifier 定义一个id 防止NSUserActivity和Core Spotlight重复索引，这里设置为nil，显示一下会重复</span></span><br><span class=\"line\">  activity.contentAttributeSet?.relatedUniqueIdentifier = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">case</span> .<span class=\"type\">AllRecords</span>:</span><br><span class=\"line\">  activity.eligibleForSearch = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">userActivity = activity</span><br></pre></td></tr></table></figure>   </p>\n<p>下面在该类中添加如下的方法，用于在合适的时机更新Activity：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 更新NSUserActivity关联的信息</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateUserActivityState</span><span class=\"params\">(activity: NSUserActivity)</span></span> &#123;</span><br><span class=\"line\">    activity.addUserInfoEntriesFromDictionary(employee.userActivityUserInfo)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>下面在Iphone的Setting/Colleagues/Indexing中选择ViewedRecords。然后启动APP，在列表中点击Brent Reid进入详细页面，然后使用Command+shift+H，计入Home页面，下拉出现搜索框，然后输入brent出现如下界面：<br><img src=\"/images/2015.12.27.03.png\" alt=\"\">   </p>\n<p>看到这个搜索结果界面，感觉太难看了，下面我们丰富一下这个搜索结果，苹果提供的搜索结果可以设置如下的内容：<br><img src=\"/images/2015.12.27.04.png\" alt=\"\">   </p>\n<p>下面我们在EmployeeSearch.swift添加如下属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> attributeSet: <span class=\"type\">CSSearchableItemAttributeSet</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> attributeSet = <span class=\"type\">CSSearchableItemAttributeSet</span>(itemContentType: kUTTypeContact <span class=\"keyword\">as</span> <span class=\"type\">String</span>)</span><br><span class=\"line\">  attributeSet.title = name  <span class=\"comment\">// 不太清楚是干啥的</span></span><br><span class=\"line\">  attributeSet.contentDescription = <span class=\"string\">\"\\(department), \\(title)\\n\\(phone)\"</span></span><br><span class=\"line\">  attributeSet.thumbnailData = <span class=\"type\">UIImageJPEGRepresentation</span>(loadPicture(), <span class=\"number\">0.9</span>)</span><br><span class=\"line\">  attributeSet.supportsPhoneCall = <span class=\"literal\">true</span></span><br><span class=\"line\">  attributeSet.phoneNumbers = [phone]</span><br><span class=\"line\">  attributeSet.emailAddresses = [email]</span><br><span class=\"line\">  attributeSet.keywords = skills</span><br><span class=\"line\">  attributeSet.relatedUniqueIdentifier = objectId  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> attributeSet</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>然后将给userActivity添加如下属性：   </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">var</span> userActivity: <span class=\"type\">NSUserActivity</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> activity = <span class=\"type\">NSUserActivity</span>(activityType: <span class=\"type\">Employee</span>.domainIdentifier)</span><br><span class=\"line\">  activity.title = name</span><br><span class=\"line\">  activity.userInfo = userActivityUserInfo</span><br><span class=\"line\">  activity.keywords = [email, department]</span><br><span class=\"line\">  activity.contentAttributeSet = attributeSet   <span class=\"comment\">// 新添加的这一行</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> activity</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  \n<p>然后运行程序，搜索结果如下：<br><img src=\"/images/2015.12.27.05.png\" alt=\"\">   </p>\n<p>但是现在我们注意到，我们点击搜索结果，打开APP并没有按照我们预想的跳转到该员工的详细界面。这个因为我们在程序中没有做对应的处理，下面我们在AppDelete中添加如下的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> objectId: <span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"comment\">// 先判断了一个type是不是我们自己定义的 然后获取到对应的EmployeeId</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">Employee</span>.domainIdentifier, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"string\">\"id\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    objectId = activityObjectId</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 获取对应Employee实例 然后跳转到对应的界面</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> nav = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span>, listVC = nav.viewControllers.first <span class=\"keyword\">as</span>? <span class=\"type\">EmployeeListViewController</span>, employee = <span class=\"type\">EmployeeService</span>().employeeWithObjectId(objectId) &#123;</span><br><span class=\"line\">    nav.popToRootViewControllerAnimated(<span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class=\"string\">\"EmployeeView\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">EmployeeViewController</span></span><br><span class=\"line\">    employeeViewController.employee = employee</span><br><span class=\"line\">    nav.pushViewController(employeeViewController, animated: <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<p>这时候我们再点击搜索结果就能够跳转到对应的详细界面了。</p>\n<h3 id=\"CoreSpotlight\"><a href=\"#CoreSpotlight\" class=\"headerlink\" title=\"CoreSpotlight\"></a>CoreSpotlight</h3><p>下面我们开始使用CoreSpotlight添加这些搜索内容。首先在EmployeeSearch.swift的attributeSet中设置如下属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在前面的代码中已经设置过了</span></span><br><span class=\"line\">attributeSet.relatedUniqueIdentifier = objectId</span><br></pre></td></tr></table></figure>\n<p>这个属性主要是将NSUserActivity与Core Spotlight indexed object进行一个关联，防止出现重复的内容（如果出现重复内容，是因为开始的时候测试NSUserActivity的时候没有设置id，还原一下模拟器就好了）   </p>\n<p>然后在EmployeeSearch.swift添加如下的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CoreSpotlight需要将一个个item放入其索引数据库中，这里创建一个方便使用</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> searchableItem: <span class=\"type\">CSSearchableItem</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> item = <span class=\"type\">CSSearchableItem</span>(uniqueIdentifier: objectId, domainIdentifier: <span class=\"type\">Employee</span>.domainIdentifier, attributeSet: attributeSet)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>然后在EmployeeService.swift添加如下代码：  </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">import</span> CoreSpotlight</span><br><span class=\"line\"></span><br><span class=\"line\">..............&lt;省略一部分代码&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">indexAllEmployees</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> employees = fetchEmployees()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> searchableItems = employees.<span class=\"built_in\">map</span>&#123; $<span class=\"number\">0</span>.searchableItem &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 将我们需要被索引的item放入到defaultSearchableIndex中</span></span><br><span class=\"line\">  <span class=\"type\">CSSearchableIndex</span>.defaultSearchableIndex().indexSearchableItems(searchableItems) &#123; (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Error indexing employees: \\(error)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Employees indexed.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   \n<p>然后在设置中选择AllRecords，这时候启动APP，然后搜索，看到的搜索结果如下：<br><img src=\"/images/2015.12.27.06.png\" alt=\"\"></p>\n<p>但是这时候我们点击搜索结果没有反应，想想应该也能猜到，我们需要在AppDelete中添加代码，最终代码如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(application: UIApplication, continueUserActivity userActivity: NSUserActivity, restorationHandler: <span class=\"params\">([AnyObject]?)</span></span></span> -&gt; <span class=\"type\">Void</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objectId: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">Employee</span>.domainIdentifier, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"string\">\"id\"</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      objectId = activityObjectId</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 这部分else是新添加的 使用不一样的type区分NSUserActivity和CoreSpotlight,然后获取对应的objectId，其他的处理都一样了   </span></span><br><span class=\"line\">    <span class=\"comment\">// CSSearchableItemActivityIdentifier这个是CoreSpotlight提供的一个key值</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> userActivity.activityType == <span class=\"type\">CSSearchableItemActionType</span>, <span class=\"keyword\">let</span> activityObjectId = userActivity.userInfo?[<span class=\"type\">CSSearchableItemActivityIdentifier</span>] <span class=\"keyword\">as</span>? <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">      objectId = activityObjectId</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> nav = window?.rootViewController <span class=\"keyword\">as</span>? <span class=\"type\">UINavigationController</span>, listVC = nav.viewControllers.first <span class=\"keyword\">as</span>? <span class=\"type\">EmployeeListViewController</span>, employee = <span class=\"type\">EmployeeService</span>().employeeWithObjectId(objectId) &#123;</span><br><span class=\"line\">      nav.popToRootViewControllerAnimated(<span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> employeeViewController = listVC.storyboard?.instantiateViewControllerWithIdentifier(<span class=\"string\">\"EmployeeView\"</span>) <span class=\"keyword\">as</span>! <span class=\"type\">EmployeeViewController</span></span><br><span class=\"line\">      employeeViewController.employee = employee</span><br><span class=\"line\">      nav.pushViewController(employeeViewController, animated: <span class=\"literal\">false</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>这时候我们点击搜索结果应该就能够跳转进入对应的人员详情了。   </p>\n<h3 id=\"删除Item\"><a href=\"#删除Item\" class=\"headerlink\" title=\"删除Item\"></a>删除Item</h3><p>最后在简单的说下删除已经索引的Item，修改EmployeeService.swift对应的方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">destroyEmployeeIndexing</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"type\">CSSearchableIndex</span>.defaultSearchableIndex().deleteAllSearchableItemsWithCompletionHandler &#123; (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> error = error &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Error deleting searching employee items: \\(error)\"</span>)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"Employees indexing deleted.\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个方法会在APP启动并且Indxing设置为Disabled的时候调用。   </p>\n<p>另外对于CoreSpotlight中对于Item的操作方式还有好多种，这里我就不一一写出来了，有兴趣的可以看看我翻译的API注释，当然文章可能有点老了，但是基本思想应该没变。地址:<a href=\"http://blog.csdn.net/mengxiangyue/article/details/46575977\">CoreSpotlight.framework注释翻译</a></p>"},{"title":"iOS9 by Tutorials 学习笔记五：Multitasking","date":"2016-01-07T15:10:56.000Z","_content":"\n在WWDC 2015上，苹果推出了multitasking，这个功能允许我们同时运行两个App，比如在看视频的时候，能够同时刷微博，由于是同时运行两个App，对于硬件的要求比较高，目前苹果并没有在所有的设备上面开放这些功能。下面就简单的介绍一下multitasking。\n\n### Getting started\n在书中与本章配套的有一个工程Travelog，打开这个工程，在iPad Air 2模拟器上运行一下。我们切换横竖屏，你能看到类似如下的界面：\n![](/images/2016.01.09/01.png)\n\n<!---more--->\nTravelog App使用了UISpiltViewController来展示左边的列表，点击左边的列表，在右边会显示对应的详细信息。我们会更具这个App介绍一下multitasking的三种模式：\n* Slide Over\n* Split View\n* Picture in Picture, or PIP\n\n\n#### Slide Over\n我们沿着iPad的屏幕右边缘像左边滑动，这时候会浮动出来一个App的列表，点击其中的一个App，会显示如下，这种状态就是Slide Over模式：\n![](/images/2016.01.09/02.png)\n\n在这种状态下，Travelog是不能使用的，只有我们弹出的日历App是可以使用的。\n\n\n#### Split View\n注意一下在日历App左边有一个小的图标，点击那个图标后，Travelog将会和日历App同时显示在iPad的屏幕上，并且同时能够使用，这种状态就是Split View模式：\n![](/images/2016.01.09/03.png)    \n\n\n#### Picture in Picture, or PIP\n这种模式翻译成成中文是画中画，类似于电视上的画中画的功能。一个例子是我们可以在使用FaceTime的时候，同时使用其他的App。FaceTime将会被缩放到一个小的界面中，并且浮动在你使用的App上面。\n\n#### multitasking支持情况\n![](/images/2016.01.09/04.png)   \n\n### 让你的App支持multitasking\n如果你的App慢如如下的条件，那么你的App就能够支持multitasking。\n* 是一个universal app\n* 使用SDK 9.x编译\n* 支持所有的方向\n* 使用launch storyboard   \n\n满足上面四个条件的APP只是能够支持multitasking，并不表示能够完美的适配。   \nTravelog 满足了上面的四个功能，但是它并没有完美的适配。   \n\n#### Orientation and size changes   \n在Split View 模式下面运行 Travelog，旋转iPad为竖屏方向，显示如下：\n![](/images/2016.01.09/05.png)   \n\n这是一个列表界面，能够看到左边有很大的空白，在后面的内容中，我们能够更好的利用这些空白区域。   \n\n旋转屏幕至横屏状态，如下：\n![](/images/2016.01.09/06.png)  \n\n上面的界面也是列表界面，但是master列太窄了。   \n\n打开SplitViewController.swift文件，SplitViewController是UISplitViewController的子类，并且覆写了viewDidlayoutSubviews()， 用来更新主列的最大宽度。这个方法可能不起作用，因为在横屏Split view 模式下也可能出现窄的windown。  \n\nUIKit提供了下面几个方法用于捕获你的layout的变化:   \n1. willTransitionToTraitCollection(\\_:, withTransitionCoordinator:)\n2. viewWillTransitionToSize(\\_:, withTransitionCoordinator:)\n3. traitCollectionDidChange(\\_:):   \n\n下面展示了Size Classes的各种状态：\n![](/images/2016.01.09/07.png)\n\n>上图中 R 代表 Regular 而 C 代表 Compact   \n\n根据上图可以看出，并不是所有的multitasking和方向改变都会触发size class改变，所有你不能仅仅依靠size classes去提供最好的用户体验。我们可以viewWillTransitionToSize这个方法，在size classes改变的时候，做出正确的操作。   \n\n下面实际操作一下，在SplitViewController.swift删除viewDidLayoutSubviews() 和 updateMaximumPrimaryColumnWidth()方法，添加某些方法，最终如下（看注释）：\n{% codeblock lang:swift %}\nimport UIKit\n\nclass SplitViewController: UISplitViewController {\n\n//  需要删除\n//  override func viewDidLayoutSubviews() {\n//    super.viewDidLayoutSubviews()\n//    updateMaximumPrimaryColumnWidth()\n//  }\n\n  override func preferredStatusBarStyle() -> UIStatusBarStyle {\n    return .LightContent\n  }\n\n//  需要删除\n//  // MARK: Helper\n//  \n//  func updateMaximumPrimaryColumnWidth() {\n//    if UIInterfaceOrientationIsPortrait(UIApplication.sharedApplication().statusBarOrientation) {\n//      maximumPrimaryColumnWidth = 170.0\n//    } else {\n//      maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension\n//    }\n//  }\n\n    // 添加的\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateMaximumPrimaryColumnWidthBasedOnSize(view.bounds.size)\n    }\n\n    // 添加的\n    // 这是一个辅助方法 用于设置主列的最大宽度\n    func updateMaximumPrimaryColumnWidthBasedOnSize(size: CGSize) {\n        if size.width < UIScreen.mainScreen().bounds.width || size.width < size.height {\n            maximumPrimaryColumnWidth = 170.0\n        } else {\n            maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension\n        }\n    }\n\n    // 添加的\n    override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) {\n        super.viewWillTransitionToSize(size,withTransitionCoordinator: coordinator)\n        updateMaximumPrimaryColumnWidthBasedOnSize(size)\n\n    }\n\n}\n{% endcodeblock %}   \n\n运行程序app最终效果如下，能够看出来app的主列的宽度体验更好一点了。\n![](/images/2016.01.09/08.png)    \n\n仔细看一下没行的内容，能够看到我们行上的内容，还是有问题的。应该是我们的cell没有响应size的变化。打开LogCell.swift找到layoutSubviews()的实现，能够发现代码检查的是UIScreen.mainScreen().bounds.width，再决定cell是使用Compact view还是regular view。 UIScreen代表整个屏幕，不去理会multitasking的状态。你不能再依赖屏幕尺寸来判断了。更新如下代码：\n{% codeblock lang:swift %}\n// 修改\n  static let widthThreshold: CGFloat = 180.0\n......\noverride func layoutSubviews() {\n   super.layoutSubviews()\n   // 修改\n//    let isTooNarrow = UIScreen.mainScreen().bounds.width < LogCell.widthThreshold\n   let isTooNarrow = bounds.width <= LogCell.widthThreshold\n   compactView.hidden = !isTooNarrow\n   regularView.hidden = isTooNarrow\n }\n{% endcodeblock %}\n\n修改后运行效果如下：\n![](/images/2016.01.09/09.png)\n\n### Adaptive presentation\n在如下状态下面点击 Photo Library bar button，能够看到如下效果：\n![](/images/2016.01.09/10.png)\n\n在上图状态下拖动中间的标志，使APP为5：5模式，效果如下：\n![](/images/2016.01.09/11.png)   \n\n能够注意到，我们没有做任何改变，但是我们从33%变成50%的时候，弹出的模态菜单变成了整个页面。这个效果是由UIPopoverPresentationController控制的，而我们想要的效果是是只有APP在Slide Over模式或者作为第二APP并且在33%的时候才会使用popover。我们可以设置UIPopoverPresentationController的delegate来实现我们的行为。   \n\n打开LogsViewController.swift，添加如下代码：\n{% codeblock lang:swift %}\nextension LogsViewController: UIPopoverPresentationControllerDelegate {\n\n    func adaptivePresentationStyleForPresentationController( controller: UIPresentationController,traitCollection: UITraitCollection) -> UIModalPresentationStyle {\n\n        //1 判断是iPad\n        guard traitCollection.userInterfaceIdiom == .Pad else {\n            return .FullScreen\n        }\n\n        // 宽度大于320使用popover\n        if splitViewController?.view.bounds.width > 320 {\n            return .None\n        } else {\n            return .FullScreen\n        }\n    }\n\n}\n{% endcodeblock %}  \n\n下面找到如下方法设置代理：\n{% codeblock lang:swift %}\nfunc presentImagePickerControllerWithSourceType(sourceType: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = sourceType\n    controller.mediaTypes = [String(kUTTypeImage), String(kUTTypeMovie)]\n    controller.view.tintColor = UIColor.themeTineColor()\n    if sourceType == UIImagePickerControllerSourceType.PhotoLibrary {\n      controller.modalPresentationStyle = .Popover\n      let presenter = controller.popoverPresentationController\n      presenter?.sourceView = view\n      presenter?.barButtonItem = photoLibraryButton\n      presenter?.delegate = self // 添加\n    }\n    presentViewController(controller, animated: true, completion: nil)\n  }\n{% endcodeblock %}\n\n最终运行的效果如下：\n![](/images/2016.01.09/12.png)\n\n算是完成了这一篇笔记吧，可能跟书中不完全一样，感觉这篇文章只是简单介绍了一下，如果想更多了解请查看：[苹果文档](https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/index.html#//apple_ref/doc/uid/TP40015145-CH3-SW1)\n","source":"_posts/iOS9-by-Tutorials-学习笔记五：Multitasking.md","raw":"title: iOS9 by Tutorials 学习笔记五：Multitasking\ndate: 2016-01-07 23:10:56\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n在WWDC 2015上，苹果推出了multitasking，这个功能允许我们同时运行两个App，比如在看视频的时候，能够同时刷微博，由于是同时运行两个App，对于硬件的要求比较高，目前苹果并没有在所有的设备上面开放这些功能。下面就简单的介绍一下multitasking。\n\n### Getting started\n在书中与本章配套的有一个工程Travelog，打开这个工程，在iPad Air 2模拟器上运行一下。我们切换横竖屏，你能看到类似如下的界面：\n![](/images/2016.01.09/01.png)\n\n<!---more--->\nTravelog App使用了UISpiltViewController来展示左边的列表，点击左边的列表，在右边会显示对应的详细信息。我们会更具这个App介绍一下multitasking的三种模式：\n* Slide Over\n* Split View\n* Picture in Picture, or PIP\n\n\n#### Slide Over\n我们沿着iPad的屏幕右边缘像左边滑动，这时候会浮动出来一个App的列表，点击其中的一个App，会显示如下，这种状态就是Slide Over模式：\n![](/images/2016.01.09/02.png)\n\n在这种状态下，Travelog是不能使用的，只有我们弹出的日历App是可以使用的。\n\n\n#### Split View\n注意一下在日历App左边有一个小的图标，点击那个图标后，Travelog将会和日历App同时显示在iPad的屏幕上，并且同时能够使用，这种状态就是Split View模式：\n![](/images/2016.01.09/03.png)    \n\n\n#### Picture in Picture, or PIP\n这种模式翻译成成中文是画中画，类似于电视上的画中画的功能。一个例子是我们可以在使用FaceTime的时候，同时使用其他的App。FaceTime将会被缩放到一个小的界面中，并且浮动在你使用的App上面。\n\n#### multitasking支持情况\n![](/images/2016.01.09/04.png)   \n\n### 让你的App支持multitasking\n如果你的App慢如如下的条件，那么你的App就能够支持multitasking。\n* 是一个universal app\n* 使用SDK 9.x编译\n* 支持所有的方向\n* 使用launch storyboard   \n\n满足上面四个条件的APP只是能够支持multitasking，并不表示能够完美的适配。   \nTravelog 满足了上面的四个功能，但是它并没有完美的适配。   \n\n#### Orientation and size changes   \n在Split View 模式下面运行 Travelog，旋转iPad为竖屏方向，显示如下：\n![](/images/2016.01.09/05.png)   \n\n这是一个列表界面，能够看到左边有很大的空白，在后面的内容中，我们能够更好的利用这些空白区域。   \n\n旋转屏幕至横屏状态，如下：\n![](/images/2016.01.09/06.png)  \n\n上面的界面也是列表界面，但是master列太窄了。   \n\n打开SplitViewController.swift文件，SplitViewController是UISplitViewController的子类，并且覆写了viewDidlayoutSubviews()， 用来更新主列的最大宽度。这个方法可能不起作用，因为在横屏Split view 模式下也可能出现窄的windown。  \n\nUIKit提供了下面几个方法用于捕获你的layout的变化:   \n1. willTransitionToTraitCollection(\\_:, withTransitionCoordinator:)\n2. viewWillTransitionToSize(\\_:, withTransitionCoordinator:)\n3. traitCollectionDidChange(\\_:):   \n\n下面展示了Size Classes的各种状态：\n![](/images/2016.01.09/07.png)\n\n>上图中 R 代表 Regular 而 C 代表 Compact   \n\n根据上图可以看出，并不是所有的multitasking和方向改变都会触发size class改变，所有你不能仅仅依靠size classes去提供最好的用户体验。我们可以viewWillTransitionToSize这个方法，在size classes改变的时候，做出正确的操作。   \n\n下面实际操作一下，在SplitViewController.swift删除viewDidLayoutSubviews() 和 updateMaximumPrimaryColumnWidth()方法，添加某些方法，最终如下（看注释）：\n{% codeblock lang:swift %}\nimport UIKit\n\nclass SplitViewController: UISplitViewController {\n\n//  需要删除\n//  override func viewDidLayoutSubviews() {\n//    super.viewDidLayoutSubviews()\n//    updateMaximumPrimaryColumnWidth()\n//  }\n\n  override func preferredStatusBarStyle() -> UIStatusBarStyle {\n    return .LightContent\n  }\n\n//  需要删除\n//  // MARK: Helper\n//  \n//  func updateMaximumPrimaryColumnWidth() {\n//    if UIInterfaceOrientationIsPortrait(UIApplication.sharedApplication().statusBarOrientation) {\n//      maximumPrimaryColumnWidth = 170.0\n//    } else {\n//      maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension\n//    }\n//  }\n\n    // 添加的\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateMaximumPrimaryColumnWidthBasedOnSize(view.bounds.size)\n    }\n\n    // 添加的\n    // 这是一个辅助方法 用于设置主列的最大宽度\n    func updateMaximumPrimaryColumnWidthBasedOnSize(size: CGSize) {\n        if size.width < UIScreen.mainScreen().bounds.width || size.width < size.height {\n            maximumPrimaryColumnWidth = 170.0\n        } else {\n            maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension\n        }\n    }\n\n    // 添加的\n    override func viewWillTransitionToSize(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator) {\n        super.viewWillTransitionToSize(size,withTransitionCoordinator: coordinator)\n        updateMaximumPrimaryColumnWidthBasedOnSize(size)\n\n    }\n\n}\n{% endcodeblock %}   \n\n运行程序app最终效果如下，能够看出来app的主列的宽度体验更好一点了。\n![](/images/2016.01.09/08.png)    \n\n仔细看一下没行的内容，能够看到我们行上的内容，还是有问题的。应该是我们的cell没有响应size的变化。打开LogCell.swift找到layoutSubviews()的实现，能够发现代码检查的是UIScreen.mainScreen().bounds.width，再决定cell是使用Compact view还是regular view。 UIScreen代表整个屏幕，不去理会multitasking的状态。你不能再依赖屏幕尺寸来判断了。更新如下代码：\n{% codeblock lang:swift %}\n// 修改\n  static let widthThreshold: CGFloat = 180.0\n......\noverride func layoutSubviews() {\n   super.layoutSubviews()\n   // 修改\n//    let isTooNarrow = UIScreen.mainScreen().bounds.width < LogCell.widthThreshold\n   let isTooNarrow = bounds.width <= LogCell.widthThreshold\n   compactView.hidden = !isTooNarrow\n   regularView.hidden = isTooNarrow\n }\n{% endcodeblock %}\n\n修改后运行效果如下：\n![](/images/2016.01.09/09.png)\n\n### Adaptive presentation\n在如下状态下面点击 Photo Library bar button，能够看到如下效果：\n![](/images/2016.01.09/10.png)\n\n在上图状态下拖动中间的标志，使APP为5：5模式，效果如下：\n![](/images/2016.01.09/11.png)   \n\n能够注意到，我们没有做任何改变，但是我们从33%变成50%的时候，弹出的模态菜单变成了整个页面。这个效果是由UIPopoverPresentationController控制的，而我们想要的效果是是只有APP在Slide Over模式或者作为第二APP并且在33%的时候才会使用popover。我们可以设置UIPopoverPresentationController的delegate来实现我们的行为。   \n\n打开LogsViewController.swift，添加如下代码：\n{% codeblock lang:swift %}\nextension LogsViewController: UIPopoverPresentationControllerDelegate {\n\n    func adaptivePresentationStyleForPresentationController( controller: UIPresentationController,traitCollection: UITraitCollection) -> UIModalPresentationStyle {\n\n        //1 判断是iPad\n        guard traitCollection.userInterfaceIdiom == .Pad else {\n            return .FullScreen\n        }\n\n        // 宽度大于320使用popover\n        if splitViewController?.view.bounds.width > 320 {\n            return .None\n        } else {\n            return .FullScreen\n        }\n    }\n\n}\n{% endcodeblock %}  \n\n下面找到如下方法设置代理：\n{% codeblock lang:swift %}\nfunc presentImagePickerControllerWithSourceType(sourceType: UIImagePickerControllerSourceType) {\n    let controller = UIImagePickerController()\n    controller.delegate = self\n    controller.sourceType = sourceType\n    controller.mediaTypes = [String(kUTTypeImage), String(kUTTypeMovie)]\n    controller.view.tintColor = UIColor.themeTineColor()\n    if sourceType == UIImagePickerControllerSourceType.PhotoLibrary {\n      controller.modalPresentationStyle = .Popover\n      let presenter = controller.popoverPresentationController\n      presenter?.sourceView = view\n      presenter?.barButtonItem = photoLibraryButton\n      presenter?.delegate = self // 添加\n    }\n    presentViewController(controller, animated: true, completion: nil)\n  }\n{% endcodeblock %}\n\n最终运行的效果如下：\n![](/images/2016.01.09/12.png)\n\n算是完成了这一篇笔记吧，可能跟书中不完全一样，感觉这篇文章只是简单介绍了一下，如果想更多了解请查看：[苹果文档](https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/index.html#//apple_ref/doc/uid/TP40015145-CH3-SW1)\n","slug":"iOS9-by-Tutorials-学习笔记五：Multitasking","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0u000n3is6zyh0moqw","content":"<p>在WWDC 2015上，苹果推出了multitasking，这个功能允许我们同时运行两个App，比如在看视频的时候，能够同时刷微博，由于是同时运行两个App，对于硬件的要求比较高，目前苹果并没有在所有的设备上面开放这些功能。下面就简单的介绍一下multitasking。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>在书中与本章配套的有一个工程Travelog，打开这个工程，在iPad Air 2模拟器上运行一下。我们切换横竖屏，你能看到类似如下的界面：<br><img src=\"/images/2016.01.09/01.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>Travelog App使用了UISpiltViewController来展示左边的列表，点击左边的列表，在右边会显示对应的详细信息。我们会更具这个App介绍一下multitasking的三种模式：</p>\n<ul>\n<li>Slide Over</li>\n<li>Split View</li>\n<li>Picture in Picture, or PIP</li>\n</ul>\n<h4 id=\"Slide-Over\"><a href=\"#Slide-Over\" class=\"headerlink\" title=\"Slide Over\"></a>Slide Over</h4><p>我们沿着iPad的屏幕右边缘像左边滑动，这时候会浮动出来一个App的列表，点击其中的一个App，会显示如下，这种状态就是Slide Over模式：<br><img src=\"/images/2016.01.09/02.png\" alt=\"\"></p>\n<p>在这种状态下，Travelog是不能使用的，只有我们弹出的日历App是可以使用的。</p>\n<h4 id=\"Split-View\"><a href=\"#Split-View\" class=\"headerlink\" title=\"Split View\"></a>Split View</h4><p>注意一下在日历App左边有一个小的图标，点击那个图标后，Travelog将会和日历App同时显示在iPad的屏幕上，并且同时能够使用，这种状态就是Split View模式：<br><img src=\"/images/2016.01.09/03.png\" alt=\"\">    </p>\n<h4 id=\"Picture-in-Picture-or-PIP\"><a href=\"#Picture-in-Picture-or-PIP\" class=\"headerlink\" title=\"Picture in Picture, or PIP\"></a>Picture in Picture, or PIP</h4><p>这种模式翻译成成中文是画中画，类似于电视上的画中画的功能。一个例子是我们可以在使用FaceTime的时候，同时使用其他的App。FaceTime将会被缩放到一个小的界面中，并且浮动在你使用的App上面。</p>\n<h4 id=\"multitasking支持情况\"><a href=\"#multitasking支持情况\" class=\"headerlink\" title=\"multitasking支持情况\"></a>multitasking支持情况</h4><p><img src=\"/images/2016.01.09/04.png\" alt=\"\">   </p>\n<h3 id=\"让你的App支持multitasking\"><a href=\"#让你的App支持multitasking\" class=\"headerlink\" title=\"让你的App支持multitasking\"></a>让你的App支持multitasking</h3><p>如果你的App慢如如下的条件，那么你的App就能够支持multitasking。</p>\n<ul>\n<li>是一个universal app</li>\n<li>使用SDK 9.x编译</li>\n<li>支持所有的方向</li>\n<li>使用launch storyboard   </li>\n</ul>\n<p>满足上面四个条件的APP只是能够支持multitasking，并不表示能够完美的适配。<br>Travelog 满足了上面的四个功能，但是它并没有完美的适配。   </p>\n<h4 id=\"Orientation-and-size-changes\"><a href=\"#Orientation-and-size-changes\" class=\"headerlink\" title=\"Orientation and size changes\"></a>Orientation and size changes</h4><p>在Split View 模式下面运行 Travelog，旋转iPad为竖屏方向，显示如下：<br><img src=\"/images/2016.01.09/05.png\" alt=\"\">   </p>\n<p>这是一个列表界面，能够看到左边有很大的空白，在后面的内容中，我们能够更好的利用这些空白区域。   </p>\n<p>旋转屏幕至横屏状态，如下：<br><img src=\"/images/2016.01.09/06.png\" alt=\"\">  </p>\n<p>上面的界面也是列表界面，但是master列太窄了。   </p>\n<p>打开SplitViewController.swift文件，SplitViewController是UISplitViewController的子类，并且覆写了viewDidlayoutSubviews()， 用来更新主列的最大宽度。这个方法可能不起作用，因为在横屏Split view 模式下也可能出现窄的windown。  </p>\n<p>UIKit提供了下面几个方法用于捕获你的layout的变化:   </p>\n<ol>\n<li>willTransitionToTraitCollection(_:, withTransitionCoordinator:)</li>\n<li>viewWillTransitionToSize(_:, withTransitionCoordinator:)</li>\n<li>traitCollectionDidChange(_:):   </li>\n</ol>\n<p>下面展示了Size Classes的各种状态：<br><img src=\"/images/2016.01.09/07.png\" alt=\"\"></p>\n<blockquote>\n<p>上图中 R 代表 Regular 而 C 代表 Compact   </p>\n</blockquote>\n<p>根据上图可以看出，并不是所有的multitasking和方向改变都会触发size class改变，所有你不能仅仅依靠size classes去提供最好的用户体验。我们可以viewWillTransitionToSize这个方法，在size classes改变的时候，做出正确的操作。   </p>\n<p>下面实际操作一下，在SplitViewController.swift删除viewDidLayoutSubviews() 和 updateMaximumPrimaryColumnWidth()方法，添加某些方法，最终如下（看注释）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplitViewController</span>: <span class=\"title\">UISplitViewController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  需要删除</span></span><br><span class=\"line\"><span class=\"comment\">//  override func viewDidLayoutSubviews() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    super.viewDidLayoutSubviews()</span></span><br><span class=\"line\"><span class=\"comment\">//    updateMaximumPrimaryColumnWidth()</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preferredStatusBarStyle</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> .<span class=\"type\">LightContent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  需要删除</span></span><br><span class=\"line\"><span class=\"comment\">//  // MARK: Helper</span></span><br><span class=\"line\"><span class=\"comment\">//  </span></span><br><span class=\"line\"><span class=\"comment\">//  func updateMaximumPrimaryColumnWidth() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    if UIInterfaceOrientationIsPortrait(UIApplication.sharedApplication().statusBarOrientation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      maximumPrimaryColumnWidth = 170.0</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        updateMaximumPrimaryColumnWidthBasedOnSize(view.bounds.size)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个辅助方法 用于设置主列的最大宽度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateMaximumPrimaryColumnWidthBasedOnSize</span><span class=\"params\">(size: CGSize)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> size.width &lt; <span class=\"type\">UIScreen</span>.mainScreen().bounds.width || size.width &lt; size.height &#123;</span><br><span class=\"line\">            maximumPrimaryColumnWidth = <span class=\"number\">170.0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            maximumPrimaryColumnWidth = <span class=\"type\">UISplitViewControllerAutomaticDimension</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillTransitionToSize</span><span class=\"params\">(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewWillTransitionToSize(size,withTransitionCoordinator: coordinator)</span><br><span class=\"line\">        updateMaximumPrimaryColumnWidthBasedOnSize(size)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>运行程序app最终效果如下，能够看出来app的主列的宽度体验更好一点了。<br><img src=\"/images/2016.01.09/08.png\" alt=\"\">    </p>\n<p>仔细看一下没行的内容，能够看到我们行上的内容，还是有问题的。应该是我们的cell没有响应size的变化。打开LogCell.swift找到layoutSubviews()的实现，能够发现代码检查的是UIScreen.mainScreen().bounds.width，再决定cell是使用Compact view还是regular view。 UIScreen代表整个屏幕，不去理会multitasking的状态。你不能再依赖屏幕尺寸来判断了。更新如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> widthThreshold: <span class=\"type\">CGFloat</span> = <span class=\"number\">180.0</span></span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>.layoutSubviews()</span><br><span class=\"line\">   <span class=\"comment\">// 修改</span></span><br><span class=\"line\"><span class=\"comment\">//    let isTooNarrow = UIScreen.mainScreen().bounds.width &lt; LogCell.widthThreshold</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> isTooNarrow = bounds.width &lt;= <span class=\"type\">LogCell</span>.widthThreshold</span><br><span class=\"line\">   compactView.hidden = !isTooNarrow</span><br><span class=\"line\">   regularView.hidden = isTooNarrow</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改后运行效果如下：<br><img src=\"/images/2016.01.09/09.png\" alt=\"\"></p>\n<h3 id=\"Adaptive-presentation\"><a href=\"#Adaptive-presentation\" class=\"headerlink\" title=\"Adaptive presentation\"></a>Adaptive presentation</h3><p>在如下状态下面点击 Photo Library bar button，能够看到如下效果：<br><img src=\"/images/2016.01.09/10.png\" alt=\"\"></p>\n<p>在上图状态下拖动中间的标志，使APP为5：5模式，效果如下：<br><img src=\"/images/2016.01.09/11.png\" alt=\"\">   </p>\n<p>能够注意到，我们没有做任何改变，但是我们从33%变成50%的时候，弹出的模态菜单变成了整个页面。这个效果是由UIPopoverPresentationController控制的，而我们想要的效果是是只有APP在Slide Over模式或者作为第二APP并且在33%的时候才会使用popover。我们可以设置UIPopoverPresentationController的delegate来实现我们的行为。   </p>\n<p>打开LogsViewController.swift，添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LogsViewController</span>: <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">( controller: UIPresentationController,traitCollection: UITraitCollection)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1 判断是iPad</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> traitCollection.userInterfaceIdiom == .<span class=\"type\">Pad</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">FullScreen</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 宽度大于320使用popover</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> splitViewController?.view.bounds.width &gt; <span class=\"number\">320</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">None</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">FullScreen</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>下面找到如下方法设置代理：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentImagePickerControllerWithSourceType</span><span class=\"params\">(sourceType: UIImagePickerControllerSourceType)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIImagePickerController</span>()</span><br><span class=\"line\">    controller.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    controller.sourceType = sourceType</span><br><span class=\"line\">    controller.mediaTypes = [<span class=\"type\">String</span>(kUTTypeImage), <span class=\"type\">String</span>(kUTTypeMovie)]</span><br><span class=\"line\">    controller.view.tintColor = <span class=\"type\">UIColor</span>.themeTineColor()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sourceType == <span class=\"type\">UIImagePickerControllerSourceType</span>.<span class=\"type\">PhotoLibrary</span> &#123;</span><br><span class=\"line\">      controller.modalPresentationStyle = .<span class=\"type\">Popover</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> presenter = controller.popoverPresentationController</span><br><span class=\"line\">      presenter?.sourceView = view</span><br><span class=\"line\">      presenter?.barButtonItem = photoLibraryButton</span><br><span class=\"line\">      presenter?.delegate = <span class=\"keyword\">self</span> <span class=\"comment\">// 添加</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    presentViewController(controller, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终运行的效果如下：<br><img src=\"/images/2016.01.09/12.png\" alt=\"\"></p>\n<p>算是完成了这一篇笔记吧，可能跟书中不完全一样，感觉这篇文章只是简单介绍了一下，如果想更多了解请查看：<a href=\"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/index.html#//apple_ref/doc/uid/TP40015145-CH3-SW1\" target=\"_blank\" rel=\"external\">苹果文档</a></p>\n","excerpt":"<p>在WWDC 2015上，苹果推出了multitasking，这个功能允许我们同时运行两个App，比如在看视频的时候，能够同时刷微博，由于是同时运行两个App，对于硬件的要求比较高，目前苹果并没有在所有的设备上面开放这些功能。下面就简单的介绍一下multitasking。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>在书中与本章配套的有一个工程Travelog，打开这个工程，在iPad Air 2模拟器上运行一下。我们切换横竖屏，你能看到类似如下的界面：<br><img src=\"/images/2016.01.09/01.png\" alt=\"\"></p>","more":"<p>Travelog App使用了UISpiltViewController来展示左边的列表，点击左边的列表，在右边会显示对应的详细信息。我们会更具这个App介绍一下multitasking的三种模式：</p>\n<ul>\n<li>Slide Over</li>\n<li>Split View</li>\n<li>Picture in Picture, or PIP</li>\n</ul>\n<h4 id=\"Slide-Over\"><a href=\"#Slide-Over\" class=\"headerlink\" title=\"Slide Over\"></a>Slide Over</h4><p>我们沿着iPad的屏幕右边缘像左边滑动，这时候会浮动出来一个App的列表，点击其中的一个App，会显示如下，这种状态就是Slide Over模式：<br><img src=\"/images/2016.01.09/02.png\" alt=\"\"></p>\n<p>在这种状态下，Travelog是不能使用的，只有我们弹出的日历App是可以使用的。</p>\n<h4 id=\"Split-View\"><a href=\"#Split-View\" class=\"headerlink\" title=\"Split View\"></a>Split View</h4><p>注意一下在日历App左边有一个小的图标，点击那个图标后，Travelog将会和日历App同时显示在iPad的屏幕上，并且同时能够使用，这种状态就是Split View模式：<br><img src=\"/images/2016.01.09/03.png\" alt=\"\">    </p>\n<h4 id=\"Picture-in-Picture-or-PIP\"><a href=\"#Picture-in-Picture-or-PIP\" class=\"headerlink\" title=\"Picture in Picture, or PIP\"></a>Picture in Picture, or PIP</h4><p>这种模式翻译成成中文是画中画，类似于电视上的画中画的功能。一个例子是我们可以在使用FaceTime的时候，同时使用其他的App。FaceTime将会被缩放到一个小的界面中，并且浮动在你使用的App上面。</p>\n<h4 id=\"multitasking支持情况\"><a href=\"#multitasking支持情况\" class=\"headerlink\" title=\"multitasking支持情况\"></a>multitasking支持情况</h4><p><img src=\"/images/2016.01.09/04.png\" alt=\"\">   </p>\n<h3 id=\"让你的App支持multitasking\"><a href=\"#让你的App支持multitasking\" class=\"headerlink\" title=\"让你的App支持multitasking\"></a>让你的App支持multitasking</h3><p>如果你的App慢如如下的条件，那么你的App就能够支持multitasking。</p>\n<ul>\n<li>是一个universal app</li>\n<li>使用SDK 9.x编译</li>\n<li>支持所有的方向</li>\n<li>使用launch storyboard   </li>\n</ul>\n<p>满足上面四个条件的APP只是能够支持multitasking，并不表示能够完美的适配。<br>Travelog 满足了上面的四个功能，但是它并没有完美的适配。   </p>\n<h4 id=\"Orientation-and-size-changes\"><a href=\"#Orientation-and-size-changes\" class=\"headerlink\" title=\"Orientation and size changes\"></a>Orientation and size changes</h4><p>在Split View 模式下面运行 Travelog，旋转iPad为竖屏方向，显示如下：<br><img src=\"/images/2016.01.09/05.png\" alt=\"\">   </p>\n<p>这是一个列表界面，能够看到左边有很大的空白，在后面的内容中，我们能够更好的利用这些空白区域。   </p>\n<p>旋转屏幕至横屏状态，如下：<br><img src=\"/images/2016.01.09/06.png\" alt=\"\">  </p>\n<p>上面的界面也是列表界面，但是master列太窄了。   </p>\n<p>打开SplitViewController.swift文件，SplitViewController是UISplitViewController的子类，并且覆写了viewDidlayoutSubviews()， 用来更新主列的最大宽度。这个方法可能不起作用，因为在横屏Split view 模式下也可能出现窄的windown。  </p>\n<p>UIKit提供了下面几个方法用于捕获你的layout的变化:   </p>\n<ol>\n<li>willTransitionToTraitCollection(_:, withTransitionCoordinator:)</li>\n<li>viewWillTransitionToSize(_:, withTransitionCoordinator:)</li>\n<li>traitCollectionDidChange(_:):   </li>\n</ol>\n<p>下面展示了Size Classes的各种状态：<br><img src=\"/images/2016.01.09/07.png\" alt=\"\"></p>\n<blockquote>\n<p>上图中 R 代表 Regular 而 C 代表 Compact   </p>\n</blockquote>\n<p>根据上图可以看出，并不是所有的multitasking和方向改变都会触发size class改变，所有你不能仅仅依靠size classes去提供最好的用户体验。我们可以viewWillTransitionToSize这个方法，在size classes改变的时候，做出正确的操作。   </p>\n<p>下面实际操作一下，在SplitViewController.swift删除viewDidLayoutSubviews() 和 updateMaximumPrimaryColumnWidth()方法，添加某些方法，最终如下（看注释）：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SplitViewController</span>: <span class=\"title\">UISplitViewController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  需要删除</span></span><br><span class=\"line\"><span class=\"comment\">//  override func viewDidLayoutSubviews() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    super.viewDidLayoutSubviews()</span></span><br><span class=\"line\"><span class=\"comment\">//    updateMaximumPrimaryColumnWidth()</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">preferredStatusBarStyle</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">UIStatusBarStyle</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> .<span class=\"type\">LightContent</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  需要删除</span></span><br><span class=\"line\"><span class=\"comment\">//  // MARK: Helper</span></span><br><span class=\"line\"><span class=\"comment\">//  </span></span><br><span class=\"line\"><span class=\"comment\">//  func updateMaximumPrimaryColumnWidth() &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//    if UIInterfaceOrientationIsPortrait(UIApplication.sharedApplication().statusBarOrientation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      maximumPrimaryColumnWidth = 170.0</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//      maximumPrimaryColumnWidth = UISplitViewControllerAutomaticDimension</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//  &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        updateMaximumPrimaryColumnWidthBasedOnSize(view.bounds.size)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"comment\">// 这是一个辅助方法 用于设置主列的最大宽度</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">updateMaximumPrimaryColumnWidthBasedOnSize</span><span class=\"params\">(size: CGSize)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> size.width &lt; <span class=\"type\">UIScreen</span>.mainScreen().bounds.width || size.width &lt; size.height &#123;</span><br><span class=\"line\">            maximumPrimaryColumnWidth = <span class=\"number\">170.0</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            maximumPrimaryColumnWidth = <span class=\"type\">UISplitViewControllerAutomaticDimension</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加的</span></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillTransitionToSize</span><span class=\"params\">(size: CGSize, withTransitionCoordinator coordinator: UIViewControllerTransitionCoordinator)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewWillTransitionToSize(size,withTransitionCoordinator: coordinator)</span><br><span class=\"line\">        updateMaximumPrimaryColumnWidthBasedOnSize(size)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>运行程序app最终效果如下，能够看出来app的主列的宽度体验更好一点了。<br><img src=\"/images/2016.01.09/08.png\" alt=\"\">    </p>\n<p>仔细看一下没行的内容，能够看到我们行上的内容，还是有问题的。应该是我们的cell没有响应size的变化。打开LogCell.swift找到layoutSubviews()的实现，能够发现代码检查的是UIScreen.mainScreen().bounds.width，再决定cell是使用Compact view还是regular view。 UIScreen代表整个屏幕，不去理会multitasking的状态。你不能再依赖屏幕尺寸来判断了。更新如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> widthThreshold: <span class=\"type\">CGFloat</span> = <span class=\"number\">180.0</span></span><br><span class=\"line\">......</span><br><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">super</span>.layoutSubviews()</span><br><span class=\"line\">   <span class=\"comment\">// 修改</span></span><br><span class=\"line\"><span class=\"comment\">//    let isTooNarrow = UIScreen.mainScreen().bounds.width &lt; LogCell.widthThreshold</span></span><br><span class=\"line\">   <span class=\"keyword\">let</span> isTooNarrow = bounds.width &lt;= <span class=\"type\">LogCell</span>.widthThreshold</span><br><span class=\"line\">   compactView.hidden = !isTooNarrow</span><br><span class=\"line\">   regularView.hidden = isTooNarrow</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改后运行效果如下：<br><img src=\"/images/2016.01.09/09.png\" alt=\"\"></p>\n<h3 id=\"Adaptive-presentation\"><a href=\"#Adaptive-presentation\" class=\"headerlink\" title=\"Adaptive presentation\"></a>Adaptive presentation</h3><p>在如下状态下面点击 Photo Library bar button，能够看到如下效果：<br><img src=\"/images/2016.01.09/10.png\" alt=\"\"></p>\n<p>在上图状态下拖动中间的标志，使APP为5：5模式，效果如下：<br><img src=\"/images/2016.01.09/11.png\" alt=\"\">   </p>\n<p>能够注意到，我们没有做任何改变，但是我们从33%变成50%的时候，弹出的模态菜单变成了整个页面。这个效果是由UIPopoverPresentationController控制的，而我们想要的效果是是只有APP在Slide Over模式或者作为第二APP并且在33%的时候才会使用popover。我们可以设置UIPopoverPresentationController的delegate来实现我们的行为。   </p>\n<p>打开LogsViewController.swift，添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">LogsViewController</span>: <span class=\"title\">UIPopoverPresentationControllerDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">adaptivePresentationStyleForPresentationController</span><span class=\"params\">( controller: UIPresentationController,traitCollection: UITraitCollection)</span></span> -&gt; <span class=\"type\">UIModalPresentationStyle</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1 判断是iPad</span></span><br><span class=\"line\">        <span class=\"keyword\">guard</span> traitCollection.userInterfaceIdiom == .<span class=\"type\">Pad</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">FullScreen</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 宽度大于320使用popover</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> splitViewController?.view.bounds.width &gt; <span class=\"number\">320</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">None</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> .<span class=\"type\">FullScreen</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>  </p>\n<p>下面找到如下方法设置代理：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">presentImagePickerControllerWithSourceType</span><span class=\"params\">(sourceType: UIImagePickerControllerSourceType)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> controller = <span class=\"type\">UIImagePickerController</span>()</span><br><span class=\"line\">    controller.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    controller.sourceType = sourceType</span><br><span class=\"line\">    controller.mediaTypes = [<span class=\"type\">String</span>(kUTTypeImage), <span class=\"type\">String</span>(kUTTypeMovie)]</span><br><span class=\"line\">    controller.view.tintColor = <span class=\"type\">UIColor</span>.themeTineColor()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> sourceType == <span class=\"type\">UIImagePickerControllerSourceType</span>.<span class=\"type\">PhotoLibrary</span> &#123;</span><br><span class=\"line\">      controller.modalPresentationStyle = .<span class=\"type\">Popover</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> presenter = controller.popoverPresentationController</span><br><span class=\"line\">      presenter?.sourceView = view</span><br><span class=\"line\">      presenter?.barButtonItem = photoLibraryButton</span><br><span class=\"line\">      presenter?.delegate = <span class=\"keyword\">self</span> <span class=\"comment\">// 添加</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    presentViewController(controller, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>最终运行的效果如下：<br><img src=\"/images/2016.01.09/12.png\" alt=\"\"></p>\n<p>算是完成了这一篇笔记吧，可能跟书中不完全一样，感觉这篇文章只是简单介绍了一下，如果想更多了解请查看：<a href=\"https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/AdoptingMultitaskingOniPad/index.html#//apple_ref/doc/uid/TP40015145-CH3-SW1\">苹果文档</a></p>"},{"title":"一场站着听完的iOS技术分享会","date":"2016-04-25T15:45:50.000Z","_content":"\n![](/images/2016.04.25/01.jpg)   \n\n\n可能有些人看到这个题目的时候，心里就会在想你丫吹什么牛逼啊，如果你真这么想，那就看看下面的图片吧。这次分享会从下午两点开始，五点半结束，总共三个多小时他们就已一直站着听完，我们其他的分享嘉宾直呼真爱啊。     \n\n\n![](/images/2016.04.25/02.jpg)\n\n下面来说一下这场分享会吧，这是我个人组织的一场iOS的分享会，分享的嘉宾都是我的朋友，分享的都是iOS的干货。这次分享涉及了下面的四个主题：\n<!--- more --->\n* MShare_JS与Swift的交互\n* MVVM实战\n* MShare_那些你可能不知道的知识-WebSocket\n* JSPatch实战\n\n对应的例子代码、Keynote、录屏的视频已经都放在了github上了，地址：<https://github.com/mengxiangyue/MShare_Salon>。    \n\n本次活动特别感谢掘金、开发者头条、推酷、Cocoachina、fir.im、deveco、segmentfault的媒体支持，感谢慧点科技的场地支持。      \n针对MShare第一期活动做了一个问卷调查，这份调查问卷将关系到我们下一期是否举办，以及准备什么内容，有兴趣的帮忙填写一下，谢谢。地址：http://form.mikecrm.com/g2M53v。    \n\n### MShare招募成员\nMShare也在招募一些成员，要求爱分享、技术中级水平（初级如果特别爱学习也可以），有想加入的联系微信 mengxiangyue1990。MShare活动群，现在已经超过100人了，如果你想加入也可以加我微信，我拉你入群。    \n\nMShare还计划做一些有意义的事情，帮助一些开发者朋友。目前计划如下，如果你感兴趣请联系我，我们一起完成它：\n* 开发一个打包服务器（使用Nodejs技术，理论上可以，不知道会有什么坑）\n* 开发一个客户端 MShare.One ，内容应该是跟技术分享提高有关。\n\n\n下面是现场的一些照片：\n![](/images/2016.04.25/03.jpg)  \n![](/images/2016.04.25/04.jpg)   \n![](/images/2016.04.25/05.jpg)\n","source":"_posts/一场站着听完的iOS技术分享会.md","raw":"title: 一场站着听完的iOS技术分享会\ndate: 2016-04-25 23:45:50\ntags:\n---\n\n![](/images/2016.04.25/01.jpg)   \n\n\n可能有些人看到这个题目的时候，心里就会在想你丫吹什么牛逼啊，如果你真这么想，那就看看下面的图片吧。这次分享会从下午两点开始，五点半结束，总共三个多小时他们就已一直站着听完，我们其他的分享嘉宾直呼真爱啊。     \n\n\n![](/images/2016.04.25/02.jpg)\n\n下面来说一下这场分享会吧，这是我个人组织的一场iOS的分享会，分享的嘉宾都是我的朋友，分享的都是iOS的干货。这次分享涉及了下面的四个主题：\n<!--- more --->\n* MShare_JS与Swift的交互\n* MVVM实战\n* MShare_那些你可能不知道的知识-WebSocket\n* JSPatch实战\n\n对应的例子代码、Keynote、录屏的视频已经都放在了github上了，地址：<https://github.com/mengxiangyue/MShare_Salon>。    \n\n本次活动特别感谢掘金、开发者头条、推酷、Cocoachina、fir.im、deveco、segmentfault的媒体支持，感谢慧点科技的场地支持。      \n针对MShare第一期活动做了一个问卷调查，这份调查问卷将关系到我们下一期是否举办，以及准备什么内容，有兴趣的帮忙填写一下，谢谢。地址：http://form.mikecrm.com/g2M53v。    \n\n### MShare招募成员\nMShare也在招募一些成员，要求爱分享、技术中级水平（初级如果特别爱学习也可以），有想加入的联系微信 mengxiangyue1990。MShare活动群，现在已经超过100人了，如果你想加入也可以加我微信，我拉你入群。    \n\nMShare还计划做一些有意义的事情，帮助一些开发者朋友。目前计划如下，如果你感兴趣请联系我，我们一起完成它：\n* 开发一个打包服务器（使用Nodejs技术，理论上可以，不知道会有什么坑）\n* 开发一个客户端 MShare.One ，内容应该是跟技术分享提高有关。\n\n\n下面是现场的一些照片：\n![](/images/2016.04.25/03.jpg)  \n![](/images/2016.04.25/04.jpg)   \n![](/images/2016.04.25/05.jpg)\n","slug":"一场站着听完的iOS技术分享会","published":1,"updated":"2016-06-28T00:32:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0v000p3is6m8utfdbp","content":"<p><img src=\"/images/2016.04.25/01.jpg\" alt=\"\">   </p>\n<p>可能有些人看到这个题目的时候，心里就会在想你丫吹什么牛逼啊，如果你真这么想，那就看看下面的图片吧。这次分享会从下午两点开始，五点半结束，总共三个多小时他们就已一直站着听完，我们其他的分享嘉宾直呼真爱啊。     </p>\n<p><img src=\"/images/2016.04.25/02.jpg\" alt=\"\"></p>\n<p>下面来说一下这场分享会吧，这是我个人组织的一场iOS的分享会，分享的嘉宾都是我的朋友，分享的都是iOS的干货。这次分享涉及了下面的四个主题：<br><a id=\"more\"></a></p>\n<ul>\n<li>MShare_JS与Swift的交互</li>\n<li>MVVM实战</li>\n<li>MShare_那些你可能不知道的知识-WebSocket</li>\n<li>JSPatch实战</li>\n</ul>\n<p>对应的例子代码、Keynote、录屏的视频已经都放在了github上了，地址：<a href=\"https://github.com/mengxiangyue/MShare_Salon\" target=\"_blank\" rel=\"external\">https://github.com/mengxiangyue/MShare_Salon</a>。    </p>\n<p>本次活动特别感谢掘金、开发者头条、推酷、Cocoachina、fir.im、deveco、segmentfault的媒体支持，感谢慧点科技的场地支持。<br>针对MShare第一期活动做了一个问卷调查，这份调查问卷将关系到我们下一期是否举办，以及准备什么内容，有兴趣的帮忙填写一下，谢谢。地址：<a href=\"http://form.mikecrm.com/g2M53v。\" target=\"_blank\" rel=\"external\">http://form.mikecrm.com/g2M53v。</a>    </p>\n<h3 id=\"MShare招募成员\"><a href=\"#MShare招募成员\" class=\"headerlink\" title=\"MShare招募成员\"></a>MShare招募成员</h3><p>MShare也在招募一些成员，要求爱分享、技术中级水平（初级如果特别爱学习也可以），有想加入的联系微信 mengxiangyue1990。MShare活动群，现在已经超过100人了，如果你想加入也可以加我微信，我拉你入群。    </p>\n<p>MShare还计划做一些有意义的事情，帮助一些开发者朋友。目前计划如下，如果你感兴趣请联系我，我们一起完成它：</p>\n<ul>\n<li>开发一个打包服务器（使用Nodejs技术，理论上可以，不知道会有什么坑）</li>\n<li>开发一个客户端 MShare.One ，内容应该是跟技术分享提高有关。</li>\n</ul>\n<p>下面是现场的一些照片：<br><img src=\"/images/2016.04.25/03.jpg\" alt=\"\"><br><img src=\"/images/2016.04.25/04.jpg\" alt=\"\"><br><img src=\"/images/2016.04.25/05.jpg\" alt=\"\"></p>\n","excerpt":"<p><img src=\"/images/2016.04.25/01.jpg\" alt=\"\">   </p>\n<p>可能有些人看到这个题目的时候，心里就会在想你丫吹什么牛逼啊，如果你真这么想，那就看看下面的图片吧。这次分享会从下午两点开始，五点半结束，总共三个多小时他们就已一直站着听完，我们其他的分享嘉宾直呼真爱啊。     </p>\n<p><img src=\"/images/2016.04.25/02.jpg\" alt=\"\"></p>\n<p>下面来说一下这场分享会吧，这是我个人组织的一场iOS的分享会，分享的嘉宾都是我的朋友，分享的都是iOS的干货。这次分享涉及了下面的四个主题：<br>","more":"</p>\n<ul>\n<li>MShare_JS与Swift的交互</li>\n<li>MVVM实战</li>\n<li>MShare_那些你可能不知道的知识-WebSocket</li>\n<li>JSPatch实战</li>\n</ul>\n<p>对应的例子代码、Keynote、录屏的视频已经都放在了github上了，地址：<a href=\"https://github.com/mengxiangyue/MShare_Salon\">https://github.com/mengxiangyue/MShare_Salon</a>。    </p>\n<p>本次活动特别感谢掘金、开发者头条、推酷、Cocoachina、fir.im、deveco、segmentfault的媒体支持，感谢慧点科技的场地支持。<br>针对MShare第一期活动做了一个问卷调查，这份调查问卷将关系到我们下一期是否举办，以及准备什么内容，有兴趣的帮忙填写一下，谢谢。地址：<a href=\"http://form.mikecrm.com/g2M53v。\">http://form.mikecrm.com/g2M53v。</a>    </p>\n<h3 id=\"MShare招募成员\"><a href=\"#MShare招募成员\" class=\"headerlink\" title=\"MShare招募成员\"></a>MShare招募成员</h3><p>MShare也在招募一些成员，要求爱分享、技术中级水平（初级如果特别爱学习也可以），有想加入的联系微信 mengxiangyue1990。MShare活动群，现在已经超过100人了，如果你想加入也可以加我微信，我拉你入群。    </p>\n<p>MShare还计划做一些有意义的事情，帮助一些开发者朋友。目前计划如下，如果你感兴趣请联系我，我们一起完成它：</p>\n<ul>\n<li>开发一个打包服务器（使用Nodejs技术，理论上可以，不知道会有什么坑）</li>\n<li>开发一个客户端 MShare.One ，内容应该是跟技术分享提高有关。</li>\n</ul>\n<p>下面是现场的一些照片：<br><img src=\"/images/2016.04.25/03.jpg\" alt=\"\"><br><img src=\"/images/2016.04.25/04.jpg\" alt=\"\"><br><img src=\"/images/2016.04.25/05.jpg\" alt=\"\"></p>"},{"title":"iOS9 by Tutorials 学习笔记八:Storyboard新特性","date":"2016-01-25T15:06:34.000Z","_content":"\n终于整理到第八篇了，中途好几次都想放弃了，最终还是坚持下来了，我自己的计划应该除了这篇还有最多三篇就结束了吧。   \n\n回到正题，苹果最近几点一直在努力推行Storyboard，每年的WWDC都会针对Storyboard有一定的增强，今年也不例外，Storyboard添加了一些新的特性：\n1. 可以使用storyboard references将一个Scene链接到另一个storyboard中\n2. 使用scene dock给view controller添加附加的view\n3. 在navigation bar上添加多个button\n\n### Getting started\n打开本节配套的工程，在模拟器上运行一下，看看都有什么功能。下面看一下代码 **ChecklistsViewController.swift** 显示checklist，**ChecklistDetailViewController.swift** 显示list中的每一个item，**Main.storyboard** 包含用户界面。这个App并没有完成，在本节中将会添加一些功能，完善该APP。  \n\n### Storyboard references\n如果你在一个大的项目中使用了storyboard，你将会慢慢感觉storyboard越来越大，会越来越笨重，并且还经常会发生冲突。这些导致了storyboard慢慢丢失了它的优势。   \n\n你可能已经通过将Scene分别放到多个storyboard中的方式解决了一部分的问题，但是同时也遇到了一些问题：在两个Scene之间的segue不能直接添加了，显示一个View Controller有时候必须通过代码创建显示。  \n\n<!--- more --->\n\n现在我们在Xcode7中能够通过storyboard reference解决这个问题了。它能够很容易的将storyboard分割成为更小的storyboard，并且能够直接在storyboard中使用segue。更多的小的storyboard也能让团队的成员更加独立的工作，而不会影响到其他的团队成员。  \n\n#### Creating your first storyboard reference   \n目前的情况，Prepped是一个很小的app，但是同样也可以在结构上进行storyboard的划分。Container view controller就是一个很好的从功能上划分的例子。   \n\nPrepped使用的tab bar controller，在这种情况下，将每个tab的子view controller划分进一个storyboard是一个不错的选择（当然每个tab bar子VC下还可以划分）。    \n\n打开Main.storyboard,双击空白区域，缩小storyboard区域，能够看到所有的scene。选中除tab bar controller的所有的scene。\n![](/images/2016.01.25/01.png)\n\n选择 **Editor\\Refactor to Storyboard**，输入 **Checklists.storyboard** 作为新的storyboard的名字。点击Save。这样我们就将一部分的Scene拆分到了新的storyboard中。Main.storyboard也变成了下面的样子：\n![](/images/2016.01.25/02.png)  \n\n选中图中的Reference，查看右边的属性检查器，能够看到Storyboard和Referenced ID，storyboard根据这两个属性去确定该reference真正指向的Scene。双加该reference也能够跳转到真正的Scene。如果我们删除了上图中的Referenced ID，默认情况下指向的是reference Storyboard中Initial View Controller。\n![](/images/2016.01.25/03.png)  \n\n#### Storyboards within a team  \n由于在团队中都惧怕Storyboard的冲突，所以还是很少使用。但是现在storyboard reference能够避免这些冲突。我们可能都遇到过这种情况，我们在一个storyboard钟创建了一个view controller，在另一个storyboard想要跳转到它，一般这种情况我们都是使用代码跳转了，现在我们可以使用storyboard实现了。\n> 添加工程目录内的Diary目录到工程中来  \n\n打开Main.storyboard，拽一个storyboard reference添加到storyboard的空白区域：\n![](/images/2016.01.25/04.png)    \n\n运行程序，显示如下：\n![](/images/2016.01.25/05.png)   \n\n### Views in the scene dock\nScene Dock是在Storyboard Scene顶部的一个区域（下图中有标注），我们可以将View添加到scene dock上，添加到scene dock上的view不会被初始化添加到view controller的view的subviews中，但是你能够使用IBOutlet引用使用它。按照如图添加然后设置该View的background color为#FFFAE8.\n![](/images/2016.01.25/06.png)    \n\n按照下图，按住ctrl连接，在弹出菜单中选择selectedBackgroundView：\n![](/images/2016.01.25/07.png)     \n\n运行程序，发现我们选中的item上面添加了背景。  \n\n上面的例子中我们只是通过storyboard使用了scene dock中的view，我们也可以使用IBOutlet引用到我们的代码中，然后由代码控制在什么情况下的隐藏与显示。\n\n### Using multiple bar buttons\n在Xcode 7中我们可以在storyboard中，为view controller的Navigation bar在同一侧添加多个按钮了。  \n\n打开ChecklistDetail.storyboard，选中 Checklist Detail View Controller，从Object Library中拽多个bar button item添加到右侧的Navigation bar上，这样就添加了多个bar button，添加完后其他的使用方式就跟原来的基本一样了，这里就不重复了。\n![](/images/2016.01.25/08.png)    \n\n最近一直在比较累，所以这篇整理的比较简单，只是挑选了一些重点的写出来了，如果哪里感觉不是太详细，还请去看英文的原版。\n","source":"_posts/iOS9-by-Tutorials-学习笔记八-Storyboard新特性.md","raw":"title: 'iOS9 by Tutorials 学习笔记八:Storyboard新特性'\ndate: 2016-01-25 23:06:34\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n终于整理到第八篇了，中途好几次都想放弃了，最终还是坚持下来了，我自己的计划应该除了这篇还有最多三篇就结束了吧。   \n\n回到正题，苹果最近几点一直在努力推行Storyboard，每年的WWDC都会针对Storyboard有一定的增强，今年也不例外，Storyboard添加了一些新的特性：\n1. 可以使用storyboard references将一个Scene链接到另一个storyboard中\n2. 使用scene dock给view controller添加附加的view\n3. 在navigation bar上添加多个button\n\n### Getting started\n打开本节配套的工程，在模拟器上运行一下，看看都有什么功能。下面看一下代码 **ChecklistsViewController.swift** 显示checklist，**ChecklistDetailViewController.swift** 显示list中的每一个item，**Main.storyboard** 包含用户界面。这个App并没有完成，在本节中将会添加一些功能，完善该APP。  \n\n### Storyboard references\n如果你在一个大的项目中使用了storyboard，你将会慢慢感觉storyboard越来越大，会越来越笨重，并且还经常会发生冲突。这些导致了storyboard慢慢丢失了它的优势。   \n\n你可能已经通过将Scene分别放到多个storyboard中的方式解决了一部分的问题，但是同时也遇到了一些问题：在两个Scene之间的segue不能直接添加了，显示一个View Controller有时候必须通过代码创建显示。  \n\n<!--- more --->\n\n现在我们在Xcode7中能够通过storyboard reference解决这个问题了。它能够很容易的将storyboard分割成为更小的storyboard，并且能够直接在storyboard中使用segue。更多的小的storyboard也能让团队的成员更加独立的工作，而不会影响到其他的团队成员。  \n\n#### Creating your first storyboard reference   \n目前的情况，Prepped是一个很小的app，但是同样也可以在结构上进行storyboard的划分。Container view controller就是一个很好的从功能上划分的例子。   \n\nPrepped使用的tab bar controller，在这种情况下，将每个tab的子view controller划分进一个storyboard是一个不错的选择（当然每个tab bar子VC下还可以划分）。    \n\n打开Main.storyboard,双击空白区域，缩小storyboard区域，能够看到所有的scene。选中除tab bar controller的所有的scene。\n![](/images/2016.01.25/01.png)\n\n选择 **Editor\\Refactor to Storyboard**，输入 **Checklists.storyboard** 作为新的storyboard的名字。点击Save。这样我们就将一部分的Scene拆分到了新的storyboard中。Main.storyboard也变成了下面的样子：\n![](/images/2016.01.25/02.png)  \n\n选中图中的Reference，查看右边的属性检查器，能够看到Storyboard和Referenced ID，storyboard根据这两个属性去确定该reference真正指向的Scene。双加该reference也能够跳转到真正的Scene。如果我们删除了上图中的Referenced ID，默认情况下指向的是reference Storyboard中Initial View Controller。\n![](/images/2016.01.25/03.png)  \n\n#### Storyboards within a team  \n由于在团队中都惧怕Storyboard的冲突，所以还是很少使用。但是现在storyboard reference能够避免这些冲突。我们可能都遇到过这种情况，我们在一个storyboard钟创建了一个view controller，在另一个storyboard想要跳转到它，一般这种情况我们都是使用代码跳转了，现在我们可以使用storyboard实现了。\n> 添加工程目录内的Diary目录到工程中来  \n\n打开Main.storyboard，拽一个storyboard reference添加到storyboard的空白区域：\n![](/images/2016.01.25/04.png)    \n\n运行程序，显示如下：\n![](/images/2016.01.25/05.png)   \n\n### Views in the scene dock\nScene Dock是在Storyboard Scene顶部的一个区域（下图中有标注），我们可以将View添加到scene dock上，添加到scene dock上的view不会被初始化添加到view controller的view的subviews中，但是你能够使用IBOutlet引用使用它。按照如图添加然后设置该View的background color为#FFFAE8.\n![](/images/2016.01.25/06.png)    \n\n按照下图，按住ctrl连接，在弹出菜单中选择selectedBackgroundView：\n![](/images/2016.01.25/07.png)     \n\n运行程序，发现我们选中的item上面添加了背景。  \n\n上面的例子中我们只是通过storyboard使用了scene dock中的view，我们也可以使用IBOutlet引用到我们的代码中，然后由代码控制在什么情况下的隐藏与显示。\n\n### Using multiple bar buttons\n在Xcode 7中我们可以在storyboard中，为view controller的Navigation bar在同一侧添加多个按钮了。  \n\n打开ChecklistDetail.storyboard，选中 Checklist Detail View Controller，从Object Library中拽多个bar button item添加到右侧的Navigation bar上，这样就添加了多个bar button，添加完后其他的使用方式就跟原来的基本一样了，这里就不重复了。\n![](/images/2016.01.25/08.png)    \n\n最近一直在比较累，所以这篇整理的比较简单，只是挑选了一些重点的写出来了，如果哪里感觉不是太详细，还请去看英文的原版。\n","slug":"iOS9-by-Tutorials-学习笔记八-Storyboard新特性","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0x000u3is69pi29lem","content":"<p>终于整理到第八篇了，中途好几次都想放弃了，最终还是坚持下来了，我自己的计划应该除了这篇还有最多三篇就结束了吧。   </p>\n<p>回到正题，苹果最近几点一直在努力推行Storyboard，每年的WWDC都会针对Storyboard有一定的增强，今年也不例外，Storyboard添加了一些新的特性：</p>\n<ol>\n<li>可以使用storyboard references将一个Scene链接到另一个storyboard中</li>\n<li>使用scene dock给view controller添加附加的view</li>\n<li>在navigation bar上添加多个button</li>\n</ol>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>打开本节配套的工程，在模拟器上运行一下，看看都有什么功能。下面看一下代码 <strong>ChecklistsViewController.swift</strong> 显示checklist，<strong>ChecklistDetailViewController.swift</strong> 显示list中的每一个item，<strong>Main.storyboard</strong> 包含用户界面。这个App并没有完成，在本节中将会添加一些功能，完善该APP。  </p>\n<h3 id=\"Storyboard-references\"><a href=\"#Storyboard-references\" class=\"headerlink\" title=\"Storyboard references\"></a>Storyboard references</h3><p>如果你在一个大的项目中使用了storyboard，你将会慢慢感觉storyboard越来越大，会越来越笨重，并且还经常会发生冲突。这些导致了storyboard慢慢丢失了它的优势。   </p>\n<p>你可能已经通过将Scene分别放到多个storyboard中的方式解决了一部分的问题，但是同时也遇到了一些问题：在两个Scene之间的segue不能直接添加了，显示一个View Controller有时候必须通过代码创建显示。  </p>\n<a id=\"more\"></a>\n<p>现在我们在Xcode7中能够通过storyboard reference解决这个问题了。它能够很容易的将storyboard分割成为更小的storyboard，并且能够直接在storyboard中使用segue。更多的小的storyboard也能让团队的成员更加独立的工作，而不会影响到其他的团队成员。  </p>\n<h4 id=\"Creating-your-first-storyboard-reference\"><a href=\"#Creating-your-first-storyboard-reference\" class=\"headerlink\" title=\"Creating your first storyboard reference\"></a>Creating your first storyboard reference</h4><p>目前的情况，Prepped是一个很小的app，但是同样也可以在结构上进行storyboard的划分。Container view controller就是一个很好的从功能上划分的例子。   </p>\n<p>Prepped使用的tab bar controller，在这种情况下，将每个tab的子view controller划分进一个storyboard是一个不错的选择（当然每个tab bar子VC下还可以划分）。    </p>\n<p>打开Main.storyboard,双击空白区域，缩小storyboard区域，能够看到所有的scene。选中除tab bar controller的所有的scene。<br><img src=\"/images/2016.01.25/01.png\" alt=\"\"></p>\n<p>选择 <strong>Editor\\Refactor to Storyboard</strong>，输入 <strong>Checklists.storyboard</strong> 作为新的storyboard的名字。点击Save。这样我们就将一部分的Scene拆分到了新的storyboard中。Main.storyboard也变成了下面的样子：<br><img src=\"/images/2016.01.25/02.png\" alt=\"\">  </p>\n<p>选中图中的Reference，查看右边的属性检查器，能够看到Storyboard和Referenced ID，storyboard根据这两个属性去确定该reference真正指向的Scene。双加该reference也能够跳转到真正的Scene。如果我们删除了上图中的Referenced ID，默认情况下指向的是reference Storyboard中Initial View Controller。<br><img src=\"/images/2016.01.25/03.png\" alt=\"\">  </p>\n<h4 id=\"Storyboards-within-a-team\"><a href=\"#Storyboards-within-a-team\" class=\"headerlink\" title=\"Storyboards within a team\"></a>Storyboards within a team</h4><p>由于在团队中都惧怕Storyboard的冲突，所以还是很少使用。但是现在storyboard reference能够避免这些冲突。我们可能都遇到过这种情况，我们在一个storyboard钟创建了一个view controller，在另一个storyboard想要跳转到它，一般这种情况我们都是使用代码跳转了，现在我们可以使用storyboard实现了。</p>\n<blockquote>\n<p>添加工程目录内的Diary目录到工程中来  </p>\n</blockquote>\n<p>打开Main.storyboard，拽一个storyboard reference添加到storyboard的空白区域：<br><img src=\"/images/2016.01.25/04.png\" alt=\"\">    </p>\n<p>运行程序，显示如下：<br><img src=\"/images/2016.01.25/05.png\" alt=\"\">   </p>\n<h3 id=\"Views-in-the-scene-dock\"><a href=\"#Views-in-the-scene-dock\" class=\"headerlink\" title=\"Views in the scene dock\"></a>Views in the scene dock</h3><p>Scene Dock是在Storyboard Scene顶部的一个区域（下图中有标注），我们可以将View添加到scene dock上，添加到scene dock上的view不会被初始化添加到view controller的view的subviews中，但是你能够使用IBOutlet引用使用它。按照如图添加然后设置该View的background color为#FFFAE8.<br><img src=\"/images/2016.01.25/06.png\" alt=\"\">    </p>\n<p>按照下图，按住ctrl连接，在弹出菜单中选择selectedBackgroundView：<br><img src=\"/images/2016.01.25/07.png\" alt=\"\">     </p>\n<p>运行程序，发现我们选中的item上面添加了背景。  </p>\n<p>上面的例子中我们只是通过storyboard使用了scene dock中的view，我们也可以使用IBOutlet引用到我们的代码中，然后由代码控制在什么情况下的隐藏与显示。</p>\n<h3 id=\"Using-multiple-bar-buttons\"><a href=\"#Using-multiple-bar-buttons\" class=\"headerlink\" title=\"Using multiple bar buttons\"></a>Using multiple bar buttons</h3><p>在Xcode 7中我们可以在storyboard中，为view controller的Navigation bar在同一侧添加多个按钮了。  </p>\n<p>打开ChecklistDetail.storyboard，选中 Checklist Detail View Controller，从Object Library中拽多个bar button item添加到右侧的Navigation bar上，这样就添加了多个bar button，添加完后其他的使用方式就跟原来的基本一样了，这里就不重复了。<br><img src=\"/images/2016.01.25/08.png\" alt=\"\">    </p>\n<p>最近一直在比较累，所以这篇整理的比较简单，只是挑选了一些重点的写出来了，如果哪里感觉不是太详细，还请去看英文的原版。</p>\n","excerpt":"<p>终于整理到第八篇了，中途好几次都想放弃了，最终还是坚持下来了，我自己的计划应该除了这篇还有最多三篇就结束了吧。   </p>\n<p>回到正题，苹果最近几点一直在努力推行Storyboard，每年的WWDC都会针对Storyboard有一定的增强，今年也不例外，Storyboard添加了一些新的特性：</p>\n<ol>\n<li>可以使用storyboard references将一个Scene链接到另一个storyboard中</li>\n<li>使用scene dock给view controller添加附加的view</li>\n<li>在navigation bar上添加多个button</li>\n</ol>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>打开本节配套的工程，在模拟器上运行一下，看看都有什么功能。下面看一下代码 <strong>ChecklistsViewController.swift</strong> 显示checklist，<strong>ChecklistDetailViewController.swift</strong> 显示list中的每一个item，<strong>Main.storyboard</strong> 包含用户界面。这个App并没有完成，在本节中将会添加一些功能，完善该APP。  </p>\n<h3 id=\"Storyboard-references\"><a href=\"#Storyboard-references\" class=\"headerlink\" title=\"Storyboard references\"></a>Storyboard references</h3><p>如果你在一个大的项目中使用了storyboard，你将会慢慢感觉storyboard越来越大，会越来越笨重，并且还经常会发生冲突。这些导致了storyboard慢慢丢失了它的优势。   </p>\n<p>你可能已经通过将Scene分别放到多个storyboard中的方式解决了一部分的问题，但是同时也遇到了一些问题：在两个Scene之间的segue不能直接添加了，显示一个View Controller有时候必须通过代码创建显示。  </p>","more":"<p>现在我们在Xcode7中能够通过storyboard reference解决这个问题了。它能够很容易的将storyboard分割成为更小的storyboard，并且能够直接在storyboard中使用segue。更多的小的storyboard也能让团队的成员更加独立的工作，而不会影响到其他的团队成员。  </p>\n<h4 id=\"Creating-your-first-storyboard-reference\"><a href=\"#Creating-your-first-storyboard-reference\" class=\"headerlink\" title=\"Creating your first storyboard reference\"></a>Creating your first storyboard reference</h4><p>目前的情况，Prepped是一个很小的app，但是同样也可以在结构上进行storyboard的划分。Container view controller就是一个很好的从功能上划分的例子。   </p>\n<p>Prepped使用的tab bar controller，在这种情况下，将每个tab的子view controller划分进一个storyboard是一个不错的选择（当然每个tab bar子VC下还可以划分）。    </p>\n<p>打开Main.storyboard,双击空白区域，缩小storyboard区域，能够看到所有的scene。选中除tab bar controller的所有的scene。<br><img src=\"/images/2016.01.25/01.png\" alt=\"\"></p>\n<p>选择 <strong>Editor\\Refactor to Storyboard</strong>，输入 <strong>Checklists.storyboard</strong> 作为新的storyboard的名字。点击Save。这样我们就将一部分的Scene拆分到了新的storyboard中。Main.storyboard也变成了下面的样子：<br><img src=\"/images/2016.01.25/02.png\" alt=\"\">  </p>\n<p>选中图中的Reference，查看右边的属性检查器，能够看到Storyboard和Referenced ID，storyboard根据这两个属性去确定该reference真正指向的Scene。双加该reference也能够跳转到真正的Scene。如果我们删除了上图中的Referenced ID，默认情况下指向的是reference Storyboard中Initial View Controller。<br><img src=\"/images/2016.01.25/03.png\" alt=\"\">  </p>\n<h4 id=\"Storyboards-within-a-team\"><a href=\"#Storyboards-within-a-team\" class=\"headerlink\" title=\"Storyboards within a team\"></a>Storyboards within a team</h4><p>由于在团队中都惧怕Storyboard的冲突，所以还是很少使用。但是现在storyboard reference能够避免这些冲突。我们可能都遇到过这种情况，我们在一个storyboard钟创建了一个view controller，在另一个storyboard想要跳转到它，一般这种情况我们都是使用代码跳转了，现在我们可以使用storyboard实现了。</p>\n<blockquote>\n<p>添加工程目录内的Diary目录到工程中来  </p>\n</blockquote>\n<p>打开Main.storyboard，拽一个storyboard reference添加到storyboard的空白区域：<br><img src=\"/images/2016.01.25/04.png\" alt=\"\">    </p>\n<p>运行程序，显示如下：<br><img src=\"/images/2016.01.25/05.png\" alt=\"\">   </p>\n<h3 id=\"Views-in-the-scene-dock\"><a href=\"#Views-in-the-scene-dock\" class=\"headerlink\" title=\"Views in the scene dock\"></a>Views in the scene dock</h3><p>Scene Dock是在Storyboard Scene顶部的一个区域（下图中有标注），我们可以将View添加到scene dock上，添加到scene dock上的view不会被初始化添加到view controller的view的subviews中，但是你能够使用IBOutlet引用使用它。按照如图添加然后设置该View的background color为#FFFAE8.<br><img src=\"/images/2016.01.25/06.png\" alt=\"\">    </p>\n<p>按照下图，按住ctrl连接，在弹出菜单中选择selectedBackgroundView：<br><img src=\"/images/2016.01.25/07.png\" alt=\"\">     </p>\n<p>运行程序，发现我们选中的item上面添加了背景。  </p>\n<p>上面的例子中我们只是通过storyboard使用了scene dock中的view，我们也可以使用IBOutlet引用到我们的代码中，然后由代码控制在什么情况下的隐藏与显示。</p>\n<h3 id=\"Using-multiple-bar-buttons\"><a href=\"#Using-multiple-bar-buttons\" class=\"headerlink\" title=\"Using multiple bar buttons\"></a>Using multiple bar buttons</h3><p>在Xcode 7中我们可以在storyboard中，为view controller的Navigation bar在同一侧添加多个按钮了。  </p>\n<p>打开ChecklistDetail.storyboard，选中 Checklist Detail View Controller，从Object Library中拽多个bar button item添加到右侧的Navigation bar上，这样就添加了多个bar button，添加完后其他的使用方式就跟原来的基本一样了，这里就不重复了。<br><img src=\"/images/2016.01.25/08.png\" alt=\"\">    </p>\n<p>最近一直在比较累，所以这篇整理的比较简单，只是挑选了一些重点的写出来了，如果哪里感觉不是太详细，还请去看英文的原版。</p>"},{"title":"iOS9 by Tutorials 学习笔记四：APP 瘦身","date":"2016-01-04T14:26:09.000Z","_content":"\n>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。\n\n>本文然然进行了一些语法的修改，很开心她为我修改这些东西。她说我转折只会用但是，被她这么一说想想还真是只是会用但是，嘿嘿。  \n\niPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。这些技术及设备的变化给我在开发的过程中也造成了许多的问题，不仅如此苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。另一方面Universal App虽然在开发的过程中，方便了我们开发人员，可是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但真正的在运行的时候，我们并不需要那么多相关的代码及资源。    \n\n例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：\n![](/images/2016.01.04.01.png)   \n\n上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：\n\n<!---more--->\n\n* App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  \n* On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。\n* Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   \n\n这三个技术加起来，统一称为App Thinning。\n\n### Getting started   \n打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：\n![](/images/2016.01.04.02.png)\n\n伴随着模拟器启动起来的还打开了一个Finder窗口：  \n![](/images/2016.01.04.03.png)\n\n这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：\n![](/images/2016.01.04.04.png)\n{% codeblock lang:bin %}\necho \"App Size in KB:  `du -sk \\\"${CONFIGURATION_BUILD_DIR}/${EXECUTABLE_NAME}.app\\\"`\"\nif [ \"${CONFIGURATION}\" = \"Debug\" ]; then\nopen ${CONFIGURATION_BUILD_DIR}\nfi\n{% endcodeblock %}   \n\n在Finder的Old CA Maps点击右键，选择显示包内容，如下：\n![](/images/2016.01.04.05.png)   \n\n上图中标注的说明如下：\n1. Assets.car是Assets.xcassets被Xcode进行编译后的文件。\n2. Old CA Maps是真实运行在设备上的可执行文件。\n3. Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。\n4. SD_Map.bundle 这个就是地图图片文件，但是将近120MB。\n\n#### Measuring your work   \n本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：\n![](/images/2016.01.04.06.png)   \n\n### Slicing up app slicing\nApp slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    \n\n**Executable slicing** 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   \n\n默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。\n\n#### Being smart with resources\n**Resource slicing** 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，则要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 **Memory** 和 **Graphics** ，如下：\n![](/images/2016.01.04.07.png)\n\n##### Your first fix\n在开始的时候介绍过Santa Cruz PNGs这个文件因为被放到Main bundle中，所以不能被编译进入到Assets.car，进而也不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：\n![](/images/2016.01.04.08.png)\n\n选择New Image Set后，将新加入的set命名为Santa Cruz，紧接着做如下操作：\n![](/images/2016.01.04.09.png)  \n> 纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   \n\n然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   \n\n##### Lazily (down)loading content\n苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。\n\n##### Wire things up to use tags\n下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：\n{% codeblock lang:swift %}\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n{% endcodeblock %}    \n\n这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：\n![](/images/2016.01.04.10.png)\n\n然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。\n![](/images/2016.01.04.11.png)  \n\n>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   \n\n#### Make it download faster   \n在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：\n{% codeblock lang:swift %}\n// add 为新添加的 ProgressView是程序已经添加上的\nprivate func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n  guard let bundleTitle = mapOverlayData?.bundleTitle else {\n    return\n  }\n\n  let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n  bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n  loadingProgressView.observedProgress = bundleResource.progress // add\n\n  loadingProgressView.hidden = false // add\n  UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n  bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n    NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n      self?.loadingProgressView.hidden = true // add\n      UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n      if error == nil {\n        self?.displayOverlayFromBundle(bundleResource.bundle)\n      }\n    })\n  }\n\n}\n{% endcodeblock %}\n\n> 如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。\n\n#### The many flavors of tagging\n虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。\n\n##### Initial install tags  \n使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：\n* **Initial Install Tags** 在ipa下载的时候一同下载\n* **Prefetched Tag Order** 在程序下载完成后，下载对应的资源，然后按顺序排列。\n* **Prefetched Tag Order** 按需下载   \n下面是配置的地方：\n![](/images/2016.01.04.12.png)  \n\n#### Purging content\n应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：\n![](/images/2016.01.04.13.png)  \n\n##### Set a resource to be purged   \n在MapChromeViewController.swift添加如下代码：\n{% codeblock lang:swift %}\n  // new add 是新加的代码\n  var overlayBundleResource: NSBundleResourceRequest? // new add\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n    overlayBundleResource = bundleResource // new add\n\n    bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n    loadingProgressView.observedProgress = bundleResource.progress // add\n\n    loadingProgressView.hidden = false // add\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        self?.loadingProgressView.hidden = true // add\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n\n  // new add\n  override func viewDidDisappear(animated: Bool) {\n    super.viewDidDisappear(animated)\n    // 告诉系统结束了对资源的访问\n    overlayBundleResource?.endAccessingResources()\n  }\n{% endcodeblock %}\n\n上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。\n\n坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。\n","source":"_posts/iOS9-by-Tutorials-学习笔记四：APP-瘦身.md","raw":"title: iOS9 by Tutorials 学习笔记四：APP 瘦身\ndate: 2016-01-04 22:26:09\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。\n\n>本文然然进行了一些语法的修改，很开心她为我修改这些东西。她说我转折只会用但是，被她这么一说想想还真是只是会用但是，嘿嘿。  \n\niPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。这些技术及设备的变化给我在开发的过程中也造成了许多的问题，不仅如此苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。另一方面Universal App虽然在开发的过程中，方便了我们开发人员，可是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但真正的在运行的时候，我们并不需要那么多相关的代码及资源。    \n\n例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：\n![](/images/2016.01.04.01.png)   \n\n上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：\n\n<!---more--->\n\n* App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  \n* On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。\n* Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   \n\n这三个技术加起来，统一称为App Thinning。\n\n### Getting started   \n打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：\n![](/images/2016.01.04.02.png)\n\n伴随着模拟器启动起来的还打开了一个Finder窗口：  \n![](/images/2016.01.04.03.png)\n\n这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：\n![](/images/2016.01.04.04.png)\n{% codeblock lang:bin %}\necho \"App Size in KB:  `du -sk \\\"${CONFIGURATION_BUILD_DIR}/${EXECUTABLE_NAME}.app\\\"`\"\nif [ \"${CONFIGURATION}\" = \"Debug\" ]; then\nopen ${CONFIGURATION_BUILD_DIR}\nfi\n{% endcodeblock %}   \n\n在Finder的Old CA Maps点击右键，选择显示包内容，如下：\n![](/images/2016.01.04.05.png)   \n\n上图中标注的说明如下：\n1. Assets.car是Assets.xcassets被Xcode进行编译后的文件。\n2. Old CA Maps是真实运行在设备上的可执行文件。\n3. Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。\n4. SD_Map.bundle 这个就是地图图片文件，但是将近120MB。\n\n#### Measuring your work   \n本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：\n![](/images/2016.01.04.06.png)   \n\n### Slicing up app slicing\nApp slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    \n\n**Executable slicing** 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   \n\n默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。\n\n#### Being smart with resources\n**Resource slicing** 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，则要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 **Memory** 和 **Graphics** ，如下：\n![](/images/2016.01.04.07.png)\n\n##### Your first fix\n在开始的时候介绍过Santa Cruz PNGs这个文件因为被放到Main bundle中，所以不能被编译进入到Assets.car，进而也不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：\n![](/images/2016.01.04.08.png)\n\n选择New Image Set后，将新加入的set命名为Santa Cruz，紧接着做如下操作：\n![](/images/2016.01.04.09.png)  \n> 纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   \n\n然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   \n\n##### Lazily (down)loading content\n苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。\n\n##### Wire things up to use tags\n下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：\n{% codeblock lang:swift %}\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n{% endcodeblock %}    \n\n这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：\n![](/images/2016.01.04.10.png)\n\n然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。\n![](/images/2016.01.04.11.png)  \n\n>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   \n\n#### Make it download faster   \n在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：\n{% codeblock lang:swift %}\n// add 为新添加的 ProgressView是程序已经添加上的\nprivate func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n  guard let bundleTitle = mapOverlayData?.bundleTitle else {\n    return\n  }\n\n  let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n\n  bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n  loadingProgressView.observedProgress = bundleResource.progress // add\n\n  loadingProgressView.hidden = false // add\n  UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n  bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n    NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n      self?.loadingProgressView.hidden = true // add\n      UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n      if error == nil {\n        self?.displayOverlayFromBundle(bundleResource.bundle)\n      }\n    })\n  }\n\n}\n{% endcodeblock %}\n\n> 如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。\n\n#### The many flavors of tagging\n虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。\n\n##### Initial install tags  \n使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：\n* **Initial Install Tags** 在ipa下载的时候一同下载\n* **Prefetched Tag Order** 在程序下载完成后，下载对应的资源，然后按顺序排列。\n* **Prefetched Tag Order** 按需下载   \n下面是配置的地方：\n![](/images/2016.01.04.12.png)  \n\n#### Purging content\n应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：\n![](/images/2016.01.04.13.png)  \n\n##### Set a resource to be purged   \n在MapChromeViewController.swift添加如下代码：\n{% codeblock lang:swift %}\n  // new add 是新加的代码\n  var overlayBundleResource: NSBundleResourceRequest? // new add\n  private func downloadAndDisplayMapOverlay() {\n//    displayOverlayFromBundle(NSBundle.mainBundle())\n    guard let bundleTitle = mapOverlayData?.bundleTitle else {\n      return\n    }\n\n    let bundleResource = NSBundleResourceRequest(tags: [bundleTitle])\n    overlayBundleResource = bundleResource // new add\n\n    bundleResource.loadingPriority = NSBundleResourceRequestLoadingPriorityUrgent  //add\n\n    loadingProgressView.observedProgress = bundleResource.progress // add\n\n    loadingProgressView.hidden = false // add\n    UIApplication.sharedApplication().networkActivityIndicatorVisible = true // add\n\n    bundleResource.beginAccessingResourcesWithCompletionHandler { [weak self] (error) -> Void in\n      NSOperationQueue.mainQueue().addOperationWithBlock({ () -> Void in\n        self?.loadingProgressView.hidden = true // add\n        UIApplication.sharedApplication().networkActivityIndicatorVisible = false // add\n        if error == nil {\n          self?.displayOverlayFromBundle(bundleResource.bundle)\n        }\n      })\n    }\n\n  }\n\n  // new add\n  override func viewDidDisappear(animated: Bool) {\n    super.viewDidDisappear(animated)\n    // 告诉系统结束了对资源的访问\n    overlayBundleResource?.endAccessingResources()\n  }\n{% endcodeblock %}\n\n上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。\n\n坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。\n","slug":"iOS9-by-Tutorials-学习笔记四：APP-瘦身","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0y000w3is6i1yxdo5r","content":"<blockquote>\n<p>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。</p>\n<p>本文然然进行了一些语法的修改，很开心她为我修改这些东西。她说我转折只会用但是，被她这么一说想想还真是只是会用但是，嘿嘿。  </p>\n</blockquote>\n<p>iPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。这些技术及设备的变化给我在开发的过程中也造成了许多的问题，不仅如此苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。另一方面Universal App虽然在开发的过程中，方便了我们开发人员，可是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但真正的在运行的时候，我们并不需要那么多相关的代码及资源。    </p>\n<p>例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：<br><img src=\"/images/2016.01.04.01.png\" alt=\"\">   </p>\n<p>上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：</p>\n<a id=\"more\"></a>\n<ul>\n<li>App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  </li>\n<li>On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。</li>\n<li>Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   </li>\n</ul>\n<p>这三个技术加起来，统一称为App Thinning。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：<br><img src=\"/images/2016.01.04.02.png\" alt=\"\"></p>\n<p>伴随着模拟器启动起来的还打开了一个Finder窗口：<br><img src=\"/images/2016.01.04.03.png\" alt=\"\"></p>\n<p>这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：<br><img src=\"/images/2016.01.04.04.png\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;App Size in KB:  `du -sk \\&quot;$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;EXECUTABLE_NAME&#125;.app\\&quot;`&quot;</span><br><span class=\"line\">if [ &quot;$&#123;CONFIGURATION&#125;&quot; = &quot;Debug&quot; ]; then</span><br><span class=\"line\">open $&#123;CONFIGURATION_BUILD_DIR&#125;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>   </p>\n<p>在Finder的Old CA Maps点击右键，选择显示包内容，如下：<br><img src=\"/images/2016.01.04.05.png\" alt=\"\">   </p>\n<p>上图中标注的说明如下：</p>\n<ol>\n<li>Assets.car是Assets.xcassets被Xcode进行编译后的文件。</li>\n<li>Old CA Maps是真实运行在设备上的可执行文件。</li>\n<li>Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。</li>\n<li>SD_Map.bundle 这个就是地图图片文件，但是将近120MB。</li>\n</ol>\n<h4 id=\"Measuring-your-work\"><a href=\"#Measuring-your-work\" class=\"headerlink\" title=\"Measuring your work\"></a>Measuring your work</h4><p>本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：<br><img src=\"/images/2016.01.04.06.png\" alt=\"\">   </p>\n<h3 id=\"Slicing-up-app-slicing\"><a href=\"#Slicing-up-app-slicing\" class=\"headerlink\" title=\"Slicing up app slicing\"></a>Slicing up app slicing</h3><p>App slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    </p>\n<p><strong>Executable slicing</strong> 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   </p>\n<p>默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。</p>\n<h4 id=\"Being-smart-with-resources\"><a href=\"#Being-smart-with-resources\" class=\"headerlink\" title=\"Being smart with resources\"></a>Being smart with resources</h4><p><strong>Resource slicing</strong> 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，则要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 <strong>Memory</strong> 和 <strong>Graphics</strong> ，如下：<br><img src=\"/images/2016.01.04.07.png\" alt=\"\"></p>\n<h5 id=\"Your-first-fix\"><a href=\"#Your-first-fix\" class=\"headerlink\" title=\"Your first fix\"></a>Your first fix</h5><p>在开始的时候介绍过Santa Cruz PNGs这个文件因为被放到Main bundle中，所以不能被编译进入到Assets.car，进而也不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：<br><img src=\"/images/2016.01.04.08.png\" alt=\"\"></p>\n<p>选择New Image Set后，将新加入的set命名为Santa Cruz，紧接着做如下操作：<br><img src=\"/images/2016.01.04.09.png\" alt=\"\">  </p>\n<blockquote>\n<p>纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   </p>\n</blockquote>\n<p>然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   </p>\n<h5 id=\"Lazily-down-loading-content\"><a href=\"#Lazily-down-loading-content\" class=\"headerlink\" title=\"Lazily (down)loading content\"></a>Lazily (down)loading content</h5><p>苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。</p>\n<h5 id=\"Wire-things-up-to-use-tags\"><a href=\"#Wire-things-up-to-use-tags\" class=\"headerlink\" title=\"Wire things up to use tags\"></a>Wire things up to use tags</h5><p>下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：<br><img src=\"/images/2016.01.04.10.png\" alt=\"\"></p>\n<p>然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。<br><img src=\"/images/2016.01.04.11.png\" alt=\"\">  </p>\n<blockquote>\n<p>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   </p>\n</blockquote>\n<h4 id=\"Make-it-download-faster\"><a href=\"#Make-it-download-faster\" class=\"headerlink\" title=\"Make it download faster\"></a>Make it download faster</h4><p>在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add 为新添加的 ProgressView是程序已经添加上的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">  <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\"></span><br><span class=\"line\">  bundleResource.loadingPriority = <span class=\"type\">NSBundleResourceRequestLoadingPriorityUrgent</span>  <span class=\"comment\">//add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  loadingProgressView.observedProgress = bundleResource.progress <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  loadingProgressView.hidden = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">  <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"keyword\">self</span>?.loadingProgressView.hidden = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。</p>\n</blockquote>\n<h4 id=\"The-many-flavors-of-tagging\"><a href=\"#The-many-flavors-of-tagging\" class=\"headerlink\" title=\"The many flavors of tagging\"></a>The many flavors of tagging</h4><p>虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。</p>\n<h5 id=\"Initial-install-tags\"><a href=\"#Initial-install-tags\" class=\"headerlink\" title=\"Initial install tags\"></a>Initial install tags</h5><p>使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：</p>\n<ul>\n<li><strong>Initial Install Tags</strong> 在ipa下载的时候一同下载</li>\n<li><strong>Prefetched Tag Order</strong> 在程序下载完成后，下载对应的资源，然后按顺序排列。</li>\n<li><strong>Prefetched Tag Order</strong> 按需下载<br>下面是配置的地方：<br><img src=\"/images/2016.01.04.12.png\" alt=\"\">  </li>\n</ul>\n<h4 id=\"Purging-content\"><a href=\"#Purging-content\" class=\"headerlink\" title=\"Purging content\"></a>Purging content</h4><p>应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：<br><img src=\"/images/2016.01.04.13.png\" alt=\"\">  </p>\n<h5 id=\"Set-a-resource-to-be-purged\"><a href=\"#Set-a-resource-to-be-purged\" class=\"headerlink\" title=\"Set a resource to be purged\"></a>Set a resource to be purged</h5><p>在MapChromeViewController.swift添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// new add 是新加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> overlayBundleResource: <span class=\"type\">NSBundleResourceRequest</span>? <span class=\"comment\">// new add</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\">    overlayBundleResource = bundleResource <span class=\"comment\">// new add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.loadingPriority = <span class=\"type\">NSBundleResourceRequestLoadingPriorityUrgent</span>  <span class=\"comment\">//add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    loadingProgressView.observedProgress = bundleResource.progress <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    loadingProgressView.hidden = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">    <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>?.loadingProgressView.hidden = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// new add</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidDisappear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidDisappear(animated)</span><br><span class=\"line\">    <span class=\"comment\">// 告诉系统结束了对资源的访问</span></span><br><span class=\"line\">    overlayBundleResource?.endAccessingResources()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。</p>\n<p>坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。</p>\n","excerpt":"<blockquote>\n<p>这篇文章在书中的标题是App Thinning，这里我给翻译成了App 瘦身。</p>\n<p>本文然然进行了一些语法的修改，很开心她为我修改这些东西。她说我转折只会用但是，被她这么一说想想还真是只是会用但是，嘿嘿。  </p>\n</blockquote>\n<p>iPhone经过这几年的发展，已经发生了很大的变化，例如屏幕变得更加多样，尺寸更多，内存变得更大，CPU的架构也在变化。伴随着iPhone的变化，iOS也在变化，例如AutoLayout、size classes、split view controller等。这些技术及设备的变化给我在开发的过程中也造成了许多的问题，不仅如此苹果通过不断推出新的技术，努力在帮助我们使用同一套代码开发适应多个设备的Universal的App。另一方面Universal App虽然在开发的过程中，方便了我们开发人员，可是对于用户来说就不那么友好了，由于需要适配多种设备，所以里包含所有设备的代码，但真正的在运行的时候，我们并不需要那么多相关的代码及资源。    </p>\n<p>例如下面的一张图，是一个App运行在iPhone 6+上，使用的各个资源相关的情况：<br><img src=\"/images/2016.01.04.01.png\" alt=\"\">   </p>\n<p>上图中对勾标出来的是在iPhone 6+上真实运行的时候使用到的相关的资源及代码，对比有对勾的部分，更多的是没有被对勾标出来的部分。可以想象我们下载了一个App（前提这个App是Universal的），然后至少一半的代码及资源是我们不需要的，白白占用着我们的空间。这样对用户体验也不好。为了解决这个问题苹果在iOS 9给出了新的解决方案：</p>","more":"<ul>\n<li>App Slicing 当你提交你的iOS 9 打包文件到App Store的时候，苹果编译你的资源和可执行文件，然后为每个设备生成一个特定的可执行文件。最终，设备只会下载适应与其特性的，并且它使用到的内容。这些特性包含显卡性能（原文单词：graphics capabilities）、内存级别、CPU架构、size classes、屏幕 scaling等。  </li>\n<li>On Demand Resouces 应用程序的资源只有在需要使用的时候才会下载，并且如果其他资源需要空间这些资源可以被移除。</li>\n<li>Bitcode 在你提交App到App Store的时候，Bitcode可以作为中间产物一起提交。包含bitcode配置的程序将会在App store上被编译和链接。bitcode允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到App store上。   </li>\n</ul>\n<p>这三个技术加起来，统一称为App Thinning。</p>\n<h3 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h3><p>打开本章节的初始项目，然后选在iPad Air 2运行，这时候运行效果如下：<br><img src=\"/images/2016.01.04.02.png\" alt=\"\"></p>\n<p>伴随着模拟器启动起来的还打开了一个Finder窗口：<br><img src=\"/images/2016.01.04.03.png\" alt=\"\"></p>\n<p>这个Finder窗口能够打开，是因为在程序中添加了一个脚本，每次运行的时候都会执行，脚本所在地方如下：<br><img src=\"/images/2016.01.04.04.png\" alt=\"\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &quot;App Size in KB:  `du -sk \\&quot;$&#123;CONFIGURATION_BUILD_DIR&#125;/$&#123;EXECUTABLE_NAME&#125;.app\\&quot;`&quot;</span><br><span class=\"line\">if [ &quot;$&#123;CONFIGURATION&#125;&quot; = &quot;Debug&quot; ]; then</span><br><span class=\"line\">open $&#123;CONFIGURATION_BUILD_DIR&#125;</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>   </p>\n<p>在Finder的Old CA Maps点击右键，选择显示包内容，如下：<br><img src=\"/images/2016.01.04.05.png\" alt=\"\">   </p>\n<p>上图中标注的说明如下：</p>\n<ol>\n<li>Assets.car是Assets.xcassets被Xcode进行编译后的文件。</li>\n<li>Old CA Maps是真实运行在设备上的可执行文件。</li>\n<li>Santa Cruz PNGs 这个是图片文件，但是没有被编译到Assets.car文件中，这是因为它并没有放到Assets.xcassets中，而是放到了工程的顶层文件中。</li>\n<li>SD_Map.bundle 这个就是地图图片文件，但是将近120MB。</li>\n</ol>\n<h4 id=\"Measuring-your-work\"><a href=\"#Measuring-your-work\" class=\"headerlink\" title=\"Measuring your work\"></a>Measuring your work</h4><p>本章介绍一些App瘦身相关的东西，所以我们必须能够测量App是否减少了。工程里面已经内置了一个脚本（上面代码里面有），能够在build的过程中输出App的大小。查看的位置如下：<br><img src=\"/images/2016.01.04.06.png\" alt=\"\">   </p>\n<h3 id=\"Slicing-up-app-slicing\"><a href=\"#Slicing-up-app-slicing\" class=\"headerlink\" title=\"Slicing up app slicing\"></a>Slicing up app slicing</h3><p>App slicing包含两部分内容：可执行文件分片（Executable slicing）和资源分片（resource slicing）。    </p>\n<p><strong>Executable slicing</strong> 指的是在设备下载App的时候会根据设备的相关信息只是下载对应该设备的相关的可执行文件，并不会包含其他设备及架构的可执行文件，达到App安装包的缩小。并且这个功能并不需要我们做太多，App Store默认支持的。   </p>\n<p>默认情况下提交到App Store的包是包含所有的内容的，这些都在配置文件里面，App Store会自动创建对应于每个类型的可执行文件。这个在iOS9+上支持。</p>\n<h4 id=\"Being-smart-with-resources\"><a href=\"#Being-smart-with-resources\" class=\"headerlink\" title=\"Being smart with resources\"></a>Being smart with resources</h4><p><strong>Resource slicing</strong> 需要我们一小部分简单的工作就能实现。如果使用Resource slicing，则要保证我们的资源都被Asset Catalogs管理。在Xcode 7中，能够标记资源被使用设备的 <strong>Memory</strong> 和 <strong>Graphics</strong> ，如下：<br><img src=\"/images/2016.01.04.07.png\" alt=\"\"></p>\n<h5 id=\"Your-first-fix\"><a href=\"#Your-first-fix\" class=\"headerlink\" title=\"Your first fix\"></a>Your first fix</h5><p>在开始的时候介绍过Santa Cruz PNGs这个文件因为被放到Main bundle中，所以不能被编译进入到Assets.car，进而也不能使用Resource slicing。下面看一下我们怎么修改，使其能够使用：<br><img src=\"/images/2016.01.04.08.png\" alt=\"\"></p>\n<p>选择New Image Set后，将新加入的set命名为Santa Cruz，紧接着做如下操作：<br><img src=\"/images/2016.01.04.09.png\" alt=\"\">  </p>\n<blockquote>\n<p>纠正一下 上图左边的内容应该是删除，包括在Finder内也应该删除   </p>\n</blockquote>\n<p>然后在不同的设备上运行App，最后发现Asset.car文件的大小并不一致。这个是因为在安装的时候，会根据设备安装对应的资源。   </p>\n<h5 id=\"Lazily-down-loading-content\"><a href=\"#Lazily-down-loading-content\" class=\"headerlink\" title=\"Lazily (down)loading content\"></a>Lazily (down)loading content</h5><p>苹果提供On-Demand Resources技术，简称ODR。ODR允许你将资源存储在苹果的服务器上，然后在你App使用的时候再去下载。NSBundleResourceRequest是处理ODR的类，使用这个类能够通过tag下载对应的资源。images, data, OpenGL shaders, SpriteKit Particles, Watchkit Complications等都可以使用ODR。</p>\n<h5 id=\"Wire-things-up-to-use-tags\"><a href=\"#Wire-things-up-to-use-tags\" class=\"headerlink\" title=\"Wire things up to use tags\"></a>Wire things up to use tags</h5><p>下面我们修改代码，实现资源的下载，修改MapChromeViewController.swift对应方法如下：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>    </p>\n<p>这时候我们运行代码，可能会在控制台输出错误，这是因为我们对应的bundle并没有tag，我们需要给bundle添加tag：<br><img src=\"/images/2016.01.04.10.png\" alt=\"\"></p>\n<p>然后我们重新编译运行我们的程序，然后按照上面的查看编译运行的程序的大小，发现小了许多。对比之前的编译生成的文件，发现运行文件里面不包含bundle了。<br><img src=\"/images/2016.01.04.11.png\" alt=\"\">  </p>\n<blockquote>\n<p>如果你的App在App Store上可能这个资源文件下载的很慢。但是在开发的过程中，Xcode会利用本地网络作为服务器，然后在设备上能够下载到，所以在开发的过程中如果电脑关了，那ODR也就不能使用了。   </p>\n</blockquote>\n<h4 id=\"Make-it-download-faster\"><a href=\"#Make-it-download-faster\" class=\"headerlink\" title=\"Make it download faster\"></a>Make it download faster</h4><p>在我们使用ODR的过程中，如果bundle比较大，可能再下载的过程中就会比较耗时，并且在下载过程中用户不知道，这样用户体验就不好。我们可以再Resource下载的过程中给用户一些提示，修改下面的代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// add 为新添加的 ProgressView是程序已经添加上的</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">  <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\"></span><br><span class=\"line\">  bundleResource.loadingPriority = <span class=\"type\">NSBundleResourceRequestLoadingPriorityUrgent</span>  <span class=\"comment\">//add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  loadingProgressView.observedProgress = bundleResource.progress <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  loadingProgressView.hidden = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">  <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">  bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"keyword\">self</span>?.loadingProgressView.hidden = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>如果用户已经下载过某个bundle，下次在使用的时候就不会再去下载了。</p>\n</blockquote>\n<h4 id=\"The-many-flavors-of-tagging\"><a href=\"#The-many-flavors-of-tagging\" class=\"headerlink\" title=\"The many flavors of tagging\"></a>The many flavors of tagging</h4><p>虽然添加了ProgressView，在体验是好了一点，但是需要注意测试的时候是使用的本地的网络，所以比较快，但是如果要是提交到App Store上，那可能下载就是比较慢了，如果再配上用户没有WiFi那可能就没法用了，所以我们还需要做其他的一些调整。</p>\n<h5 id=\"Initial-install-tags\"><a href=\"#Initial-install-tags\" class=\"headerlink\" title=\"Initial install tags\"></a>Initial install tags</h5><p>使用Initial install tags，我们可以设置哪些bundle会在我们App初始化安装的时候就会被下载。 下面下介绍一下ODR三种下载的时机吧：</p>\n<ul>\n<li><strong>Initial Install Tags</strong> 在ipa下载的时候一同下载</li>\n<li><strong>Prefetched Tag Order</strong> 在程序下载完成后，下载对应的资源，然后按顺序排列。</li>\n<li><strong>Prefetched Tag Order</strong> 按需下载<br>下面是配置的地方：<br><img src=\"/images/2016.01.04.12.png\" alt=\"\">  </li>\n</ul>\n<h4 id=\"Purging-content\"><a href=\"#Purging-content\" class=\"headerlink\" title=\"Purging content\"></a>Purging content</h4><p>应用程序在使用的过程中通过ODR下载了对应的bundle，但是有时候我们需要清理一些已经下载过的并且不使用的bundle。在介绍怎么删除之前先看一下怎么查看下载的ODR：<br><img src=\"/images/2016.01.04.13.png\" alt=\"\">  </p>\n<h5 id=\"Set-a-resource-to-be-purged\"><a href=\"#Set-a-resource-to-be-purged\" class=\"headerlink\" title=\"Set a resource to be purged\"></a>Set a resource to be purged</h5><p>在MapChromeViewController.swift添加如下代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">// new add 是新加的代码</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> overlayBundleResource: <span class=\"type\">NSBundleResourceRequest</span>? <span class=\"comment\">// new add</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">downloadAndDisplayMapOverlay</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//    displayOverlayFromBundle(NSBundle.mainBundle())</span></span><br><span class=\"line\">    <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> bundleTitle = mapOverlayData?.bundleTitle <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> bundleResource = <span class=\"type\">NSBundleResourceRequest</span>(tags: [bundleTitle])</span><br><span class=\"line\">    overlayBundleResource = bundleResource <span class=\"comment\">// new add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.loadingPriority = <span class=\"type\">NSBundleResourceRequestLoadingPriorityUrgent</span>  <span class=\"comment\">//add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    loadingProgressView.observedProgress = bundleResource.progress <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    loadingProgressView.hidden = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">    <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\"></span><br><span class=\"line\">    bundleResource.beginAccessingResourcesWithCompletionHandler &#123; [<span class=\"keyword\">weak</span> <span class=\"keyword\">self</span>] (error) -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">      <span class=\"type\">NSOperationQueue</span>.mainQueue().addOperationWithBlock(&#123; () -&gt; <span class=\"type\">Void</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>?.loadingProgressView.hidden = <span class=\"literal\">true</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">        <span class=\"type\">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class=\"literal\">false</span> <span class=\"comment\">// add</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> error == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">self</span>?.displayOverlayFromBundle(bundleResource.bundle)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// new add</span></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidDisappear</span><span class=\"params\">(animated: Bool)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidDisappear(animated)</span><br><span class=\"line\">    <span class=\"comment\">// 告诉系统结束了对资源的访问</span></span><br><span class=\"line\">    overlayBundleResource?.endAccessingResources()</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，我做测试的时候不清楚会在什么时候会删除，我也模拟了内存警告，如果谁清楚，还请告诉我，谢谢。</p>\n<p>坚持了好几天中午写完了，这篇笔记，一篇笔记13张截图，好累。</p>"},{"title":"iOS9 by Tutorials 学习笔记六：UIStackView & Auto Layout Changes","date":"2016-01-13T14:20:34.000Z","_content":"\n今天这是第六篇笔记，现在回过头去看，我也没有想到自己能够更新到第六篇。我算是一个比较懒的人了，现在已经不太喜欢动手敲代码了。在写这几篇笔记的时候，我需要一边看英文的文档，一边测试代码，还得考虑怎么能够写明白。这里有点说明，我的英语水平只是四级，语文水平只能用呵呵评价了，文章中的语句难免会有不通顺的地方，希望能够把语义表述清楚。    \n\n闲话多了，回到正题，这篇文章介绍UIStackView和一些Auto Layout的改变。   \n\nUIStackView我个人理解是为了解决使用Storyboard添加的约束需要经常变化的情况。我想我们可能都在开发中遇到过修改约束的情况，一般是把约束与一个outlet的约束link起来，然后代码修改，但是这个操作起来是不方便的。UIStackView通过修改一些简单的属性，例如alignment, distribution, and spacing，从而让UIStackView根据我们的修改自动调整内部的显示。    \n\nAuto Layout的改变主要是介绍layout anchors和layout guides。\n\n<!---more--->\n\n### Getting Started   \n打开本章的配套的工程VacationSpots，在iPhone 6模拟器上运行，能够看到APP有一些UI的问题，不要担心，在后面将会修复这些问题。简单梳理一下问题如下：\n1. 图中标出的内容没有在垂直方向居中\n![](/images/2016.01.13/01.png)  \n\n2. 点击列表中的London Cell进入详情页面，最下面的三个按钮没有平均分配空间：\n![](/images/2016.01.13/02.png)  \n\n3. 点击WEATHER旁边的hide按钮，内容是被隐藏了，但是留下了一块空白，下面的内容没有移动上来：\n![](/images/2016.01.13/03.png)    \n\n4. WHAT TO SEE 部分在WHY VISIT的下面会更加合理一点。  \n\n现在已经了解了这些问题，下面开始用UIStackView来修改这些问题。打开Main.storyboard，查看如下的Controller scene：\n![](/images/2016.01.13/04.png)    \n>能够注意到上面的每个对应的控件都有背景颜色，这个只是为了帮助我们查看这些属性的变化。这些背景颜色在运行的时候都会被去掉，通过如下代码，如果你想让它们在运行的时候也显示注释掉这些代码就可以：\n{% codeblock lang:swift %}\n// SpotInfoViewController.swift\n override func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Clear background colors from labels and buttons\n    for view in backgroundColoredViews {\n      view.backgroundColor = UIColor.clearColor()\n    }\n\n    ........\n  }\n{% endcodeblock %}    \n\n在Storyboard中的的控件都通过outlet与SpotInfoViewController.swift中对应的属性进行了关联。在storyboard中显示的名字对应SpotInfoViewController.swift对应的变量。  \n\n#### Your first stack view\n我们先用Stack View解决我们问题列表中底部按钮的问题。使用UIStackView能够在一个坐标抽上分配位置和控件之间的空间。幸运的是将Views嵌入到UIStackView中并没有太难。在Storyboard中的Spot Info View Controller选择如下三个按钮控件：\n![](/images/2016.01.13/05.png)\n\n选择好三个按钮后，在Storyboard中点击如下的按钮：\n![](/images/2016.01.13/06.png)\n\n当Views被嵌入UIStackView之后，Views的约束都被移除了，同时需要设置UIStackView的约束。选中UIStackView，然后按照如图添加约束：\n![](/images/2016.01.13/07.png)\n\n>这里有个选择UIStackView的技巧，由于UIStackView是在按钮的后面，很不好选中，我们可以按住Shift，右击，在出现的菜单中列出来当前点击位置所有的View，我们可以选择UIstackView。另一种方法我们可以在outline view中选择。   \n\n设置好约束后，能够看到按钮显示如下，第一个按钮被拉伸了，填充满了UIStackView的剩余空间。UIstackView有一个Distribution属性，用于控制Views怎么在UIStackView中显示，现在设置的是Fill，即将会填充满UIStackView。为了这个目的，UIstackView将会根据View的ccontent hugging优先级去拉伸View，最低的将会被拉伸。如果优先级一样，将会拉伸第一个。\n![](/images/2016.01.13/08.png)  \n\n我们的目的是让View间的距离相等，在Attributes inspector中修改Distribution为Equal Spacing。\n![](/images/2016.01.13/09.png)\n\n运行APP，能够看到我们的按钮显示正确了：\n![](/images/2016.01.13/10.png)  \n\n#### 一些思考\n思考一下你使用Auto Layout，通过约束实现上面的要求，那将是一种什么令人\"愉悦\"的行为。可能你很熟悉Auto Layout，认为这些东西都很简单，那么你在考虑一下如果我们后面有需求添加一个按钮，删除一个按钮呢，怎么办呢？约束删除了重新添加吗？如果使用UIStackView，这些将变得比较简单，只要我们添加或者删除View，其他的工作UIstackView就会帮我们做了。    \n\nUISTackView的更加深入的讲解，将会在下一篇文章中继续介绍。这里先介绍一下Auto Layout的新特性：layout anchors和layout guides。\n\n### Layout anchors\nLayout anchors提供了我们一种简单的创建约束的方式。  \n\n想象一下我们在iOS 9之前创建一个约束，简直就是天书，但是在iOS 9中使用Layout anchors将会简单好多，下面是两种的对比：\n{% codeblock lang:swift %}\n// iOS9以前\nlet constraint = NSLayoutConstraint(item: topLabel, attribute: .Bottom, relatedBy: .Equal, toItem: bottomLabel, attribute: .Top, multiplier: 1, constant: 8)\n\n// iOS 9\nlet constraint = topLabel.bottomAnchor.constraintEqualToAnchor(bottomLabel.topAnchor, constant: 8)\n{% endcodeblock %}   \n\nLayout anchors不仅理解起来简单，而且写起来也简单了。   \n\n对应于我们在iOS 9以前添加约束时候的attribute，基本都有与之对应的anchor，例如top对应topAnchor，bottom对应bottomAnchor等。Layout Anchor都是直接或者间接继承自NSLayoutAnchor，上面只是演示了一下相等的情况，我们都知道在约束中又大于小于等，下面列出NSLayoutAnchor的接口文件，从接口文件中能够清楚的了解到对应的方法：\n{% codeblock lang:swift %}\nimport Foundation\nimport UIKit\n\n/*\tNSLayoutAnchor.h\n\tCopyright (c) 2015, Apple Inc. All rights reserved.\n*/\n\n/* An NSLayoutAnchor represents an edge or dimension of a layout item.  Its concrete \n subclasses allow concise creation of constraints.  \n    Instead of invoking \n \n +[NSLayoutConstraint constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:] \n \n directly, you can instead do something like this:\n \n [myView.topAnchor constraintEqualToAnchor:otherView.topAnchor constant:10];\n \n The -constraint* methods are available in multiple flavors to support use of different\n relations and omission of unused options.\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutAnchor : NSObject {\n    \n    /* These methods return an inactive constraint of the form thisAnchor = otherAnchor.\n     */\n    public func constraintEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.\n     */\n    public func constraintEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n}\n\n/* Axis-specific subclasses for location anchors: top/bottom, leading/trailing, baseline, etc.\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutXAxisAnchor : NSLayoutAnchor {\n}\n\n@available(iOS 9.0, *)\npublic class NSLayoutYAxisAnchor : NSLayoutAnchor {\n}\n\n/* This layout anchor subclass is used for sizes (width & height).\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutDimension : NSLayoutAnchor {\n    \n    /* These methods return an inactive constraint of the form \n        thisVariable = constant.\n    */\n    public func constraintEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form \n        thisAnchor = otherAnchor * multiplier.\n    */\n    public func constraintEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form \n        thisAnchor = otherAnchor * multiplier + constant.\n    */\n    public func constraintEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n}\n{% endcodeblock %}   \n\n在上面的接口文件中，我们能够清楚的了解到NSLayoutAnchor有三个子类：NSLayoutXAxisAnchor，NSLayoutYAxisAnchor，NSLayoutDimension。下面列出了UIView的Anchor都是对应的那种类型：\n{% codeblock lang:swift %}\nextension UIView {\n    /* Constraint creation conveniences. See NSLayoutAnchor.h for details.\n     */\n    @available(iOS 9.0, *)\n    public var leadingAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var trailingAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var leftAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var rightAnchor: NSLayoutXAxisAnchor { get }\n\t@available(iOS 9.0, *)\n    public var centerXAnchor: NSLayoutXAxisAnchor { get }\n\n    @available(iOS 9.0, *)\n    public var topAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var bottomAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var firstBaselineAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var lastBaselineAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var centerYAnchor: NSLayoutYAxisAnchor { get }\n\n    @available(iOS 9.0, *)\n    public var widthAnchor: NSLayoutDimension { get }\n    @available(iOS 9.0, *)\n    public var heightAnchor: NSLayoutDimension { get }\n}\n{% endcodeblock %}   \n\n上面UIView的Anchor属性被分成了三类，同样我们在设置属性的时候，也要求同类的属性的才能设置，比如ViewA和ViewB之间的约束，ViewA-topAnchor和ViewB-bottomAnchor是可以的，ViewA-topAnchor和ViewB-leftAnchor就是不允许的，如果这样的话编译器会警告，运行时也会报错。\n> 注意： whyVisitLabel.topAnchor.constraintEqualToAnchor(whatToSeeLabel.leftAnchor) 这个按照上面的说法应该会报错的，但是我在运行的时候也没有报错，可能是我这里只是随便写出一个做测试的原因，后续我会继续试验一下这个知识点，然后再改正。   \n\n### Layout guides\n有时候我们想设置两个View之间的空间，需要在两个View之间添加一个不可见的View（dummy view），然后在设置约束。Layout guide可以理解为一个隐形的不可见View，我们能够使用它的矩形边缘来布局，我们可以像我们使用View一样设置约束。使用Layout guide的好处是轻量，而且不会在view的层级中，也不会参与事件的响应过程。layout guide也包含除了firstBaselineAnchor和lastBaselineAnchor之外的View所有的Anchor。 \n\n#### Fixing the alignment bug\n下面就利用layout guide来修复列表页面文字内容上下不居中的问题。看下图是我们设置的约束，我们设置label距离上面的距离是15，当下面的label显示一行的时候是正常的，如果要是两行了，由于上面的约束是固定的，最终就变成了不居中的效果了。\n![](/images/2016.01.13/11.png)   \n\n在iOS 9之前，我们想解决这个问题可以把两个label放置到一个container view容器中，设置这个container view为剧中，这里面的container view就是不可见的view即dummy view。现在在iOS 9上我们可以使用layout guide来代替这个view。   \n\n目前只能通过代码来添加layout guide。打开VacationSpotCell.swift文件，修改对应代码：\n{% codeblock lang:swift %}\noverride func awakeFromNib() {\n    super.awakeFromNib()\n\n    // TODO: Add layoutGuide code here to center the name and locationName labels vertically\n    \n    // 创建layou guide\n    let layoutGuide = UILayoutGuide()\n    contentView.addLayoutGuide(layoutGuide)\n    \n    // 设置layout guide的约束\n    let topConstraint = layoutGuide.topAnchor.constraintEqualToAnchor(nameLabel.topAnchor)\n    let bottomConstraint = layoutGuide.bottomAnchor.constraintEqualToAnchor(locationNameLabel.bottomAnchor)\n    let centerConstraint = layoutGuide.centerYAnchor.constraintEqualToAnchor(contentView.centerYAnchor)\n    \n    // 激活layout guide的约束\n    NSLayoutConstraint.activateConstraints([topConstraint, bottomConstraint, centerConstraint])\n  }\n{% endcodeblock %}\n\n运行APP发现，部分文字被截断了：\n![](/images/2016.01.13/12.png) \n\n#### 处理截断问题\n这个原因是我们设置layout guide居中，但是nameLabel(上面的)与super view top的约束还存在，造成了下面的label被挤压了，这时候我们只要删除掉这个约束就可以了。但是删除了之后storyboard会提示错误，这时候我们可以使用占位约束，这个主要是为了使storyboard不报错，在运行的时候并不会使用。\n![](/images/2016.01.13/13.png) \n\n最近一直在加班，断断续续整理了好久终于整理完了这篇文章了，可能会有错误，还请大家指出。\n","source":"_posts/iOS9-by-Tutorials-学习笔记六：UIStackView-Auto-Layout-Changes.md","raw":"title: 'iOS9 by Tutorials 学习笔记六：UIStackView & Auto Layout Changes'\ndate: 2016-01-13 22:20:34\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\n今天这是第六篇笔记，现在回过头去看，我也没有想到自己能够更新到第六篇。我算是一个比较懒的人了，现在已经不太喜欢动手敲代码了。在写这几篇笔记的时候，我需要一边看英文的文档，一边测试代码，还得考虑怎么能够写明白。这里有点说明，我的英语水平只是四级，语文水平只能用呵呵评价了，文章中的语句难免会有不通顺的地方，希望能够把语义表述清楚。    \n\n闲话多了，回到正题，这篇文章介绍UIStackView和一些Auto Layout的改变。   \n\nUIStackView我个人理解是为了解决使用Storyboard添加的约束需要经常变化的情况。我想我们可能都在开发中遇到过修改约束的情况，一般是把约束与一个outlet的约束link起来，然后代码修改，但是这个操作起来是不方便的。UIStackView通过修改一些简单的属性，例如alignment, distribution, and spacing，从而让UIStackView根据我们的修改自动调整内部的显示。    \n\nAuto Layout的改变主要是介绍layout anchors和layout guides。\n\n<!---more--->\n\n### Getting Started   \n打开本章的配套的工程VacationSpots，在iPhone 6模拟器上运行，能够看到APP有一些UI的问题，不要担心，在后面将会修复这些问题。简单梳理一下问题如下：\n1. 图中标出的内容没有在垂直方向居中\n![](/images/2016.01.13/01.png)  \n\n2. 点击列表中的London Cell进入详情页面，最下面的三个按钮没有平均分配空间：\n![](/images/2016.01.13/02.png)  \n\n3. 点击WEATHER旁边的hide按钮，内容是被隐藏了，但是留下了一块空白，下面的内容没有移动上来：\n![](/images/2016.01.13/03.png)    \n\n4. WHAT TO SEE 部分在WHY VISIT的下面会更加合理一点。  \n\n现在已经了解了这些问题，下面开始用UIStackView来修改这些问题。打开Main.storyboard，查看如下的Controller scene：\n![](/images/2016.01.13/04.png)    \n>能够注意到上面的每个对应的控件都有背景颜色，这个只是为了帮助我们查看这些属性的变化。这些背景颜色在运行的时候都会被去掉，通过如下代码，如果你想让它们在运行的时候也显示注释掉这些代码就可以：\n{% codeblock lang:swift %}\n// SpotInfoViewController.swift\n override func viewDidLoad() {\n    super.viewDidLoad()\n\n    // Clear background colors from labels and buttons\n    for view in backgroundColoredViews {\n      view.backgroundColor = UIColor.clearColor()\n    }\n\n    ........\n  }\n{% endcodeblock %}    \n\n在Storyboard中的的控件都通过outlet与SpotInfoViewController.swift中对应的属性进行了关联。在storyboard中显示的名字对应SpotInfoViewController.swift对应的变量。  \n\n#### Your first stack view\n我们先用Stack View解决我们问题列表中底部按钮的问题。使用UIStackView能够在一个坐标抽上分配位置和控件之间的空间。幸运的是将Views嵌入到UIStackView中并没有太难。在Storyboard中的Spot Info View Controller选择如下三个按钮控件：\n![](/images/2016.01.13/05.png)\n\n选择好三个按钮后，在Storyboard中点击如下的按钮：\n![](/images/2016.01.13/06.png)\n\n当Views被嵌入UIStackView之后，Views的约束都被移除了，同时需要设置UIStackView的约束。选中UIStackView，然后按照如图添加约束：\n![](/images/2016.01.13/07.png)\n\n>这里有个选择UIStackView的技巧，由于UIStackView是在按钮的后面，很不好选中，我们可以按住Shift，右击，在出现的菜单中列出来当前点击位置所有的View，我们可以选择UIstackView。另一种方法我们可以在outline view中选择。   \n\n设置好约束后，能够看到按钮显示如下，第一个按钮被拉伸了，填充满了UIStackView的剩余空间。UIstackView有一个Distribution属性，用于控制Views怎么在UIStackView中显示，现在设置的是Fill，即将会填充满UIStackView。为了这个目的，UIstackView将会根据View的ccontent hugging优先级去拉伸View，最低的将会被拉伸。如果优先级一样，将会拉伸第一个。\n![](/images/2016.01.13/08.png)  \n\n我们的目的是让View间的距离相等，在Attributes inspector中修改Distribution为Equal Spacing。\n![](/images/2016.01.13/09.png)\n\n运行APP，能够看到我们的按钮显示正确了：\n![](/images/2016.01.13/10.png)  \n\n#### 一些思考\n思考一下你使用Auto Layout，通过约束实现上面的要求，那将是一种什么令人\"愉悦\"的行为。可能你很熟悉Auto Layout，认为这些东西都很简单，那么你在考虑一下如果我们后面有需求添加一个按钮，删除一个按钮呢，怎么办呢？约束删除了重新添加吗？如果使用UIStackView，这些将变得比较简单，只要我们添加或者删除View，其他的工作UIstackView就会帮我们做了。    \n\nUISTackView的更加深入的讲解，将会在下一篇文章中继续介绍。这里先介绍一下Auto Layout的新特性：layout anchors和layout guides。\n\n### Layout anchors\nLayout anchors提供了我们一种简单的创建约束的方式。  \n\n想象一下我们在iOS 9之前创建一个约束，简直就是天书，但是在iOS 9中使用Layout anchors将会简单好多，下面是两种的对比：\n{% codeblock lang:swift %}\n// iOS9以前\nlet constraint = NSLayoutConstraint(item: topLabel, attribute: .Bottom, relatedBy: .Equal, toItem: bottomLabel, attribute: .Top, multiplier: 1, constant: 8)\n\n// iOS 9\nlet constraint = topLabel.bottomAnchor.constraintEqualToAnchor(bottomLabel.topAnchor, constant: 8)\n{% endcodeblock %}   \n\nLayout anchors不仅理解起来简单，而且写起来也简单了。   \n\n对应于我们在iOS 9以前添加约束时候的attribute，基本都有与之对应的anchor，例如top对应topAnchor，bottom对应bottomAnchor等。Layout Anchor都是直接或者间接继承自NSLayoutAnchor，上面只是演示了一下相等的情况，我们都知道在约束中又大于小于等，下面列出NSLayoutAnchor的接口文件，从接口文件中能够清楚的了解到对应的方法：\n{% codeblock lang:swift %}\nimport Foundation\nimport UIKit\n\n/*\tNSLayoutAnchor.h\n\tCopyright (c) 2015, Apple Inc. All rights reserved.\n*/\n\n/* An NSLayoutAnchor represents an edge or dimension of a layout item.  Its concrete \n subclasses allow concise creation of constraints.  \n    Instead of invoking \n \n +[NSLayoutConstraint constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:] \n \n directly, you can instead do something like this:\n \n [myView.topAnchor constraintEqualToAnchor:otherView.topAnchor constant:10];\n \n The -constraint* methods are available in multiple flavors to support use of different\n relations and omission of unused options.\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutAnchor : NSObject {\n    \n    /* These methods return an inactive constraint of the form thisAnchor = otherAnchor.\n     */\n    public func constraintEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor!) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.\n     */\n    public func constraintEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor!, constant c: CGFloat) -> NSLayoutConstraint!\n}\n\n/* Axis-specific subclasses for location anchors: top/bottom, leading/trailing, baseline, etc.\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutXAxisAnchor : NSLayoutAnchor {\n}\n\n@available(iOS 9.0, *)\npublic class NSLayoutYAxisAnchor : NSLayoutAnchor {\n}\n\n/* This layout anchor subclass is used for sizes (width & height).\n */\n\n@available(iOS 9.0, *)\npublic class NSLayoutDimension : NSLayoutAnchor {\n    \n    /* These methods return an inactive constraint of the form \n        thisVariable = constant.\n    */\n    public func constraintEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToConstant(c: CGFloat) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form \n        thisAnchor = otherAnchor * multiplier.\n    */\n    public func constraintEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat) -> NSLayoutConstraint!\n    \n    /* These methods return an inactive constraint of the form \n        thisAnchor = otherAnchor * multiplier + constant.\n    */\n    public func constraintEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n    public func constraintLessThanOrEqualToAnchor(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant c: CGFloat) -> NSLayoutConstraint!\n}\n{% endcodeblock %}   \n\n在上面的接口文件中，我们能够清楚的了解到NSLayoutAnchor有三个子类：NSLayoutXAxisAnchor，NSLayoutYAxisAnchor，NSLayoutDimension。下面列出了UIView的Anchor都是对应的那种类型：\n{% codeblock lang:swift %}\nextension UIView {\n    /* Constraint creation conveniences. See NSLayoutAnchor.h for details.\n     */\n    @available(iOS 9.0, *)\n    public var leadingAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var trailingAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var leftAnchor: NSLayoutXAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var rightAnchor: NSLayoutXAxisAnchor { get }\n\t@available(iOS 9.0, *)\n    public var centerXAnchor: NSLayoutXAxisAnchor { get }\n\n    @available(iOS 9.0, *)\n    public var topAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var bottomAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var firstBaselineAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var lastBaselineAnchor: NSLayoutYAxisAnchor { get }\n    @available(iOS 9.0, *)\n    public var centerYAnchor: NSLayoutYAxisAnchor { get }\n\n    @available(iOS 9.0, *)\n    public var widthAnchor: NSLayoutDimension { get }\n    @available(iOS 9.0, *)\n    public var heightAnchor: NSLayoutDimension { get }\n}\n{% endcodeblock %}   \n\n上面UIView的Anchor属性被分成了三类，同样我们在设置属性的时候，也要求同类的属性的才能设置，比如ViewA和ViewB之间的约束，ViewA-topAnchor和ViewB-bottomAnchor是可以的，ViewA-topAnchor和ViewB-leftAnchor就是不允许的，如果这样的话编译器会警告，运行时也会报错。\n> 注意： whyVisitLabel.topAnchor.constraintEqualToAnchor(whatToSeeLabel.leftAnchor) 这个按照上面的说法应该会报错的，但是我在运行的时候也没有报错，可能是我这里只是随便写出一个做测试的原因，后续我会继续试验一下这个知识点，然后再改正。   \n\n### Layout guides\n有时候我们想设置两个View之间的空间，需要在两个View之间添加一个不可见的View（dummy view），然后在设置约束。Layout guide可以理解为一个隐形的不可见View，我们能够使用它的矩形边缘来布局，我们可以像我们使用View一样设置约束。使用Layout guide的好处是轻量，而且不会在view的层级中，也不会参与事件的响应过程。layout guide也包含除了firstBaselineAnchor和lastBaselineAnchor之外的View所有的Anchor。 \n\n#### Fixing the alignment bug\n下面就利用layout guide来修复列表页面文字内容上下不居中的问题。看下图是我们设置的约束，我们设置label距离上面的距离是15，当下面的label显示一行的时候是正常的，如果要是两行了，由于上面的约束是固定的，最终就变成了不居中的效果了。\n![](/images/2016.01.13/11.png)   \n\n在iOS 9之前，我们想解决这个问题可以把两个label放置到一个container view容器中，设置这个container view为剧中，这里面的container view就是不可见的view即dummy view。现在在iOS 9上我们可以使用layout guide来代替这个view。   \n\n目前只能通过代码来添加layout guide。打开VacationSpotCell.swift文件，修改对应代码：\n{% codeblock lang:swift %}\noverride func awakeFromNib() {\n    super.awakeFromNib()\n\n    // TODO: Add layoutGuide code here to center the name and locationName labels vertically\n    \n    // 创建layou guide\n    let layoutGuide = UILayoutGuide()\n    contentView.addLayoutGuide(layoutGuide)\n    \n    // 设置layout guide的约束\n    let topConstraint = layoutGuide.topAnchor.constraintEqualToAnchor(nameLabel.topAnchor)\n    let bottomConstraint = layoutGuide.bottomAnchor.constraintEqualToAnchor(locationNameLabel.bottomAnchor)\n    let centerConstraint = layoutGuide.centerYAnchor.constraintEqualToAnchor(contentView.centerYAnchor)\n    \n    // 激活layout guide的约束\n    NSLayoutConstraint.activateConstraints([topConstraint, bottomConstraint, centerConstraint])\n  }\n{% endcodeblock %}\n\n运行APP发现，部分文字被截断了：\n![](/images/2016.01.13/12.png) \n\n#### 处理截断问题\n这个原因是我们设置layout guide居中，但是nameLabel(上面的)与super view top的约束还存在，造成了下面的label被挤压了，这时候我们只要删除掉这个约束就可以了。但是删除了之后storyboard会提示错误，这时候我们可以使用占位约束，这个主要是为了使storyboard不报错，在运行的时候并不会使用。\n![](/images/2016.01.13/13.png) \n\n最近一直在加班，断断续续整理了好久终于整理完了这篇文章了，可能会有错误，还请大家指出。\n","slug":"iOS9-by-Tutorials-学习笔记六：UIStackView-Auto-Layout-Changes","published":1,"updated":"2016-04-25T10:54:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cipyqsl0z00113is6uhkqo274","content":"<p>今天这是第六篇笔记，现在回过头去看，我也没有想到自己能够更新到第六篇。我算是一个比较懒的人了，现在已经不太喜欢动手敲代码了。在写这几篇笔记的时候，我需要一边看英文的文档，一边测试代码，还得考虑怎么能够写明白。这里有点说明，我的英语水平只是四级，语文水平只能用呵呵评价了，文章中的语句难免会有不通顺的地方，希望能够把语义表述清楚。    </p>\n<p>闲话多了，回到正题，这篇文章介绍UIStackView和一些Auto Layout的改变。   </p>\n<p>UIStackView我个人理解是为了解决使用Storyboard添加的约束需要经常变化的情况。我想我们可能都在开发中遇到过修改约束的情况，一般是把约束与一个outlet的约束link起来，然后代码修改，但是这个操作起来是不方便的。UIStackView通过修改一些简单的属性，例如alignment, distribution, and spacing，从而让UIStackView根据我们的修改自动调整内部的显示。    </p>\n<p>Auto Layout的改变主要是介绍layout anchors和layout guides。</p>\n<a id=\"more\"></a>\n<h3 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h3><p>打开本章的配套的工程VacationSpots，在iPhone 6模拟器上运行，能够看到APP有一些UI的问题，不要担心，在后面将会修复这些问题。简单梳理一下问题如下：</p>\n<ol>\n<li><p>图中标出的内容没有在垂直方向居中<br><img src=\"/images/2016.01.13/01.png\" alt=\"\">  </p>\n</li>\n<li><p>点击列表中的London Cell进入详情页面，最下面的三个按钮没有平均分配空间：<br><img src=\"/images/2016.01.13/02.png\" alt=\"\">  </p>\n</li>\n<li><p>点击WEATHER旁边的hide按钮，内容是被隐藏了，但是留下了一块空白，下面的内容没有移动上来：<br><img src=\"/images/2016.01.13/03.png\" alt=\"\">    </p>\n</li>\n<li><p>WHAT TO SEE 部分在WHY VISIT的下面会更加合理一点。  </p>\n</li>\n</ol>\n<p>现在已经了解了这些问题，下面开始用UIStackView来修改这些问题。打开Main.storyboard，查看如下的Controller scene：<br><img src=\"/images/2016.01.13/04.png\" alt=\"\">    </p>\n<blockquote>\n<p>能够注意到上面的每个对应的控件都有背景颜色，这个只是为了帮助我们查看这些属性的变化。这些背景颜色在运行的时候都会被去掉，通过如下代码，如果你想让它们在运行的时候也显示注释掉这些代码就可以：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SpotInfoViewController.swift</span></span><br><span class=\"line\"> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear background colors from labels and buttons</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews &#123;</span><br><span class=\"line\">      view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ........</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>    </p>\n</blockquote>\n<p>在Storyboard中的的控件都通过outlet与SpotInfoViewController.swift中对应的属性进行了关联。在storyboard中显示的名字对应SpotInfoViewController.swift对应的变量。  </p>\n<h4 id=\"Your-first-stack-view\"><a href=\"#Your-first-stack-view\" class=\"headerlink\" title=\"Your first stack view\"></a>Your first stack view</h4><p>我们先用Stack View解决我们问题列表中底部按钮的问题。使用UIStackView能够在一个坐标抽上分配位置和控件之间的空间。幸运的是将Views嵌入到UIStackView中并没有太难。在Storyboard中的Spot Info View Controller选择如下三个按钮控件：<br><img src=\"/images/2016.01.13/05.png\" alt=\"\"></p>\n<p>选择好三个按钮后，在Storyboard中点击如下的按钮：<br><img src=\"/images/2016.01.13/06.png\" alt=\"\"></p>\n<p>当Views被嵌入UIStackView之后，Views的约束都被移除了，同时需要设置UIStackView的约束。选中UIStackView，然后按照如图添加约束：<br><img src=\"/images/2016.01.13/07.png\" alt=\"\"></p>\n<blockquote>\n<p>这里有个选择UIStackView的技巧，由于UIStackView是在按钮的后面，很不好选中，我们可以按住Shift，右击，在出现的菜单中列出来当前点击位置所有的View，我们可以选择UIstackView。另一种方法我们可以在outline view中选择。   </p>\n</blockquote>\n<p>设置好约束后，能够看到按钮显示如下，第一个按钮被拉伸了，填充满了UIStackView的剩余空间。UIstackView有一个Distribution属性，用于控制Views怎么在UIStackView中显示，现在设置的是Fill，即将会填充满UIStackView。为了这个目的，UIstackView将会根据View的ccontent hugging优先级去拉伸View，最低的将会被拉伸。如果优先级一样，将会拉伸第一个。<br><img src=\"/images/2016.01.13/08.png\" alt=\"\">  </p>\n<p>我们的目的是让View间的距离相等，在Attributes inspector中修改Distribution为Equal Spacing。<br><img src=\"/images/2016.01.13/09.png\" alt=\"\"></p>\n<p>运行APP，能够看到我们的按钮显示正确了：<br><img src=\"/images/2016.01.13/10.png\" alt=\"\">  </p>\n<h4 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h4><p>思考一下你使用Auto Layout，通过约束实现上面的要求，那将是一种什么令人”愉悦”的行为。可能你很熟悉Auto Layout，认为这些东西都很简单，那么你在考虑一下如果我们后面有需求添加一个按钮，删除一个按钮呢，怎么办呢？约束删除了重新添加吗？如果使用UIStackView，这些将变得比较简单，只要我们添加或者删除View，其他的工作UIstackView就会帮我们做了。    </p>\n<p>UISTackView的更加深入的讲解，将会在下一篇文章中继续介绍。这里先介绍一下Auto Layout的新特性：layout anchors和layout guides。</p>\n<h3 id=\"Layout-anchors\"><a href=\"#Layout-anchors\" class=\"headerlink\" title=\"Layout anchors\"></a>Layout anchors</h3><p>Layout anchors提供了我们一种简单的创建约束的方式。  </p>\n<p>想象一下我们在iOS 9之前创建一个约束，简直就是天书，但是在iOS 9中使用Layout anchors将会简单好多，下面是两种的对比：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// iOS9以前</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> constraint = <span class=\"type\">NSLayoutConstraint</span>(item: topLabel, attribute: .<span class=\"type\">Bottom</span>, relatedBy: .<span class=\"type\">Equal</span>, toItem: bottomLabel, attribute: .<span class=\"type\">Top</span>, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// iOS 9</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> constraint = topLabel.bottomAnchor.constraintEqualToAnchor(bottomLabel.topAnchor, constant: <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>   </p>\n<p>Layout anchors不仅理解起来简单，而且写起来也简单了。   </p>\n<p>对应于我们在iOS 9以前添加约束时候的attribute，基本都有与之对应的anchor，例如top对应topAnchor，bottom对应bottomAnchor等。Layout Anchor都是直接或者间接继承自NSLayoutAnchor，上面只是演示了一下相等的情况，我们都知道在约束中又大于小于等，下面列出NSLayoutAnchor的接口文件，从接口文件中能够清楚的了解到对应的方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*\tNSLayoutAnchor.h</span><br><span class=\"line\">\tCopyright (c) 2015, Apple Inc. All rights reserved.</span><br><span class=\"line\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* An NSLayoutAnchor represents an edge or dimension of a layout item.  Its concrete </span><br><span class=\"line\"> subclasses allow concise creation of constraints.  </span><br><span class=\"line\">    Instead of invoking </span><br><span class=\"line\"> </span><br><span class=\"line\"> +[NSLayoutConstraint constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:] </span><br><span class=\"line\"> </span><br><span class=\"line\"> directly, you can instead do something like this:</span><br><span class=\"line\"> </span><br><span class=\"line\"> [myView.topAnchor constraintEqualToAnchor:otherView.topAnchor constant:10];</span><br><span class=\"line\"> </span><br><span class=\"line\"> The -constraint* methods are available in multiple flavors to support use of different</span><br><span class=\"line\"> relations and omission of unused options.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutAnchor</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form thisAnchor = otherAnchor.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Axis-specific subclasses for location anchors: top/bottom, leading/trailing, baseline, etc.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutXAxisAnchor</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutYAxisAnchor</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* This layout anchor subclass is used for sizes (width &amp; height).</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutDimension</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisVariable = constant.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisAnchor = otherAnchor * multiplier.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisAnchor = otherAnchor * multiplier + constant.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>在上面的接口文件中，我们能够清楚的了解到NSLayoutAnchor有三个子类：NSLayoutXAxisAnchor，NSLayoutYAxisAnchor，NSLayoutDimension。下面列出了UIView的Anchor都是对应的那种类型：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Constraint creation conveniences. See NSLayoutAnchor.h for details.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> leadingAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> trailingAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> leftAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> rightAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">\t<span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> centerXAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> topAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> bottomAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> firstBaselineAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> lastBaselineAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> centerYAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> widthAnchor: <span class=\"type\">NSLayoutDimension</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> heightAnchor: <span class=\"type\">NSLayoutDimension</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>上面UIView的Anchor属性被分成了三类，同样我们在设置属性的时候，也要求同类的属性的才能设置，比如ViewA和ViewB之间的约束，ViewA-topAnchor和ViewB-bottomAnchor是可以的，ViewA-topAnchor和ViewB-leftAnchor就是不允许的，如果这样的话编译器会警告，运行时也会报错。</p>\n<blockquote>\n<p>注意： whyVisitLabel.topAnchor.constraintEqualToAnchor(whatToSeeLabel.leftAnchor) 这个按照上面的说法应该会报错的，但是我在运行的时候也没有报错，可能是我这里只是随便写出一个做测试的原因，后续我会继续试验一下这个知识点，然后再改正。   </p>\n</blockquote>\n<h3 id=\"Layout-guides\"><a href=\"#Layout-guides\" class=\"headerlink\" title=\"Layout guides\"></a>Layout guides</h3><p>有时候我们想设置两个View之间的空间，需要在两个View之间添加一个不可见的View（dummy view），然后在设置约束。Layout guide可以理解为一个隐形的不可见View，我们能够使用它的矩形边缘来布局，我们可以像我们使用View一样设置约束。使用Layout guide的好处是轻量，而且不会在view的层级中，也不会参与事件的响应过程。layout guide也包含除了firstBaselineAnchor和lastBaselineAnchor之外的View所有的Anchor。 </p>\n<h4 id=\"Fixing-the-alignment-bug\"><a href=\"#Fixing-the-alignment-bug\" class=\"headerlink\" title=\"Fixing the alignment bug\"></a>Fixing the alignment bug</h4><p>下面就利用layout guide来修复列表页面文字内容上下不居中的问题。看下图是我们设置的约束，我们设置label距离上面的距离是15，当下面的label显示一行的时候是正常的，如果要是两行了，由于上面的约束是固定的，最终就变成了不居中的效果了。<br><img src=\"/images/2016.01.13/11.png\" alt=\"\">   </p>\n<p>在iOS 9之前，我们想解决这个问题可以把两个label放置到一个container view容器中，设置这个container view为剧中，这里面的container view就是不可见的view即dummy view。现在在iOS 9上我们可以使用layout guide来代替这个view。   </p>\n<p>目前只能通过代码来添加layout guide。打开VacationSpotCell.swift文件，修改对应代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">awakeFromNib</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.awakeFromNib()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Add layoutGuide code here to center the name and locationName labels vertically</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建layou guide</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> layoutGuide = <span class=\"type\">UILayoutGuide</span>()</span><br><span class=\"line\">    contentView.addLayoutGuide(layoutGuide)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置layout guide的约束</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> topConstraint = layoutGuide.topAnchor.constraintEqualToAnchor(nameLabel.topAnchor)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bottomConstraint = layoutGuide.bottomAnchor.constraintEqualToAnchor(locationNameLabel.bottomAnchor)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> centerConstraint = layoutGuide.centerYAnchor.constraintEqualToAnchor(contentView.centerYAnchor)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 激活layout guide的约束</span></span><br><span class=\"line\">    <span class=\"type\">NSLayoutConstraint</span>.activateConstraints([topConstraint, bottomConstraint, centerConstraint])</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行APP发现，部分文字被截断了：<br><img src=\"/images/2016.01.13/12.png\" alt=\"\"> </p>\n<h4 id=\"处理截断问题\"><a href=\"#处理截断问题\" class=\"headerlink\" title=\"处理截断问题\"></a>处理截断问题</h4><p>这个原因是我们设置layout guide居中，但是nameLabel(上面的)与super view top的约束还存在，造成了下面的label被挤压了，这时候我们只要删除掉这个约束就可以了。但是删除了之后storyboard会提示错误，这时候我们可以使用占位约束，这个主要是为了使storyboard不报错，在运行的时候并不会使用。<br><img src=\"/images/2016.01.13/13.png\" alt=\"\"> </p>\n<p>最近一直在加班，断断续续整理了好久终于整理完了这篇文章了，可能会有错误，还请大家指出。</p>\n","excerpt":"<p>今天这是第六篇笔记，现在回过头去看，我也没有想到自己能够更新到第六篇。我算是一个比较懒的人了，现在已经不太喜欢动手敲代码了。在写这几篇笔记的时候，我需要一边看英文的文档，一边测试代码，还得考虑怎么能够写明白。这里有点说明，我的英语水平只是四级，语文水平只能用呵呵评价了，文章中的语句难免会有不通顺的地方，希望能够把语义表述清楚。    </p>\n<p>闲话多了，回到正题，这篇文章介绍UIStackView和一些Auto Layout的改变。   </p>\n<p>UIStackView我个人理解是为了解决使用Storyboard添加的约束需要经常变化的情况。我想我们可能都在开发中遇到过修改约束的情况，一般是把约束与一个outlet的约束link起来，然后代码修改，但是这个操作起来是不方便的。UIStackView通过修改一些简单的属性，例如alignment, distribution, and spacing，从而让UIStackView根据我们的修改自动调整内部的显示。    </p>\n<p>Auto Layout的改变主要是介绍layout anchors和layout guides。</p>","more":"<h3 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h3><p>打开本章的配套的工程VacationSpots，在iPhone 6模拟器上运行，能够看到APP有一些UI的问题，不要担心，在后面将会修复这些问题。简单梳理一下问题如下：</p>\n<ol>\n<li><p>图中标出的内容没有在垂直方向居中<br><img src=\"/images/2016.01.13/01.png\" alt=\"\">  </p>\n</li>\n<li><p>点击列表中的London Cell进入详情页面，最下面的三个按钮没有平均分配空间：<br><img src=\"/images/2016.01.13/02.png\" alt=\"\">  </p>\n</li>\n<li><p>点击WEATHER旁边的hide按钮，内容是被隐藏了，但是留下了一块空白，下面的内容没有移动上来：<br><img src=\"/images/2016.01.13/03.png\" alt=\"\">    </p>\n</li>\n<li><p>WHAT TO SEE 部分在WHY VISIT的下面会更加合理一点。  </p>\n</li>\n</ol>\n<p>现在已经了解了这些问题，下面开始用UIStackView来修改这些问题。打开Main.storyboard，查看如下的Controller scene：<br><img src=\"/images/2016.01.13/04.png\" alt=\"\">    </p>\n<blockquote>\n<p>能够注意到上面的每个对应的控件都有背景颜色，这个只是为了帮助我们查看这些属性的变化。这些背景颜色在运行的时候都会被去掉，通过如下代码，如果你想让它们在运行的时候也显示注释掉这些代码就可以：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SpotInfoViewController.swift</span></span><br><span class=\"line\"> <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Clear background colors from labels and buttons</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> view <span class=\"keyword\">in</span> backgroundColoredViews &#123;</span><br><span class=\"line\">      view.backgroundColor = <span class=\"type\">UIColor</span>.clearColor()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ........</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>    </p>\n</blockquote>\n<p>在Storyboard中的的控件都通过outlet与SpotInfoViewController.swift中对应的属性进行了关联。在storyboard中显示的名字对应SpotInfoViewController.swift对应的变量。  </p>\n<h4 id=\"Your-first-stack-view\"><a href=\"#Your-first-stack-view\" class=\"headerlink\" title=\"Your first stack view\"></a>Your first stack view</h4><p>我们先用Stack View解决我们问题列表中底部按钮的问题。使用UIStackView能够在一个坐标抽上分配位置和控件之间的空间。幸运的是将Views嵌入到UIStackView中并没有太难。在Storyboard中的Spot Info View Controller选择如下三个按钮控件：<br><img src=\"/images/2016.01.13/05.png\" alt=\"\"></p>\n<p>选择好三个按钮后，在Storyboard中点击如下的按钮：<br><img src=\"/images/2016.01.13/06.png\" alt=\"\"></p>\n<p>当Views被嵌入UIStackView之后，Views的约束都被移除了，同时需要设置UIStackView的约束。选中UIStackView，然后按照如图添加约束：<br><img src=\"/images/2016.01.13/07.png\" alt=\"\"></p>\n<blockquote>\n<p>这里有个选择UIStackView的技巧，由于UIStackView是在按钮的后面，很不好选中，我们可以按住Shift，右击，在出现的菜单中列出来当前点击位置所有的View，我们可以选择UIstackView。另一种方法我们可以在outline view中选择。   </p>\n</blockquote>\n<p>设置好约束后，能够看到按钮显示如下，第一个按钮被拉伸了，填充满了UIStackView的剩余空间。UIstackView有一个Distribution属性，用于控制Views怎么在UIStackView中显示，现在设置的是Fill，即将会填充满UIStackView。为了这个目的，UIstackView将会根据View的ccontent hugging优先级去拉伸View，最低的将会被拉伸。如果优先级一样，将会拉伸第一个。<br><img src=\"/images/2016.01.13/08.png\" alt=\"\">  </p>\n<p>我们的目的是让View间的距离相等，在Attributes inspector中修改Distribution为Equal Spacing。<br><img src=\"/images/2016.01.13/09.png\" alt=\"\"></p>\n<p>运行APP，能够看到我们的按钮显示正确了：<br><img src=\"/images/2016.01.13/10.png\" alt=\"\">  </p>\n<h4 id=\"一些思考\"><a href=\"#一些思考\" class=\"headerlink\" title=\"一些思考\"></a>一些思考</h4><p>思考一下你使用Auto Layout，通过约束实现上面的要求，那将是一种什么令人”愉悦”的行为。可能你很熟悉Auto Layout，认为这些东西都很简单，那么你在考虑一下如果我们后面有需求添加一个按钮，删除一个按钮呢，怎么办呢？约束删除了重新添加吗？如果使用UIStackView，这些将变得比较简单，只要我们添加或者删除View，其他的工作UIstackView就会帮我们做了。    </p>\n<p>UISTackView的更加深入的讲解，将会在下一篇文章中继续介绍。这里先介绍一下Auto Layout的新特性：layout anchors和layout guides。</p>\n<h3 id=\"Layout-anchors\"><a href=\"#Layout-anchors\" class=\"headerlink\" title=\"Layout anchors\"></a>Layout anchors</h3><p>Layout anchors提供了我们一种简单的创建约束的方式。  </p>\n<p>想象一下我们在iOS 9之前创建一个约束，简直就是天书，但是在iOS 9中使用Layout anchors将会简单好多，下面是两种的对比：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// iOS9以前</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> constraint = <span class=\"type\">NSLayoutConstraint</span>(item: topLabel, attribute: .<span class=\"type\">Bottom</span>, relatedBy: .<span class=\"type\">Equal</span>, toItem: bottomLabel, attribute: .<span class=\"type\">Top</span>, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// iOS 9</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> constraint = topLabel.bottomAnchor.constraintEqualToAnchor(bottomLabel.topAnchor, constant: <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>   </p>\n<p>Layout anchors不仅理解起来简单，而且写起来也简单了。   </p>\n<p>对应于我们在iOS 9以前添加约束时候的attribute，基本都有与之对应的anchor，例如top对应topAnchor，bottom对应bottomAnchor等。Layout Anchor都是直接或者间接继承自NSLayoutAnchor，上面只是演示了一下相等的情况，我们都知道在约束中又大于小于等，下面列出NSLayoutAnchor的接口文件，从接口文件中能够清楚的了解到对应的方法：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Foundation</span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*\tNSLayoutAnchor.h</span><br><span class=\"line\">\tCopyright (c) 2015, Apple Inc. All rights reserved.</span><br><span class=\"line\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* An NSLayoutAnchor represents an edge or dimension of a layout item.  Its concrete </span><br><span class=\"line\"> subclasses allow concise creation of constraints.  </span><br><span class=\"line\">    Instead of invoking </span><br><span class=\"line\"> </span><br><span class=\"line\"> +[NSLayoutConstraint constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:] </span><br><span class=\"line\"> </span><br><span class=\"line\"> directly, you can instead do something like this:</span><br><span class=\"line\"> </span><br><span class=\"line\"> [myView.topAnchor constraintEqualToAnchor:otherView.topAnchor constant:10];</span><br><span class=\"line\"> </span><br><span class=\"line\"> The -constraint* methods are available in multiple flavors to support use of different</span><br><span class=\"line\"> relations and omission of unused options.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutAnchor</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form thisAnchor = otherAnchor.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form thisAnchor = otherAnchor + constant.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutAnchor!, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Axis-specific subclasses for location anchors: top/bottom, leading/trailing, baseline, etc.</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutXAxisAnchor</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutYAxisAnchor</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* This layout anchor subclass is used for sizes (width &amp; height).</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NSLayoutDimension</span> : <span class=\"title\">NSLayoutAnchor</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisVariable = constant.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToConstant</span><span class=\"params\">(<span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisAnchor = otherAnchor * multiplier.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* These methods return an inactive constraint of the form </span><br><span class=\"line\">        thisAnchor = otherAnchor * multiplier + constant.</span><br><span class=\"line\">    */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintGreaterThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">constraintLessThanOrEqualToAnchor</span><span class=\"params\">(anchor: NSLayoutDimension!, multiplier m: CGFloat, constant <span class=\"built_in\">c</span>: CGFloat)</span></span> -&gt; <span class=\"type\">NSLayoutConstraint</span>!</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>在上面的接口文件中，我们能够清楚的了解到NSLayoutAnchor有三个子类：NSLayoutXAxisAnchor，NSLayoutYAxisAnchor，NSLayoutDimension。下面列出了UIView的Anchor都是对应的那种类型：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Constraint creation conveniences. See NSLayoutAnchor.h for details.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> leadingAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> trailingAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> leftAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> rightAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">\t<span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> centerXAnchor: <span class=\"type\">NSLayoutXAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> topAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> bottomAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> firstBaselineAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> lastBaselineAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> centerYAnchor: <span class=\"type\">NSLayoutYAxisAnchor</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> widthAnchor: <span class=\"type\">NSLayoutDimension</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">    <span class=\"meta\">@available</span>(iOS <span class=\"number\">9.0</span>, *)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">var</span> heightAnchor: <span class=\"type\">NSLayoutDimension</span> &#123; <span class=\"keyword\">get</span> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>   </p>\n<p>上面UIView的Anchor属性被分成了三类，同样我们在设置属性的时候，也要求同类的属性的才能设置，比如ViewA和ViewB之间的约束，ViewA-topAnchor和ViewB-bottomAnchor是可以的，ViewA-topAnchor和ViewB-leftAnchor就是不允许的，如果这样的话编译器会警告，运行时也会报错。</p>\n<blockquote>\n<p>注意： whyVisitLabel.topAnchor.constraintEqualToAnchor(whatToSeeLabel.leftAnchor) 这个按照上面的说法应该会报错的，但是我在运行的时候也没有报错，可能是我这里只是随便写出一个做测试的原因，后续我会继续试验一下这个知识点，然后再改正。   </p>\n</blockquote>\n<h3 id=\"Layout-guides\"><a href=\"#Layout-guides\" class=\"headerlink\" title=\"Layout guides\"></a>Layout guides</h3><p>有时候我们想设置两个View之间的空间，需要在两个View之间添加一个不可见的View（dummy view），然后在设置约束。Layout guide可以理解为一个隐形的不可见View，我们能够使用它的矩形边缘来布局，我们可以像我们使用View一样设置约束。使用Layout guide的好处是轻量，而且不会在view的层级中，也不会参与事件的响应过程。layout guide也包含除了firstBaselineAnchor和lastBaselineAnchor之外的View所有的Anchor。 </p>\n<h4 id=\"Fixing-the-alignment-bug\"><a href=\"#Fixing-the-alignment-bug\" class=\"headerlink\" title=\"Fixing the alignment bug\"></a>Fixing the alignment bug</h4><p>下面就利用layout guide来修复列表页面文字内容上下不居中的问题。看下图是我们设置的约束，我们设置label距离上面的距离是15，当下面的label显示一行的时候是正常的，如果要是两行了，由于上面的约束是固定的，最终就变成了不居中的效果了。<br><img src=\"/images/2016.01.13/11.png\" alt=\"\">   </p>\n<p>在iOS 9之前，我们想解决这个问题可以把两个label放置到一个container view容器中，设置这个container view为剧中，这里面的container view就是不可见的view即dummy view。现在在iOS 9上我们可以使用layout guide来代替这个view。   </p>\n<p>目前只能通过代码来添加layout guide。打开VacationSpotCell.swift文件，修改对应代码：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">awakeFromNib</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.awakeFromNib()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Add layoutGuide code here to center the name and locationName labels vertically</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建layou guide</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> layoutGuide = <span class=\"type\">UILayoutGuide</span>()</span><br><span class=\"line\">    contentView.addLayoutGuide(layoutGuide)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 设置layout guide的约束</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> topConstraint = layoutGuide.topAnchor.constraintEqualToAnchor(nameLabel.topAnchor)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bottomConstraint = layoutGuide.bottomAnchor.constraintEqualToAnchor(locationNameLabel.bottomAnchor)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> centerConstraint = layoutGuide.centerYAnchor.constraintEqualToAnchor(contentView.centerYAnchor)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 激活layout guide的约束</span></span><br><span class=\"line\">    <span class=\"type\">NSLayoutConstraint</span>.activateConstraints([topConstraint, bottomConstraint, centerConstraint])</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>运行APP发现，部分文字被截断了：<br><img src=\"/images/2016.01.13/12.png\" alt=\"\"> </p>\n<h4 id=\"处理截断问题\"><a href=\"#处理截断问题\" class=\"headerlink\" title=\"处理截断问题\"></a>处理截断问题</h4><p>这个原因是我们设置layout guide居中，但是nameLabel(上面的)与super view top的约束还存在，造成了下面的label被挤压了，这时候我们只要删除掉这个约束就可以了。但是删除了之后storyboard会提示错误，这时候我们可以使用占位约束，这个主要是为了使storyboard不报错，在运行的时候并不会使用。<br><img src=\"/images/2016.01.13/13.png\" alt=\"\"> </p>\n<p>最近一直在加班，断断续续整理了好久终于整理完了这篇文章了，可能会有错误，还请大家指出。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cipyqsl0900023is6zzi972bl","category_id":"cipyqsl0g00053is6jio1ihsw","_id":"cipyqsl0o000c3is6rjkv0fvm"},{"post_id":"cipyqsl0c00033is69l727bbw","category_id":"cipyqsl0n000a3is69g6lrg47","_id":"cipyqsl0s000k3is6ubvoa2pj"},{"post_id":"cipyqsl0h00063is6r4kn6ya9","category_id":"cipyqsl0q000f3is69z6n5zdp","_id":"cipyqsl0w000q3is6wxip1lq7"},{"post_id":"cipyqsl0i00073is62p71z0zy","category_id":"cipyqsl0q000f3is69z6n5zdp","_id":"cipyqsl0y000x3is6y5yb7tf1"},{"post_id":"cipyqsl0x000u3is69pi29lem","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1200133is6wefield1"},{"post_id":"cipyqsl0j00093is6dedgsgw5","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1300163is68dyuye49"},{"post_id":"cipyqsl0y000w3is6i1yxdo5r","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1600193is6qfyxtz8y"},{"post_id":"cipyqsl0z00113is6uhkqo274","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl18001c3is6ukmv3cjy"},{"post_id":"cipyqsl0n000b3is6iliojajv","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl19001f3is6yaep4oww"},{"post_id":"cipyqsl0p000d3is6uq57m4zy","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1b001h3is650cv2rmc"},{"post_id":"cipyqsl0r000h3is6iy36490h","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1d001k3is6gn8edu0w"},{"post_id":"cipyqsl0s000j3is6zzaf3in1","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1d001n3is60ew00f03"},{"post_id":"cipyqsl0u000n3is6zyh0moqw","category_id":"cipyqsl0w000s3is6wq50ge4x","_id":"cipyqsl1e001o3is6jh83c8yj"}],"PostTag":[{"post_id":"cipyqsl0900023is6zzi972bl","tag_id":"cipyqsl0d00043is6imo3c735","_id":"cipyqsl0r000g3is6d42lc7as"},{"post_id":"cipyqsl0900023is6zzi972bl","tag_id":"cipyqsl0j00083is62cpfl7u7","_id":"cipyqsl0r000i3is6pt9x08x0"},{"post_id":"cipyqsl0c00033is69l727bbw","tag_id":"cipyqsl0q000e3is6yi7quqgr","_id":"cipyqsl0u000o3is6u7s17a47"},{"post_id":"cipyqsl0u000n3is6zyh0moqw","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl0w000r3is6bcgnj675"},{"post_id":"cipyqsl0i00073is62p71z0zy","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl0y000v3is68zkhiqx6"},{"post_id":"cipyqsl0x000u3is69pi29lem","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl0z000y3is65t29b6kh"},{"post_id":"cipyqsl0j00093is6dedgsgw5","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl1200123is6l5civg18"},{"post_id":"cipyqsl0y000w3is6i1yxdo5r","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl1300143is6z7zk9sri"},{"post_id":"cipyqsl0z00113is6uhkqo274","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl1500183is61mpz3avv"},{"post_id":"cipyqsl0n000b3is6iliojajv","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl17001a3is6nm4w6tgn"},{"post_id":"cipyqsl0p000d3is6uq57m4zy","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl19001e3is6xnk7f959"},{"post_id":"cipyqsl0r000h3is6iy36490h","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl1c001j3is6dfv3chaa"},{"post_id":"cipyqsl0s000j3is6zzaf3in1","tag_id":"cipyqsl0s000l3is64tbg6yjz","_id":"cipyqsl1d001m3is6wvbqg9tj"}],"Tag":[{"name":"Github","_id":"cipyqsl0d00043is6imo3c735"},{"name":"Hexo","_id":"cipyqsl0j00083is62cpfl7u7"},{"name":"React Native","_id":"cipyqsl0q000e3is6yi7quqgr"},{"name":"iOS 9","_id":"cipyqsl0s000l3is64tbg6yjz"}]}}