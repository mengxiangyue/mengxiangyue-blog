{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","path":"images/2015.12.23.NavigationBarTest.gif","modified":1},{"_id":"source/images/2015.12.19.06.png","path":"images/2015.12.19.06.png","modified":1},{"_id":"source/images/2015.12.19.05.png","path":"images/2015.12.19.05.png","modified":1},{"_id":"source/images/2015.12.19.04.png","path":"images/2015.12.19.04.png","modified":1},{"_id":"source/images/2015.12.19.03.png","path":"images/2015.12.19.03.png","modified":1},{"_id":"source/images/2015.12.19.02.png","path":"images/2015.12.19.02.png","modified":1},{"_id":"source/images/2015.12.19.01.png","path":"images/2015.12.19.01.png","modified":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","path":"img/mengxiangyue.jpg","modified":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/jacman/source/img/logo-back.png","path":"img/logo-back.png","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1}],"Cache":[{"_id":"source/_posts/Hexo结合Github-Pages搭建静态博客.md","shasum":"cfda02059e8a1c6ca0eb3434e3fdf71d5fda361c","modified":1450579367000},{"_id":"source/_posts/iOS-NavigationBar手势返回的时候跟随.md","shasum":"6c32668ab9b22a11c41538f2ee21971d221a3e0b","modified":1450886535000},{"_id":"source/_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","shasum":"974a44e2052be062a8e450f9c871454eb020b757","modified":1451179480000},{"_id":"source/CNAME","shasum":"82a91d02385750292b82a7d6b3734c8d98a928be","modified":1450112345000},{"_id":"source/about/index.md","shasum":"275236c2371c3501bf390165a8511172469e7ab7","modified":1450499801000},{"_id":"source/images/2015.12.19.03.png","shasum":"b2230e53726b0213972a7f341e44499e0aa3eb08","modified":1450522668000},{"_id":"source/images/2015.12.19.05.png","shasum":"ee6cb6d8d3ba4f298575de57f1aa3eb119ad45bc","modified":1450524952000},{"_id":"source/images/2015.12.19.06.png","shasum":"5dbc917107cd31245445b190dca5b726c0dfd10e","modified":1450529338000},{"_id":"source/images/2015.12.19.02.png","shasum":"1b4e204bbe1e798c3ebd4c209b1b51e68059231e","modified":1450521943000},{"_id":"source/images/2015.12.23.NavigationBarTest.gif","shasum":"c78d77a76a397b0848874414fc1f335ae60dee8c","modified":1450885231000},{"_id":"source/images/2015.12.19.01.png","shasum":"021c02950ab5581da6c035e40fb94e3b1a56ae1e","modified":1450521146000},{"_id":"source/images/2015.12.19.04.png","shasum":"880191f1f6ad386668bf9f70bec795e1a8d978b8","modified":1450523879000},{"_id":"themes/jacman/_config.yml","shasum":"f11a10f5308afb72990e4d60ff26049794ca701a","modified":1450577640000},{"_id":"themes/jacman/languages/default.yml","shasum":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1450111304000},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1450111304000},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"b79534df2651b79dca54ec17829a514ff55ecb46","modified":1450530033000},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"c645e8a77b5b13baf31a69da8365942747cb214f","modified":1450492919000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"facd1ecd2d45d0d6eb8dbf0b11be0a1be3c07613","modified":1450493978000},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"89f22cb6086c5244ecd01da3bb17d70f68e7d07f","modified":1450500196000},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"08119290adc3a7b0f0fe7b83699758569005c5bf","modified":1450502090000},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"c88bc8f5805173920a5fdd7e9234a850e3d8e151","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"b4c151839cb6ac81477db44ee1748aea4c37c8c8","modified":1450526363000},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"c4f527fff0070fbe65919053a16224412317f40d","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1450111304000},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/github-card.ejs","shasum":"5c759b6ea214bac56a393247de27e67ce73fb33f","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1450111304000},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1450111304000},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1450111304000},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1450111304000},{"_id":"themes/jacman/layout/index.ejs","shasum":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1450111304000},{"_id":"themes/jacman/layout/layout.ejs","shasum":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1450111304000},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1450111304000},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1450111304000},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1450111304000},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","shasum":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","shasum":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1450111304000},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"f016180726019927b9a835ed01e04d153f27a149","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"a0095f49f3531d777cb34513a64d367b742e5c14","modified":1450497664000},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"1136600932b97534b88465bf05ef313630b2de3d","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1450111304000},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1450111304000},{"_id":"themes/jacman/source/css/style.styl","shasum":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1450111304000},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1450111304000},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1450111304000},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1450111304000},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"53a9b87b9937fe6513a5da328909f94add3fbf79","modified":1450499063000},{"_id":"themes/jacman/source/img/logo.png","shasum":"29d05f497fc1aa9ecebd753b0e2e21241ed1fe0a","modified":1450503556000},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1450111304000},{"_id":"themes/jacman/source/img/mengxiangyue.jpg","shasum":"2563a79fce9ec04dc3b14545aeff3a56f81dd4d1","modified":1450498875000},{"_id":"themes/jacman/source/js/gallery.js","shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1450111304000},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1450111304000},{"_id":"themes/jacman/source/js/totop.js","shasum":"5a9ea00aa54adb83015f514690894bc123855bc3","modified":1450503375000},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","shasum":"57c3987166a26415a71292162690e82c21e315ad","modified":1450111304000},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1450111304000},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1450111304000},{"_id":"themes/jacman/source/img/author.jpg","shasum":"15de0631d5ccae00a8b2990ad957cfb51f58bc27","modified":1450491067000},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1450111304000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1450111304000},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1450111304000},{"_id":"themes/jacman/source/img/logo-back.png","shasum":"eafdece1be127ff95553a02976076653d5c0a422","modified":1450497033000}],"Category":[{"name":"iOS 9 by Tutoials","_id":"ciinut8930002gl6ea1o3lbii"},{"name":"iOS Tips","_id":"ciinut89f0007gl6e4trj6kx4"},{"name":"工具","_id":"ciinut89j000agl6e9qlgdagq"}],"Data":[],"Page":[{"title":"about","date":"2015-12-19T04:36:01.000Z","_content":"\n写点什么呢。。。。。。。。\n","source":"about/index.md","raw":"title: about\ndate: 2015-12-19 12:36:01\n---\n\n写点什么呢。。。。。。。。\n","updated":"2015-12-19T04:36:41.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciinut88o0000gl6ehyziuhvq"}],"Post":[{"title":"iOS9 by Tutorials 学习笔记一：Swift 2.0","date":"2015-12-22T14:15:07.000Z","_content":"\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","source":"_posts/iOS9-by-Tutorials-学习笔记一：Swift-2-0.md","raw":"title: iOS9 by Tutorials 学习笔记一：Swift 2.0\ndate: 2015-12-22 22:15:07\ncategories:\n  - iOS 9 by Tutoials\ntags:\n  - iOS 9\n---\n\nApple在前段时间开源了Swift，在iOS开发领域中又制造了一阵骚动，看了一眼Swift的开发路线图，计划在明年的秋天发布Swift 3.0。Apple现在在Swift上变得也更加的开发，鼓励社区贡献代码，也开始接纳社区的一些反馈了。苹果改变以往的封闭的姿态，表明了它对于Swift语言的重视，同时也说明了Swift语言苹果会加大力度去优化，所以现在对于我们iOS开发人员来说，是时候开始学习iOS了。   \n前段时间也面试了几个人，简历里面好几个都写了精通Swift，但是一问问题好多都答不上来，简历上真的。。。。。更多的人貌似没有开始学Swift，但是最后我都建议他们去学习一下Swift。    \n扯远了，回到正题，这篇文章是我的学习笔记，非本人原创内容，只是在看《iOS 9 by Tutorials》这本书时候的一些笔记，然后加上自己的一些理解而已。    \n\nSwift 2中加入了几个（作者认为）比较重要的改进，如下：\n* 新的控制流\n* （相对）完善的错误处理模型\n* 协议扩展\n* 模式匹配的增强\n* API可用性检测\n* 其他一些。。。。。。\n\n### 控制流   \n在书中首先作者解释了一下控制流，感觉不错：程序中任何能够影响程序执行到不同的路径的结构或者关键字都可以叫做控制流，原文：any construct or keyword that causes the execution of your program to follow a different path can be considered \"control flow\".   \n#### repeat...while\nrepeat...while是重复的意思，类似于其他语言中的do...while。其实在Swift 1.x中还是使用的do...while，在2.x中为了与do...catch区分，所以改成了repeat，但是语义上还是没有变化。这里多说一句，Swift的好多改进，都是为了让程序读上去更加明确，例如Optional、guard等也有这方面的考虑。   \n> 本例子中的代码都是在Playground中实现的    \n\n{% codeblock lang:swift %}  \nvar x = 2\nrepeat {\n    print(\"x:\\(x)\")\n    x += 1 // Swift计划在3.0中移除 ++ -- 所以还是尽量少用吧\n} while x < 10 // 这个地方可以添加括号\n{% endcodeblock %}\n上面while后面可以不适用括号，这个也是Swift的一个改进，Swift中只有必要（即语义不明确）的时候才会要求必须加括号。\n\n<!--more-->\n\n#### guard\nguard这个词我也不知道怎么翻译，这里就不翻译了。但是这个关键字的作用的就是一个先决条件的检测。先看下面的例子：   \n\n{% codeblock lang:swift %}\nfunc printName(name: String) {\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}  \n\n上面的例子是一个没有意义的例子，只是为了演示。定义了一个函数打印传入的名字，这个函数的要求如果传入的name为空，就判定程序错误，然后返回不执行代码。**guard** 后面跟一个条件，条件为真的时候不会执行else，当条件为假的时候将会执行else，这样就能够达到了我们的要求。但是可能又回说，我用一个if-else也能够实现这个功能，但是如果要是跟Optional结合在一起就比if-else方便多了，下面继续看这个例子：  \n\n{% codeblock lang:swift %}\nfunc printName(inName: String?) { // 这里变成了可选值了\n    guard let name = inName else {\n        print(\"no name\")\n        return\n    }\n    guard !name.isEmpty else {\n        print(\"no name\")\n        return\n    }\n    print(name)\n}\nprintName(\"\")\nprintName(\"MengXiangYue\")\n{% endcodeblock %}    \n\n上面的例子中传入的参数是一个可选值，这时候使用『guard let name = \\_name else...』,这个类似于if let解包的方式，但是看下面我们使用guard声明的name变量，在下面是能够正常使用的，但是考虑如果使用if let这个就不能使用了，所以我认为guard结合Optional是使用起来最方便的。另外这个东西也可以实现类似NSAssert类似的功能，只是这个不会崩溃。\n\n### （相对）完善的错误处理模型\n这里我加了一个相对，主要是指的相对于Swift 1.x，2.x的错误处理好用了不少，但是相比于java等其他部分语言，还是不完善，Swift中的错误处理，对于抛出错误来说，你只是知道该函数抛出了错误，但是不清楚这个函数抛出了什么错误，书中有句话写的很正确，这个要求写程序的时候一定要在文档中写明，会抛出的各种异常（在java中会明确的抛出Exception，Exception与Swift的Error功能一致）。    \n\n另外相对于Objective-C的NSError把指针传递进去，然后等函数执行完成之后检查，已经先进了不少，鼓掌。。。。。   \n定义下面的一个协议：   \n\n{% codeblock %} swift\nprotocol JSONParsable {\n    static func parse(json: [String: AnyObject]) throws -> Self\n}\n{% endcodeblock %}  \n\n这个协议定义了一个静态方法，这里不能叫做类方法，以为协议同时可以应用到Struct上，可以叫类型方法。这个函数使用了**throws** 关键字，这个关键字表示该方法可能会抛出一个错误，这里也看不出来抛出什么错误（你妹啊，啥错误都不知道），所以就更加突出这时候注释的重要性（可以写篇文章：论注释的重要性，哈哈哈）。   \n\n那既然说到抛出错误，那我们就得定义错误，在Swift中定义错误比较容易，只要定义一个枚举类型，然后遵守**ErrorType** 协议就可以了。OC中的NSError同样也实现了**ErrorType** 协议，所以我们能够在OC和Swift中使用NSError没有问题。下面定义一个错误：\n\n{% codeblock lang:swift %}\nenum ParseError: ErrorType {\n    case MissingAttribute(message: String)\n}\n{% endcodeblock %}\n\n定义一个错误比较简单，跟普通的枚举没什么不同，这里定义了一个有关联值的枚举。关联值这里要多扯一句，关联值这个东西在Swift中能够解决好多与类型相关的东西，有时候我们经常会遇到某个类型与值相关，比如我们自己的工程中，网络请求错误需要带着错误码和错误提示，这时候我在OC中可能需要返回三个参数，但是在Swift中我可以只是返回一个枚举，然后关联上另外的两个值。对于多个有关系的值，同样也可以使用元组，曾经看kingfisher的时候，作者把一个类的配置参数都放到一个元组里面，然后解析这个元组，这样参数可能更加清晰。   \n又扯远了，回到正题。下面我们实现一个结构体Person：\n\n{% codeblock lang:swift %}\nstruct Person: JSONParsable {\n    let firstName: String\n    let lastName: String\n\n    static func parse(json: [String : AnyObject]) throws -> Person {\n        guard let firstName = json[\"first_name\"] as? String else {\n            let message = \"Expected first_name String\"\n            throw ParseError.MissingAttribute(message: message) // 1\n        }\n\n        guard let lastName = json[\"last_name\"] as? String else {\n            let message = \"Expected last_name String\"\n            throw ParseError.MissingAttribute(message: message) // 2\n        }\n        return Person(firstName: firstName, lastName: lastName)\n    }\n}\n{% endcodeblock %}  \n\n代码比较简单就不过多解释了，就是在不同情况下抛出不同的异常。我们在调用这个方法的时候，需要处理这些异常，这时候就使用到了Swift中的do...catch。下面是代码：\n\n{% codeblock lang:swift %}\ndo {\n    let person = try Person.parse([\"foo\": \"bar\"])\n} catch ParseError.MissingAttribute(let message) {\n        print(message)\n} catch {\n        print(\"Unexpected ErrorType\")\n}\n{% endcodeblock %}    \n\ndo后面需要使用{}将抛出异常的函数包起来，调用抛出异常的方法的时候，需要使用try关键字，然后后面跟着需要捕获的异常，如果清楚需要捕获的异常的类型，可以再catch后面加上异常类型，如果没有异常类型，那表示捕获所有的异常。异常会按照catch的顺序挨个匹配，直到找到第一个匹配的结束。   \n\n如果我们对于异常不关心，我们可以使用try?、try!调用方法，其中try?调用方法会返回一个Optional值，如果调用成功将会返回对应的结果，如果失败则返回nil，程序一定不会崩溃，但是如果我们直接使用try!如果有异常抛出，程序将会崩溃。所以只有在保证我们调用的函数不会抛出异常的时候才能使用try!。  \n\n{% codeblock lang:swift %}\nlet p1 = try? Person.parse([\"foo\": \"bar\"])  // nil\nlet p2 = try! Person.parse([\"first_name\": \"Ray\", \"last_name\": \"Wenderlich\"]) // Person\nlet p3 = try! Person.parse([\"foo\": \"bar\"]) // error crash\n{% endcodeblock %}\n\n### 协议扩展\n在这一部分使用一个例子来介绍协议扩展，协议扩展是在Swift 2.x中一个比较重要的思想。详细的可以看看WWDC 2015 Session 408了解。下面定义一个验证字符串规则的一个协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidationRule {\n    func validate(string: String) throws -> Bool // 验证是否合法的方法\n    var errorType: StringValidationError { get }  // error的类型\n}\n{% endcodeblock %}  \n\n上面定义了校验规则的协议，下面定义一个校验器协议：  \n\n{% codeblock lang:swift %}\nprotocol StringValidator {\n    var validationRules: [StringValidationRule] { get }\n    func validate(string: String) -> (valid: Bool, errors: [StringValidationError])\n}\n{% endcodeblock %}   \n\nStringValidator这个校验器，有一个保存校验规则的数组，然后有一个校验方法，返回一个元祖，包含最终的校验结果，及错误。这里我们考虑一下对于校验器可能我们处理的逻辑都是一样的，就是循环所有的校验规则，然后查看是否校验成功。这个逻辑算是比较一致，如果我们把这个放到每个实现该协议的类型里面，那代码可能会重复。这时候我们可以提供一个默认的实现，这就是协议扩展（类似于虚函数的功能）。   \n\n{% codeblock lang:swift %}\nextension StringValidator {\n    func validate(string: String) -> (valid: Bool, errors:[StringValidationError]) {\n\n        var errors = [StringValidationError]()\n        for rule in validationRules {\n            do {\n                try rule.validate(string)\n            } catch let error as StringValidationError {\n                errors.append(error)\n            } catch let error {\n                fatalError(\"Unexpected error type: \\(error)\")\n            }\n        }\n        return (valid: errors.isEmpty, errors: errors)\n    }\n}\n{% endcodeblock %}\n\n下面我们实现一个字符串以某些字符开始和以某些字符结束的的规则。首先定义一下上面的StringValidationError\n{% codeblock lang:swift %}\n// 错误类型\nenum StringValidationError: ErrorType {\n    case MustStartWith(set: NSCharacterSet, description: String)\n    case MustEndWith(set: NSCharacterSet, description: String)\n    var description: String {\n      let errorString: String\n      switch self {\n      case .MustStartWith(\\_, let description):\n        errorString = \"Must start with \\(description).\"\n      case .MustEndWith(\\_, let description):\n        errorString = \"Must end with \\(description).\"\n      }\n      return errorString\n    }\n}   \n\n// 扩展String\nextension String {\n    public func startsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: startIndex..<startIndex.successor()) != nil\n    }\n\n    public func endsWithCharacterFromSet(set: NSCharacterSet) -> Bool {\n        guard !isEmpty else {\n            return false\n        }\n\n        return rangeOfCharacterFromSet(set, options: [], range: endIndex.predecessor()..<endIndex) != nil\n    }\n}\n\nstruct StartsWithCharacterStringValidationRule : StringValidationRule {\n\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustStartWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        string\n        if string.startsWithCharacterFromSet(characterSet) {\n            return true\n        } else{\n            throw errorType // 4\n        }\n    }\n}\n\nstruct EndsWithCharacterStringValidationRule: StringValidationRule {\n    let characterSet: NSCharacterSet\n    let description: String\n    var errorType: StringValidationError {\n        return .MustEndWith(set: characterSet, description: description)\n    }\n    func validate(string: String) throws -> Bool {\n        if string.endsWithCharacterFromSet(characterSet) {\n            return true\n        } else {\n            throw errorType\n        }\n    }\n}\n{% endcodeblock %}\n\n两个验证规则创建好了，下面我们创建一个校验器：\n{% codeblock lang:swift %}\n// 这个校验器实现了StringValidator，但是由于StringValidator存在扩展，所以可以不用实现该协议中的func validate(string: String) -> (valid: Bool, errors:[StringValidationError])方法\nstruct StartsAndEndsWithStringValidator: StringValidator {\n  let startsWithSet: NSCharacterSet\n  let startsWithDescription: String\n  let endsWithSet: NSCharacterSet\n  let endsWithDescription: String\n  var validationRules: [StringValidationRule] {\n    return [\n      StartsWithCharacterStringValidationRule(characterSet: startsWithSet, description: startsWithDescription),\n      EndsWithCharacterStringValidationRule(characterSet: endsWithSet, description: endsWithDescription)\n    ]\n  }\n}\n\n// 下面使用一下\net numberSet = NSCharacterSet.decimalDigitCharacterSet()\nlet startsAndEndsWithValidator = StartsAndEndsWithStringValidator(startsWithSet: letterSet, startsWithDescription: \"letter\", endsWithSet: numberSet, endsWithDescription: \"number\")\n\nstartsAndEndsWithValidator.validate(\"1foo\").errors.description\n{% endcodeblock %}   \n\n上面的内容是一个简单的例子，我将书中的例子做了一些简化。   \n\n下面我们再看一个例子，在扩展协议的时候我们可以结合where关键字，使符合where条件的类型，才会自动的存在默认的协议扩展。\n{% codeblock lang:swift %}\n// 扩展了MutableCollectionType协议，这个协议仅对Index为Int类型的实现了MutableCollectionType的类型生效  \n// Index是定义在MutableCollectionType的父协议MutableIndexable中的关联类型\nextension MutableCollectionType where Index == Int {\n  // 该方法任意的交换集合元素\n  mutating func shuffleInPlace() {\n    let c = self.count\n    for i in 0..<(c-1) {\n      let j = Int(arc4random_uniform(UInt32(c - i))) + i\n      guard i != j else { continue }\n      swap(&self[i], &self[j])\n    }\n  }\n}\n\nvar people = [\"Chris\", \"Ray\", \"Sam\", \"Jake\", \"Charlie\"]\npeople.shuffleInPlace()\n{% endcodeblock %}\n\n### 模式匹配的增强   \n在Swift中可以不仅可以再实现协议扩展的时候使用，还可以在for循环，也可以在if-let、switch、if-case的使用，如下例子：\n{% codeblock lang:swift %}\nlet names = [\"Charlie\", \"Chris\", \"Mic\", \"John\", \"Craig\", \"Felipe\"]\nvar namesThatStartWithC = [String]()\n// 将以\"C\"开头的名字，加入到数组namesThatStartWithC中\nfor cName in names where cName.hasPrefix(\"C\") {\n  namesThatStartWithC.append(cName)\n}\n\n// 定义一个Author\npublic struct Author {\n    public let name: String\n    public let status: Additional_Things_PageSources.AuthorStatus\n    public init(name: String, status: Additional_Things_PageSources.AuthorStatus)\n}\nlet authors = [\n  Author(name: \"Chris Wagner\", status: .Late(daysLate: 5)),\n  Author(name: \"Charlie Fulton\", status: .Late(daysLate: 10)),\n  Author(name: \"Evan Dekhayser\", status: .OnTime)\n]\nvar slapLog = \"\"\nfor author in authors {\n  if case .Late(let daysLate) = author.status where daysLate > 2 {\n    slapLog += \"Ray slaps \\(author.name) around a bit with a large trout \\n\"\n  }\n}\n{% endcodeblock %}\n\n### API可用性检测\n在Swift 2.x中检测某个API是否可用，不用像原来一样判断是否能够响应某个API，直接使用如下代码，使其在该版本系统下生效即可：\n{% codeblock lang:swift %}\nif #available(iOS 9.0, \\*) {\n  // 调用在iOS 9下才能使用的API\n}\n{% endcodeblock %}\n\n### defer关键字\ndefer在Swift中表示，在方法结束的时候一定会调用的代码。在程序中我们经常将一些内存回收、状态回复等动作放在代码的最后，但是如果在前面代码执行的过程中，发生了异常，那么可能后面的代码就不能执行，造成程序错误。但是使用defer关键字，能够保证不管程序是否正常结束，该代码一定会被执行。   \n\n例如在使用ATM的时候，不管使用的过程中发生了什么异常都必须保证最后必须把银行卡退给用户，这个在这里使用defer关键字就比较合适。\n\n{% codeblock lang:swift %}\nstruct ATM {\n  mutating func dispenseFunds(amount: Float, inout account: Account) throws{\n   defer {  // 保证一定能够退卡成功\n     log += \"Card for \\(account.name) has been returned to customer.\\n\"\n     ejectCard()\n   }\n   // 其他的逻辑处理\n }\n  func ejectCard() {\n    // physically eject card\n  }\n}\n{% endcodeblock %}   \n\n终于是把这篇文章算是写完了，后面的一部分都是一些小的知识点，慢慢积累吧，自己的读书笔记，希望对别人有帮助吧。\n","slug":"iOS9-by-Tutorials-学习笔记一：Swift-2-0","published":1,"updated":"2015-12-27T01:24:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciinut88x0001gl6er0lgzijt"},{"title":"iOS NavigationBar手势返回的时候跟随","date":"2015-12-23T15:22:39.000Z","_content":"\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","source":"_posts/iOS-NavigationBar手势返回的时候跟随.md","raw":"title: iOS NavigationBar手势返回的时候跟随\ndate: 2015-12-23 23:22:39\ncategories:\n  - iOS Tips\ntags:\n---\n\n在iOS的开发中有时候会遇到这样的情况，在开发的过程中有两个界面，这两个界面使用UINavigationController串联起来，然后在第一个ViewController中不显示UINavigationBar，在第二个显示UINavigationBar。iOS在手势返回的时候默认情况下iOS的NavigationBar是固定的，然后再去做一些渐变位移等动画，但是如果我们在一个界面有NavigationBar，一个没有这样的动画就会很难看。这时候我们希望第二个界面手势返回的时候，NavigationBar跟着界面一起移动。 实现类似下面的效果:   \n\n![](/images/2015.12.23.NavigationBarTest.gif)  \n\n<!--more-->\n\n这个效果中有两个ViewController，在第二个Controller手势返回的时候，UINavigationBar是跟随着Controller的。如果只是在第一个界面的时候使用这种效果比较简单，只要在两个Controller中添加如下代码即可：\n\n{% codeblock lang:swift %}  \n// 第一个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    // 这里一定要使用这个方法 否则会有问题\n    self.navigationController?.setNavigationBarHidden(true, animated: true)\n}\n\n// 第二个ViewController\noverride func viewWillAppear(animated: Bool) {\n    super.viewWillAppear(animated)\n    self.navigationController?.setNavigationBarHidden(false, animated: true)\n}\n{% endcodeblock %}\n\n上面的代码只能实现第一个UINavigationController第一个ViewController隐藏，第二个显示的时候实现跟随效果。如果想实现所有的界面都有跟随的效果，那需要自定义ViewController的转场动画，网上有人已经实现了这个效果，感兴趣的可以下载看一下，地址：<https://github.com/esonchen/CCSlideNavigationTransition>。   \n\n这篇文章比较短，只是一个简单的Tip而已。\n","slug":"iOS-NavigationBar手势返回的时候跟随","published":1,"updated":"2015-12-23T16:02:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciinut89d0006gl6egb4i1tk1"},{"title":"Hexo结合Github Pages搭建静态博客","date":"2015-12-19T05:17:00.000Z","_content":"已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","source":"_posts/Hexo结合Github-Pages搭建静态博客.md","raw":"title: Hexo结合Github Pages搭建静态博客\ncategories:\n  - 工具\ntags:\n  - Github\n  - Hexo\ndate: 2015-12-19 13:17:00\n---\n已经好久没有写过博客了，主要是因为懒了。  \n前几天无聊点进了阿里云的广告里面，无意中看到了域名查询，查了一下自己的名字的域名，发现还没有注册（我原来记的这个域名是已经注册的了），然后就花钱买下了这个域名。然后因为这个买到的域名引出了了后面搭建博客的这么一堆事。  \n\n我自己已经有一个博客了，是在CSDN的博客，博客地址：<http://blog.csdn.net/mengxiangyue>,那个博客维护了好久了，从大三开始吧。断断续续也写了好多年了，里面的文章我个人感觉水平也就一般。但是因为这些水平一般的文章，我也收获了很多，首先是收获了一个笔记吧，然后是申请成功了CSDN的博客（伪）专家，因为这个专家的身份，有时候会参加一些CSDN举办的活动。说到写博客，我个人感觉最重要的是技术的积累，我也跟很多人说过写博客这个事情，但是貌似听的人不是特别多。  \n\n好了貌似扯得有点远了，下面进入正题。  \n上面我已经说过我买了一个域名，那就大概梳理一下提纲吧：  \n>1. 购买一个域名\n>2. 在github上面生成一个github pages的仓库\n>3. 搭建Hexo环境\n>4. 配置博客\n>5. 部署博客\n\n<!--more-->\n\n在开始介绍步骤之前，先扯几句Hexo、Github Pages的东西（我也不是完全了解，只是我的理解，如果哪里错了，还请指出）  Github Pages是Github提供的一个静态网站的功能，可以根据在Github仓库的HTML、CSS、js文件生成一个网站，然后提供一个二级域名，可以直接访问。这里说的静态网站，就是所有的页面的HTML页面都是静态的、已经生成好的，而不是动态生成的。   \nGithub Pages使用的是已经生成好的HTML，如果我们自己手动写HTML会累死的，所以就需要使用工具来生成。搭配Github Pages的比较不错的工具有jekyll、Hexo等，查了一下资料说jekyll比较复杂，Hexo比较简单，最后选择了后者。\n\n下面按步骤说吧：\n### 1. 购买一个域名  \n>这里如果你不想使用独立域名，也可以略过这一步    \n\n注册、登录阿里云账号，然后选择->域名与网站服务，查询自己想要的域名，加入清单，结算这样就买了一个域名。这里先不配置DNS，后面会说。  \n\n### 2. 在github上面生成一个github pages的仓库\n2.1 在github上创建一个仓库,名字你自己随便起就可以了。如图： ![](/images/2015.12.19.01.png)  \n2.2 创建完了后，选择该仓库的Settings，然后找到Github Pages部分。![](/images/2015.12.19.02.png)   \n点击了之后会进入选择主题，这时候随便选择，然后点击发布就可以了。做完了这些之后，我们可以访问以下http://<你的Github用户名>.github.com，这时候如果能够打开说明成功了。   \n\n### 3. 搭建Hexo环境\n3.1 安装npm、nodejs环境，这个自己百度吧，我就不写了。   \n3.2 安装Hexo   \n    执行如下命令：\n```shell\nnpm install hexo-cli -g # 安装hexo工具\n```\n3.3 初始化博客   \n```shell\nhexo init blog #初始化一个blog 可以cd到你想要生成博客的目录\ncd blog # 切换到创建博客的目录下\nnpm install # 安装nodejs依赖 注册这里一定要在init后面执行一次这个，否则可能会出现一些未知的错误\n```\n这时候生成的博客目录：![](/images/2015.12.19.03.png)   \n执行如下命令：    \n```shell\nhexo server\n```\n这时候在浏览器访问<http://0.0.0.0:4000/>，应该能够看到已经搭建好的博客了。  \n\n### 4. 配置博客\n这里主要配置主题、评论插件多说、RSS、域名。  \n我使用的主题是jacman，详细的介绍在[这篇文章](http://wuchong.me/jacman/2014/11/20/how-to-use-jacman/)已经介绍了，我这里只是说了一下我自己配置过程中的一些注意的地方。我的博客的源文件也已经开源了，如果有不明白的地方可以下载看一下，地址<https://github.com/mengxiangyue/mengxiangyue-blog>   \n每个配置项的后面留一个空格，然后再写配置的值，如下\"首页:\"与后面的\"/\"之间要留一个空格，否则会出现问题。\n```shell\n首页: /\n```\n如果一个配置项目包含多个子项目，子项目起始位置要留空格，如下：\n```shell\nimglogo:\n  enable: true  \n  src: img/logo.png\n```\n另外在配置的过程中，可能会出现看着配置项目没问题，然后就是出现错误，这时候可以试试换一个工具打开配置文件，然后配置，可能有些工具的编码问题造成的。   \n在配置的过程中涉及到图片的路径都在themes/jacman/source/img目录下面。   \n\n#### 配置多说插件\n注册多说（<http://duoshuo.com/>）账户，然后添加站点，按照自己的要求填写信息。![](/images/2015.12.19.04.png)  \n右上角点击你新建的使用多说的配置站点，然后看浏览器地址栏的地址，如果出现admin结尾，然后记录下来多说前面的用户名，比如我的是http://mengxinagyue.duoshuo.com/admin/ ，然后我的用户名就是mengxiangyue。找到配置文件在对应的地方改成你自己的用户名   \n```shell\nduoshuo_shortname: mengxinagyue  #修改成你自己的用户名\n```\n到这里多说配置完了。\n#### 配置RSS\n执行如下命令：\n```shell\nnpm install hexo-generator-feed --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\nPlugins:\n  hexo-generator-feed\n\n#Feed Atom\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\n```\n\n执行如下命令：\n> 这里先去创建一篇测试文章，因为多说插件只有在文章中才能看到，怎么创建文章，这个去看官方文档吧。\n\n```shell\nhexo generate  # 重新生成配置文件 保证我们的修改会生效\nhexo server\n```\n访问<http://0.0.0.0:4000/>，配置应该已经生效\n\n#### 配置域名\n安装阿里云的帮助文档，进入到域名解析配置页面，然后选择CNAME进行解析（这里的原理我也没有详细了解过），类似下面的配置（图中的域名修改为你自己的），然后保存。  \n![](/images/2015.12.19.04.png)  \n> 配置完后可能立即访问也没有效果，需要过一会才会生效，这个涉及到DNS的知识，请自己百度吧。  \n\n在你的博客的文件夹的source目录下创建一个\"CNAME\"文件，没有后缀，里面的内容就只是写上你的域名就可以了。\n\n### 5. 部署博客\n在命令行执行如下命令，安装hexo-deployer-git,这个主要适用于将博客部署到Github上的工具。\n```shell\nnpm install hexo-deployer-git --save\n```\n在博客的配置文件_config.yml中添加如下配置：\n```shell\ndeploy:\n  type: git\n  repo: <你的博客的仓库地址，即查看仓库时候浏览器地址栏的地址>\n```\n最后执行如下命令：\n> 在部署的过程中可能会需要输入用户名密码，如果还是不行可能还需要配置SSH，因为我的电脑原来早就已经配置过了，所以这里不清楚。  \n\n```shell\nhexo deploy\n```\n最后出现部署成功的提示，这时候访问你的博客应该就能看到最新的了。\n\n### 下面是我遇到的一些问题  \n\n1 about路径不存在    \n jacman主题上菜单栏里面有一个about菜单项目，它指向的地址是about/目录，我们可以使用如下命令创建该目录，然后修改里面的index.md文件。     \n\n ```shell\nhexo new page \"about\"\n```\n\n2 图片路径的问题\n我们可以在source目录下创建一个images目录，然后在使用的时候，使用相对路径，例如：'![](/images/2015.12.19.05.png)'  \n\n3 站内搜索\n配置了半天的百度搜索，只能说自己能力有限，最后懒得弄了，就没弄，如果有谁清楚，还请赐教。  \n\n4 目录序号错误  \nHexo如果开启文章目录，会根据Markdown的##标记自动生成文章目录，并且自动添加序号，但是如果我们的文章中也使用了序号，那就会出现两个序号，如图：   \n![](/images/2015.12.19.06.png)   \n我解决这个问题是是通过js删除了序号，因为我对于nodejs不熟悉，所以不能从那上面改只能想其他的方法了。在博客的themes/jacman/layout/\\_partial/after_footer.ejs文件中添加如下代码，代码位置可以参看我的Github工程：  \n\n```javascript\n<!-- 解决自动生成文章目录序号问题 -->\n<script type=\"text/javascript\">\nvar regex = new RegExp(\"^\\\\d+\\\\.\\\\d* \");\nvar tocItemTextArray = $(\".toc-article .toc-item .toc-text\");\nfor (var i = 0; i < tocItemTextArray.length; i++) {\n  var item = tocItemTextArray[i];\n  item.textContent = item.textContent.replace(regex, \"\");\n}\n</script>\n```\n\n\n5 回到顶部不显示   \njacman主题默认是滚动距离超过1000才会显示回到顶部按钮，如果文章过短将永远不会显示，我这里改成了300，可以在themes/jacman/source/js/totop.js中修改如下属性为300：   \n\n```shell\nvar upperLimit = 300;\n```   \n\n6 首页不展开配置\njacman提供在首页展开一部分文章，然后添加一个read more的提示。需要在jacman的配置文件中，找到如下配置，然后改成true，   \n\n```javascript\nindex:\n  expand: true  \n  excerpt_link: Read More\n```        \n然后需要在写文章的时候，在需要在首页截断显示的地方添加\"<!--more--\\>\"标签   \n\n7 写文章即使预览功能    \n在写文章的时候可能需要经常修改在浏览器预览效果这时候可以分别启用两个终端，然后分别执行如下的两条命令，这样就能够在修改后立即预览最新的 内容      \n\n>hexo generate --watch  #文件变动 立即重新生成\n>hexo server\n\n终于把这个写完了好费劲。如果有什么问题可以找我交流。PS: 不清楚为什么在添加代码片段的过程中，总是会出现错误。\n","slug":"Hexo结合Github-Pages搭建静态博客","published":1,"updated":"2015-12-20T02:42:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciinut89h0009gl6e8j8cetsv"}],"PostAsset":[],"PostCategory":[{"post_id":"ciinut88x0001gl6er0lgzijt","category_id":"ciinut8930002gl6ea1o3lbii","_id":"ciinut89a0005gl6e8bk6hcvz"},{"post_id":"ciinut89d0006gl6egb4i1tk1","category_id":"ciinut89f0007gl6e4trj6kx4","_id":"ciinut89f0008gl6excb6rib2"},{"post_id":"ciinut89h0009gl6e8j8cetsv","category_id":"ciinut89j000agl6e9qlgdagq","_id":"ciinut89k000dgl6ed9docxhj"}],"PostTag":[{"post_id":"ciinut88x0001gl6er0lgzijt","tag_id":"ciinut8930003gl6eloxg7to7","_id":"ciinut8990004gl6en4od3c4j"},{"post_id":"ciinut89h0009gl6e8j8cetsv","tag_id":"ciinut89j000bgl6e8a8s4iln","_id":"ciinut89k000egl6es455t4lv"},{"post_id":"ciinut89h0009gl6e8j8cetsv","tag_id":"ciinut89k000cgl6e2ekj7tdf","_id":"ciinut89l000fgl6e8lq5376p"}],"Tag":[{"name":"iOS 9","_id":"ciinut8930003gl6eloxg7to7"},{"name":"Github","_id":"ciinut89j000bgl6e8a8s4iln"},{"name":"Hexo","_id":"ciinut89k000cgl6e2ekj7tdf"}]}}